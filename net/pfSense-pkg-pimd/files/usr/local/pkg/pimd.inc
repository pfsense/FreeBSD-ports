<?php
/*
 * pimd.inc
 *
 * part of pfSense (https://www.pfsense.org)
 * Copyright (c) 2020 Rubicon Communications, LLC (Netgate)
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require_once("config.inc");
require_once("functions.inc");
require_once("interfaces.inc");
require_once("service-utils.inc");
require_once("util.inc");

define('PKG_PIMD_CONFIG_BASE', '/var/etc/pimd');
/* Since we need to embed this in strings & HERE Docs, copy to a var. Can't embed constants. */
global $pimd_config_base;
$pimd_config_base = PKG_PIMD_CONFIG_BASE;

global $pimd_auto_config_warning;
$pimd_auto_config_warning = <<<EOF
##################### DO NOT EDIT THIS FILE! ######################
###################################################################
# This file was created by an automatic configuration generator.  #
# The contents of this file will be overwritten without warning!  #
###################################################################

EOF;

require_once("pimd/inc/pimd_validation.inc");

/* Build a list of assigned/enabled interfaces, formatted for use in a selection
 * list, including IP Aliases, CARP VIPs, and OpenVPN interfaces. */
function pimd_get_interfaces($includedefault = true, $includevips = true, $includelocalhost = false, $nameprefix = "", $valueprefix = "") {
	global $config;

	/* Only include the 'default' option when requested, some places like
	 * OSPF interface selections can't use 'default'.
	 */
	if ($includedefault) {
		$interfaces['default'] = "default";
	} else {
		$interfaces = array();
	}
	if ($includelocalhost) {
		$interfaces['lo0'] = "Localhost (lo0)";
	}
	$interfaces = array_merge($interfaces, get_configured_interface_with_descr());
	$ifs = array();

	/* Change the interfaces array into one properly formatted for an XML GUI select_source list */
	foreach ($interfaces as $iface => $ifacename) {
		$tmp["name"] = $nameprefix . $ifacename;
		$tmp["value"] = $valueprefix . $iface;
		$ifs[] = $tmp;
	}

	/* Get a list of VIPs */
	if ($includevips) {
		$viplist = get_configured_vip_list();
		foreach ($viplist as $vip => $address) {
			$tmp["name"] = $nameprefix . $address;
			$tmp["value"] = $valueprefix . $vip.'|'.$address;
			if (get_vip_descr($address)) {
				$tmp["name"] .= " (" . get_vip_descr($address) . ")";
			}
			$ifs[] = $tmp;
		}
	}

	/* Create a list of OpenVPN server and client interfaces. */
	foreach (array('server', 'client') as $mode) {
		if (is_array($config['openvpn']["openvpn-{$mode}"])) {
			foreach ($config['openvpn']["openvpn-{$mode}"] as $id => $setting) {
				if (!isset($setting['disable'])) {
					$tmp["name"] = $nameprefix . gettext("OpenVPN") . " ".$mode.": ".htmlspecialchars($setting['description']);
					$tmp["value"] = $valueprefix . 'ovpn' . substr($mode, 0, 1) . $setting['vpnid'];
					$ifs[] = $tmp;
				}
			}
		}
	}
	return $ifs;
}

/* Simple utility function to translate a select_source list of items into a
 * list of values for easier testing by in_array() and similar cases. */
function pimd_get_list_values($arr) {
	$vals = array();
	foreach ($arr as $a) {
		$vals[] = $a['value'];
	}
	return $vals;
}

function pimd_generate_rcfile() {
	global $config, $pimd_config_base;
	init_config_arr(array('installedpackages', 'pimd', 'config', 0));
	if (!empty($config['installedpackages']['pimd']['config'][0])) {
		$pimd_conf = &$config['installedpackages']['pimd']['config'][0];
	} else {
		return null;
	}

	/* Setup a CARP VIP status check, if needed, so the service won't start
	 * unless this node is in a MASTER state */
	$carp_ip_status_check = "";
	if (isset($pimd_conf['carpstatusvip']) && $pimd_conf['carpstatusvip'] != "none") {
		$vip = get_configured_vip($pimd_conf['carpstatusvip']);
		$carpcheckinterface = escapeshellarg(get_real_interface($vip['interface']));
		$vhid = escapeshellarg("vhid {$vip['vhid']}");
		$carp_ip_status_check = <<<EOF

CARP_STATUS=`/sbin/ifconfig {$carpcheckinterface} | /usr/bin/grep 'carp:' | /usr/bin/grep {$vhid} | /usr/bin/awk '{print \$2;}'`
if [ \${CARP_STATUS} != "MASTER" ]; then
	exit;
fi
EOF;
	}

	/* When stopping, stop all services and remove old PID files */
	$rc_file_stop = <<<EOF
	/usr/local/sbin/pimd -q
	sleep 3
	/usr/bin/killall -q -9 pimd
	# Exit without error no matter what happened with killall
	exit 0
EOF;

	$interfacemode = ($pimd_conf['interfacemode'] == 'all') ? '' : '--disable-vifs';
	$loglevel = (empty($pimd_conf['loglevel'])) ? '' : '-s ' . escapeshellarg($pimd_conf['loglevel']);
	$rc_file_start = <<<EOF
	if /bin/pgrep -q pimd; then
		/usr/local/sbin/pimd -q
		sleep 1
		/usr/bin/killall -q -9 pimd 2>/dev/null
	fi
	{$carp_ip_status_check}
	if [ -s {$pimd_config_base}/pimd.conf ]; then
		/usr/local/sbin/pimd \
			-c {$pimd_config_base}/pimd.conf {$interfacemode} {$loglevel}
	fi

EOF;

	write_rcfile(array(
			"file" => "pimd.sh",
			"start" => $rc_file_start,
			"stop" =>  $rc_file_stop
		)
	);

	if (isset($pimd_conf['carpstatusvip']) && ($pimd_conf['carpstatusvip'] != "none")) {
		$status = get_carp_interface_status($pimd_conf['carpstatusvip']);
		switch (strtoupper($status)) {
			// Stop the service if the VIP is in BACKUP or INIT state.
			case "BACKUP":
			case "INIT":
				stop_service("pimd");
				break;
			// Start the service if the VIP is MASTER state.
			case "MASTER":
			// Assume it's up if the status can't be determined.
			default:
				restart_service("pimd");
				break;
		}
	} elseif ($pimd_conf['enable'] == 'on') {
		restart_service("pimd");
	} else {
		stop_service("pimd");
	}

}

function pimd_generate_config_general() {
	global $config, $pimd_config_base;
	init_config_arr(array('installedpackages', 'pimd', 'config', 0));
	if (!empty($config['installedpackages']['pimd']['config'][0])) {
		$pimd_conf = &$config['installedpackages']['pimd']['config'][0];
	} else {
		return null;
	}

	$conf = "";
	if (!empty($pimd_conf['default_route_distance'])) {
		$conf .= "default-route-distance {$pimd_conf['default_route_distance']}\n";
	}
	if (!empty($pimd_conf['default_route_metric'])) {
		$conf .= "default-route-metric {$pimd_conf['default_route_metric']}\n";
	}
	if (!empty($pimd_conf['igmp_query_interval'])) {
		$conf .= "igmp-query-interval {$pimd_conf['igmp_query_interval']}\n";
	}
	if (!empty($pimd_conf['igmp_querier_timeout'])) {
		$conf .= "igmp-querier-timeout {$pimd_conf['igmp_querier_timeout']}\n";
	}
	if (!empty($pimd_conf['hello_interval'])) {
		$conf .= "hello-interval {$pimd_conf['hello_interval']}\n";
	}

	$sptopts = "";
	/* spt_type (default, rate, packets, infinity) */
	if (in_array($pimd_conf['spt_type'], array('rate', 'packets'))) {
		$sptopts .= " {$pimd_conf['spt_type']} {$pimd_conf['spt_value']}";
	} elseif ($pimd_conf['spt_type'] == 'infinity') {
		$sptopts .= " infinity"; 
	}
	if (!empty($pimd_conf['spt_interval'])) {
		$sptopts .= " interval {$pimd_conf['spt_interval']}";
	}
	if (!empty($sptopts)) {
		$conf .= "spt-threshold{$sptopts}\n";
	}

	return $conf;
}

/* Find the IP address for an "interface" which could be a VIP/IP address,
 * or an interface name. */
function pimd_get_source($source, $returnaddress = false) {
	if (in_array($source, pimd_get_list_values(pimd_get_interfaces(true, true, true)))) {
		/* If this is a VIP, split off the VIP ID from the IP address. */
		if (substr($source, 0, 4) == "_vip") {
			list ($vipid, $source) = explode('|', $source);
		}
		/* If the source is already an IP address from a VIP, return it. */
		if (is_ipaddrv4($source)) {
			return $source;
		} else {
			/* If it reached here, this must be an interface name,
			 * so find the real interface address or name */
			if ($returnaddress) {
				return get_interface_ip($source);
			} else {
				return get_real_interface($source);
			}
		}
	}
	/* Whatever was passed must not be a valid source */
	return "";
}

function pimd_generate_config_interfaces() {
	global $config;
	init_config_arr(array('installedpackages', 'pimdinterfaces', 'config'));
	if (!empty($config['installedpackages']['pimdinterfaces']['config'])) {
		$pimd_conf = &$config['installedpackages']['pimdinterfaces']['config'];
	} else {
		return null;
	}
	$conf = "";
	foreach ($pimd_conf as $pif) {
		$opts = "";
		/* Enable/Disable */
		if (!empty($pif['enable']) &&
		    ($pif['enable'] != 'default')) {
			$opts .= " {$pif['enable']}";
		}
		/* IGMP Version (Default, 3, 2) */
		if (!empty($pif['igmpversion']) &&
		    ($pif['igmpversion'] != 'default')) {
			$opts .= " igmpv{$pif['igmpversion']}";
		}
		/* dr-priority <1-4294967294> (Default: 1) */
		if (!empty($pif['dr_priority'])) {
			$opts .= " dr-priority {$pif['dr_priority']}";
		}
		/* ttl-threshold <1-255> (Default: 1) */
		if (!empty($pif['ttl_threshold'])) {
			$opts .= " ttl-threshold {$pif['ttl_threshold']}";
		}
		/* distance <1-255> (Default: Global default-route-distance) */
		if (!empty($pif['distance'])) {
			$opts .= " distance {$pif['distance']}";
		}
		/* metric <1-1024> (Default: Global default-route-metric) */
		if (!empty($pif['metric'])) {
			$opts .= " metric {$pif['metric']}";
		}
		/* altnet <network/len> */
		if (!empty($pif['altnet'])) {
			$opts .= " altnet {$pif['altnet']}";
		}
		/* scoped <network/len> */
		if (!empty($pif['scoped'])) {
			$opts .= " scoped {$pif['scoped']}";
		}
		$interface = pimd_get_source($pif['interface']);
		if (!empty($interface)) {
			$conf .= "phyint {$interface}{$opts}\n";
		}
	}
	return $conf;
}

function pimd_generate_config_bsrcandidate() {
	global $config;
	init_config_arr(array('installedpackages', 'pimdbsrcandidate', 'config'));
	if (!empty($config['installedpackages']['pimdbsrcandidate']['config'])) {
		$pimd_conf = &$config['installedpackages']['pimdbsrcandidate']['config'];
	} else {
		return null;
	}
	$conf = "";
	foreach ($pimd_conf as $pif) {
		$conf .= "bsr-candidate";
		/* Interface name -- Check for default and omit if set */
		$interface = pimd_get_source($pif['interface']);
		if (!empty($interface) && ($interface != 'default')) {
			$conf .= " {$interface}";
		}
		/* priority <0-255> (Default: 0) */
		if (!empty($pif['priority'])) {
			$conf .= " priority {$pif['priority']}";
		}
		$conf .= "\n";
	}
	return $conf;
}

function pimd_generate_config_rpcandidate() {
	global $config;
	init_config_arr(array('installedpackages', 'pimdrpcandidate', 'config'));
	if (!empty($config['installedpackages']['pimdrpcandidate']['config'])) {
		$pimd_conf = &$config['installedpackages']['pimdrpcandidate']['config'];
	} else {
		return null;
	}
	$conf = "";
	foreach ($pimd_conf as $pif) {
		$conf .= "rp-candidate";
		/* Interface name -- Check for default and omit if set */
		$interface = pimd_get_source($pif['interface']);
		if (!empty($interface) && ($interface != 'default')) {
			$conf .= " {$interface}";
		}
		/* priority <0-255> (Default: 0) */
		if (!empty($pif['priority'])) {
			$conf .= " priority {$pif['priority']}";
		}
		/* time <10-16383> (Default: 30) */
		if (!empty($pif['time'])) {
			$conf .= " time {$pif['time']}";
		}
		$conf .= "\n";
		if (is_array($pif['row']) && !empty($pif['row'])) {
			foreach ($pif['row'] as $gp) {
				if (!empty($gp['groupprefix'])) {
					$conf .= "	group-prefix {$gp['groupprefix']}\n";
				}
			}
		}
	}
	return $conf;
}

function pimd_generate_config_rpaddress() {
	global $config;
	init_config_arr(array('installedpackages', 'pimdrpaddress', 'config'));
	if (!empty($config['installedpackages']['pimdrpaddress']['config'])) {
		$pimd_conf = &$config['installedpackages']['pimdrpaddress']['config'];
	} else {
		return null;
	}
	$conf = "";
	foreach ($pimd_conf as $pif) {
		if (!empty($pif['address'])) {
			$conf .= "rp-address {$pif['address']}";
			/* group (network/len) */
			if (!empty($pif['mcgroup'])) {
				$conf .= " {$pif['mcgroup']}";
			}
			$conf .= "\n";
		}
	}
	return $conf;
}

function pimd_generate_config() {
	global $config, $pimd_config_base, $pimd_auto_config_warning;

	safe_mkdir(PKG_PIMD_CONFIG_BASE);
	unlink_if_exists("{$pimd_config_base}/pimd.conf");

	$conffile = $pimd_auto_config_warning;

	/* General Settings */
	$conffile .= pimd_generate_config_general();

	/* Interfaces */
	$conffile .= pimd_generate_config_interfaces();

	/* BSR Candidates */
	$conffile .= pimd_generate_config_bsrcandidate();

	/* RP Candidates */
	$conffile .= pimd_generate_config_rpcandidate();

	/* RP Addresses */
	$conffile .= pimd_generate_config_rpaddress();

	file_put_contents("{$pimd_config_base}/pimd.conf", $conffile);

	pimd_generate_rcfile();
}

function pimd_package_install() {
	/* Nothing yet */
}

/* Build a list of only CARP VIPs, formatted for use in a selection list */
function pimd_get_carp_list() {
	$list = array();
	$list[] = array("name" => "none", "value" => "none");
	$carplist = get_configured_vip_list("all", VIP_CARP);
	foreach ($carplist as $vid => $vaddr) {
		$vip = get_configured_vip($vid);
		$list[] = array("name" => "$vaddr (vhid: {$vip['vhid']})", "value" => $vid);
	}
	return ($list);
}

/*
 * Called when a CARP VIP changes state
 * $pluginparams['event'] contains either 'rc.carpmaster' or 'rc.carpbackup'
 * $pluginparams['interface'] contains the affected VIP, id@int e.g. 19@igb1
 */
function pimd_plugin_carp($pluginparams) {
	global $config;
	/* If pimd is not configured, then stop */
	init_config_arr(array('installedpackages', 'pimd', 'config', 0));
	if (!empty($config['installedpackages']['pimd']['config'][0])) {
		$pimd_conf = &$config['installedpackages']['pimd']['config'][0];
	} else {
		return null;
	}
	/* If there is no properly configured CARP status check IP, then stop */
	if (!isset($pimd_conf['carpstatusvid']) || $pimd_conf['carpstatusvid'] == "none") {
		return null;
	}
	/* Locate the VIP and match it against the configured check address */
	list($vhid, $iface) = explode("@", trim($pluginparams['interface']));
	$friendly = convert_real_interface_to_friendly_interface_name($iface);
	$vip = get_configured_vip($pimd_conf['carpstatusvid']);
	if ($vip['vhid'] != $vhid || $vip['interface'] != $friendly) {
		/* This is not the VIP we're looking for, move along. */
		return null;
	}
	/* Start or stop the service as needed based on the CARP transition. */
	if ($pluginparams['event'] == "rc.carpmaster") {
		start_service("pimd");
	} elseif ($pluginparams['event'] == "rc.carpbackup") {
		stop_service("pimd");
	}
}

function pimd_find_interface_name($name) {
	$iflist = pimd_get_interfaces(true, true, true);
	foreach ($iflist as $if) {
		if ($if['value'] == $name) {
			return $if['name'];
		}
	}
	return $name;
}
