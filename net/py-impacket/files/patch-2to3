--- impacket/IP6_Address.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/IP6_Address.py
@@ -26,7 +26,7 @@ class IP6_Address():
         self.__scope_id = ""
         
         #Invoke a constructor based on the type of the argument
-        if type(address) is str or type(address) is unicode:
+        if type(address) is str or type(address) is str:
             self.__from_string(address)
         else:
             self.__from_bytes(address)
@@ -243,7 +243,7 @@ class IP6_Address():
             #Capitalize on the constructor's ability to detect invalid text representations of an IP6 address            
             ip6_address = IP6_Address(text_representation)
             return True
-        except Exception, e:
+        except Exception as e:
             return False
                 
     def __is_a_scoped_address(self, text_representation):
@@ -252,18 +252,18 @@ class IP6_Address():
 #############################################################################################################
 # Informal tests
 if __name__ == '__main__':
-    print IP6_Address("A:B:C:D:E:F:1:2").as_string()
+    print(IP6_Address("A:B:C:D:E:F:1:2").as_string())
 #    print IP6_Address("A:B:C:D:E:F:0:2").as_bytes()
-    print IP6_Address("A:B:0:D:E:F:0:2").as_string()
+    print(IP6_Address("A:B:0:D:E:F:0:2").as_string())
 #    print IP6_Address("A::BC:E:D").as_string(False)
-    print IP6_Address("A::BC:E:D").as_string()
-    print IP6_Address("A::BCD:EFFF:D").as_string()
-    print IP6_Address("FE80:0000:0000:0000:020C:29FF:FE26:E251").as_string()
+    print(IP6_Address("A::BC:E:D").as_string())
+    print(IP6_Address("A::BCD:EFFF:D").as_string())
+    print(IP6_Address("FE80:0000:0000:0000:020C:29FF:FE26:E251").as_string())
 
 #    print IP6_Address("A::BCD:EFFF:D").as_bytes()
-    print IP6_Address("::").as_string()
-    print IP6_Address("1::").as_string()
-    print IP6_Address("::2").as_string()
+    print(IP6_Address("::").as_string())
+    print(IP6_Address("1::").as_string())
+    print(IP6_Address("::2").as_string())
 #    bin = [
 #           0x01, 0x02, 0x03, 0x04,
 #           0x01, 0x02, 0x03, 0x04,
--- impacket/IP6_Extension_Headers.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/IP6_Extension_Headers.py
@@ -6,7 +6,7 @@
 #
 import array
 
-from ImpactPacket import Header, ImpactPacketException, PacketBuffer
+from .ImpactPacket import Header, ImpactPacketException, PacketBuffer
 
 class IP6_Extension_Header(Header):
 # --------------------------------- - - - - - - -
@@ -40,7 +40,7 @@ class IP6_Extension_Header(Header):
         for option in self._option_list:
             option_str = str(option)
             option_str = option_str.split('\n')
-            option_str = map(lambda s: (' ' * 4) + s, option_str)
+            option_str = [(' ' * 4) + s for s in option_str]
             s += '\n'.join(option_str) + '\n'
         
         return s
@@ -53,7 +53,7 @@ class IP6_Extension_Header(Header):
 
         buffer = array.array('B', buffer[self.get_headers_field_size():])
         if remaining_bytes > len(buffer):
-            raise ImpactPacketException, "Cannot load options from truncated packet"
+            raise ImpactPacketException("Cannot load options from truncated packet")
 
         while remaining_bytes > 0:
             option_type = buffer[0]
@@ -164,7 +164,7 @@ class Extension_Option(PacketBuffer):
 
     def __init__(self, option_type, size):
         if size > Extension_Option.MAX_OPTION_LEN:
-            raise ImpactPacketException, "Option size of % is greater than the maximum of %d" % (size, Extension_Option.MAX_OPTION_LEN)
+            raise ImpactPacketException("Option size of % is greater than the maximum of %d" % (size, Extension_Option.MAX_OPTION_LEN))
         PacketBuffer.__init__(self, size)
         self.set_option_type(option_type)
 
@@ -217,7 +217,7 @@ class Option_PADN(Extension_Option):
 
     def __init__(self, padding_size):
         if padding_size < 2:
-            raise ImpactPacketException, "PadN Extension Option must be greater than 2 bytes"
+            raise ImpactPacketException("PadN Extension Option must be greater than 2 bytes")
 
         Extension_Option.__init__(self, Option_PADN.OPTION_TYPE_VALUE, padding_size)
         self.set_data('\x00' * (padding_size - 2))
@@ -266,7 +266,7 @@ class Hop_By_Hop(Basic_Extension_Header):
     
     @classmethod
     def get_decoder(self):
-        import ImpactDecoder
+        from . import ImpactDecoder
         return ImpactDecoder.HopByHopDecoder
 
 class Destination_Options(Basic_Extension_Header):
@@ -275,7 +275,7 @@ class Destination_Options(Basic_Extension_Header):
     
     @classmethod
     def get_decoder(self):
-        import ImpactDecoder
+        from . import ImpactDecoder
         return ImpactDecoder.DestinationOptionsDecoder
 
 class Routing_Options(IP6_Extension_Header):
@@ -307,7 +307,7 @@ class Routing_Options(IP6_Extension_Header):
         
     @classmethod
     def get_decoder(self):
-        import ImpactDecoder
+        from . import ImpactDecoder
         return ImpactDecoder.RoutingOptionsDecoder
 
     def get_headers_field_size(self):
--- impacket/ImpactPacket.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/ImpactPacket.py
@@ -19,6 +19,7 @@ import socket
 import string
 import sys
 from binascii import hexlify
+from functools import reduce
 
 """Classes to build network packets programmatically.
 
@@ -34,7 +35,7 @@ class ImpactPacketException(Exception):
     def __init__(self, value):
         self.value = value
     def __str__(self):
-        return `self.value`
+        return repr(self.value)
 
 class PacketBuffer(object):
     """Implement the basic operations utilized to operate on a
@@ -362,7 +363,7 @@ class ProtocolPacket(ProtocolLayer):
 class Header(PacketBuffer,ProtocolLayer):
     "This is the base class from which all protocol definitions extend."
 
-    packet_printable = filter(lambda c: c not in string.whitespace, string.printable) + ' '
+    packet_printable = [c for c in string.printable if c not in string.whitespace] + ' '
 
     ethertype = None
     protocol = None
@@ -650,7 +651,7 @@ class Ethernet(Header):
 
     @staticmethod
     def as_eth_addr(anArray):
-        tmp_list = map(lambda x: x > 15 and '%x'%x or '0%x'%x, anArray)
+        tmp_list = [x > 15 and '%x'%x or '0%x'%x for x in anArray]
         return '' + reduce(lambda x, y: x+':'+y, tmp_list)
 
     def __str__(self):
@@ -842,7 +843,7 @@ class IP(Header):
         for op in self.__option_list:
             sum += op.get_len()
         if sum > 40:
-            raise ImpactPacketException, "Options overflowed in IP packet with length: %d" % sum
+            raise ImpactPacketException("Options overflowed in IP packet with length: %d" % sum)
 
 
     def get_ip_v(self):
@@ -1065,7 +1066,7 @@ class IP(Header):
         opt_left = (self.get_ip_hl() - 5) * 4
         opt_bytes = array.array('B', aBuffer[20:(20 + opt_left)])
         if len(opt_bytes) != opt_left:
-            raise ImpactPacketException, "Cannot load options from truncated packet"
+            raise ImpactPacketException("Cannot load options from truncated packet")
 
 
         while opt_left:
@@ -1076,7 +1077,7 @@ class IP(Header):
             else:
                 op_len = opt_bytes[1]
                 if op_len > len(opt_bytes):
-                    raise ImpactPacketException, "IP Option length is too high"
+                    raise ImpactPacketException("IP Option length is too high")
 
                 new_option = IPOption(op_type, op_len)
                 new_option.set_bytes(opt_bytes[:op_len])
@@ -1111,7 +1112,7 @@ class IPOption(PacketBuffer):
 
     def __init__(self, opcode = 0, size = None):
         if size and (size < 3 or size > 40):
-            raise ImpactPacketException, "IP Options must have a size between 3 and 40 bytes"
+            raise ImpactPacketException("IP Options must have a size between 3 and 40 bytes")
 
         if(opcode == IPOption.IPOPT_EOL):
             PacketBuffer.__init__(self, 1)
@@ -1153,7 +1154,7 @@ class IPOption(PacketBuffer):
             self.set_flags(0)
         else:
             if not size:
-                raise ImpactPacketException, "Size required for this type"
+                raise ImpactPacketException("Size required for this type")
             PacketBuffer.__init__(self,size)
             self.set_code(opcode)
             self.set_len(size)
@@ -1162,14 +1163,14 @@ class IPOption(PacketBuffer):
     def append_ip(self, ip):
         op = self.get_code()
         if not (op == IPOption.IPOPT_RR or op == IPOption.IPOPT_LSRR or op == IPOption.IPOPT_SSRR or op == IPOption.IPOPT_TS):
-            raise ImpactPacketException, "append_ip() not support for option type %d" % self.opt_type
+            raise ImpactPacketException("append_ip() not support for option type %d" % self.opt_type)
 
         p = self.get_ptr()
         if not p:
-            raise ImpactPacketException, "append_ip() failed, option ptr uninitialized"
+            raise ImpactPacketException("append_ip() failed, option ptr uninitialized")
 
         if (p + 4) > self.get_len():
-            raise ImpactPacketException, "append_ip() would overflow option"
+            raise ImpactPacketException("append_ip() would overflow option")
 
         self.set_ip_address(p - 1, ip)
         p += 4
@@ -1185,12 +1186,12 @@ class IPOption(PacketBuffer):
 
     def set_flags(self, flags):
         if not (self.get_code() == IPOption.IPOPT_TS):
-            raise ImpactPacketException, "Operation only supported on Timestamp option"
+            raise ImpactPacketException("Operation only supported on Timestamp option")
         self.set_byte(3, flags)
 
     def get_flags(self, flags):
         if not (self.get_code() == IPOption.IPOPT_TS):
-            raise ImpactPacketException, "Operation only supported on Timestamp option"
+            raise ImpactPacketException("Operation only supported on Timestamp option")
         return self.get_byte(3)
 
 
@@ -1218,7 +1219,7 @@ class IPOption(PacketBuffer):
 
         tmp_str = "\tIP Option: "
         op = self.get_code()
-        if map.has_key(op):
+        if op in map:
             tmp_str += map[op]
         else:
             tmp_str += "Code: %d " % op
@@ -1327,7 +1328,7 @@ class TCP(Header):
             sum += op.get_size()
 
         if sum > 40:
-            raise ImpactPacketException, "Cannot add TCP option, would overflow option space"
+            raise ImpactPacketException("Cannot add TCP option, would overflow option space")
 
     def get_options(self):
         return self.__option_list
@@ -1509,7 +1510,7 @@ class TCP(Header):
         opt_left = (self.get_th_off() - 5) * 4
         opt_bytes = array.array('B', aBuffer[20:(20 + opt_left)])
         if len(opt_bytes) != opt_left:
-            raise ImpactPacketException, "Cannot load options from truncated packet"
+            raise ImpactPacketException("Cannot load options from truncated packet")
 
         while opt_left:
             op_kind = opt_bytes[0]
@@ -1519,9 +1520,9 @@ class TCP(Header):
             else:
                 op_len = opt_bytes[1]
                 if op_len > len(opt_bytes):
-                    raise ImpactPacketException, "TCP Option length is too high"
+                    raise ImpactPacketException("TCP Option length is too high")
                 if op_len < 2:
-                    raise ImpactPacketException, "TCP Option length is too low"
+                    raise ImpactPacketException("TCP Option length is too low")
 
                 new_option = TCPOption(op_kind)
                 new_option.set_bytes(opt_bytes[:op_len])
@@ -1655,12 +1656,12 @@ class TCPOption(PacketBuffer):
 
     def set_len(self, len):
         if self.get_size() < 2:
-            raise ImpactPacketException, "Cannot set length field on an option having a size smaller than 2 bytes"
+            raise ImpactPacketException("Cannot set length field on an option having a size smaller than 2 bytes")
         self.set_byte(1, len)
 
     def get_len(self):
         if self.get_size() < 2:
-            raise ImpactPacketException, "Cannot retrieve length field from an option having a size smaller than 2 bytes"
+            raise ImpactPacketException("Cannot retrieve length field from an option having a size smaller than 2 bytes")
         return self.get_byte(1)
 
     def get_size(self):
@@ -1669,42 +1670,42 @@ class TCPOption(PacketBuffer):
 
     def set_mss(self, len):
         if self.get_kind() != TCPOption.TCPOPT_MAXSEG:
-            raise ImpactPacketException, "Can only set MSS on TCPOPT_MAXSEG option"
+            raise ImpactPacketException("Can only set MSS on TCPOPT_MAXSEG option")
         self.set_word(2, len)
 
     def get_mss(self):
         if self.get_kind() != TCPOption.TCPOPT_MAXSEG:
-            raise ImpactPacketException, "Can only retrieve MSS from TCPOPT_MAXSEG option"
+            raise ImpactPacketException("Can only retrieve MSS from TCPOPT_MAXSEG option")
         return self.get_word(2)
 
     def set_shift_cnt(self, cnt):
         if self.get_kind() != TCPOption.TCPOPT_WINDOW:
-            raise ImpactPacketException, "Can only set Shift Count on TCPOPT_WINDOW option"
+            raise ImpactPacketException("Can only set Shift Count on TCPOPT_WINDOW option")
         self.set_byte(2, cnt)
 
     def get_shift_cnt(self):
         if self.get_kind() != TCPOption.TCPOPT_WINDOW:
-            raise ImpactPacketException, "Can only retrieve Shift Count from TCPOPT_WINDOW option"
+            raise ImpactPacketException("Can only retrieve Shift Count from TCPOPT_WINDOW option")
         return self.get_byte(2)
 
     def get_ts(self):
         if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:
-            raise ImpactPacketException, "Can only retrieve timestamp from TCPOPT_TIMESTAMP option"
+            raise ImpactPacketException("Can only retrieve timestamp from TCPOPT_TIMESTAMP option")
         return self.get_long(2)
 
     def set_ts(self, ts):
         if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:
-            raise ImpactPacketException, "Can only set timestamp on TCPOPT_TIMESTAMP option"
+            raise ImpactPacketException("Can only set timestamp on TCPOPT_TIMESTAMP option")
         self.set_long(2, ts)
 
     def get_ts_echo(self):
         if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:
-            raise ImpactPacketException, "Can only retrieve timestamp from TCPOPT_TIMESTAMP option"
+            raise ImpactPacketException("Can only retrieve timestamp from TCPOPT_TIMESTAMP option")
         return self.get_long(6)
 
     def set_ts_echo(self, ts):
         if self.get_kind() != TCPOption.TCPOPT_TIMESTAMP:
-            raise ImpactPacketException, "Can only set timestamp on TCPOPT_TIMESTAMP option"
+            raise ImpactPacketException("Can only set timestamp on TCPOPT_TIMESTAMP option")
         self.set_long(6, ts)
 
     def __str__(self):
@@ -1716,7 +1717,7 @@ class TCPOption(PacketBuffer):
 
         tmp_str = "\tTCP Option: "
         op = self.get_kind()
-        if map.has_key(op):
+        if op in map:
             tmp_str += map[op]
         else:
             tmp_str += " kind: %d " % op
@@ -1779,7 +1780,7 @@ class ICMP(Header):
 
     def get_header_size(self):
         anamolies = { ICMP.ICMP_TSTAMP : 20, ICMP.ICMP_TSTAMPREPLY : 20, ICMP.ICMP_MASKREQ : 12, ICMP.ICMP_MASKREPLY : 12 }
-        if anamolies.has_key(self.get_icmp_type()):
+        if self.get_icmp_type() in anamolies:
             return anamolies[self.get_icmp_type()]
         else:
             return 8
@@ -1899,7 +1900,7 @@ class ICMP(Header):
         tmp_code[11] = ['TIMXCEED INTRANS ', 'TIMXCEED REASS']
         tmp_code[12] = ['PARAMPROB ERRATPTR ', 'PARAMPROB OPTABSENT', 'PARAMPROB LENGTH']
         tmp_code[40] = [None, 'PHOTURIS UNKNOWN INDEX', 'PHOTURIS AUTH FAILED', 'PHOTURIS DECRYPT FAILED']
-        if tmp_code.has_key(aType):
+        if aType in tmp_code:
             tmp_list = tmp_code[aType]
             if ((aCode + 1) > len(tmp_list)) or (not tmp_list[aCode]):
                 return 'UNKNOWN'
@@ -1937,7 +1938,7 @@ class ICMP(Header):
 
     def isQuery(self):
         tmp_dict = {8:'',  9:'',  10:'', 13:'', 14:'', 15:'', 16:'', 17:'', 18:''}
-        return tmp_dict.has_key(self.get_icmp_type())
+        return self.get_icmp_type() in tmp_dict
 
 class IGMP(Header):
     protocol = 2
@@ -2122,5 +2123,5 @@ def example(): #To execute an example, remove this lin
     b.set_ar_tpa((192, 168, 66, 171))
     a.set_ether_shost((0x0, 0xe0, 0x7d, 0x8a, 0xef, 0x3d))
     a.set_ether_dhost((0x0, 0xc0, 0xdf, 0x6, 0x5, 0xe))
-    print "beto %s" % a
+    print("beto %s" % a)
 
--- impacket/dcerpc/v5/dcom/oaut.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/dcom/oaut.py
@@ -40,7 +40,7 @@ class DCERPCSessionError(DCERPCException):
         DCERPCException.__init__(self, error_string, error_code, packet)
 
     def __str__( self ):
-        if hresult_errors.ERROR_MESSAGES.has_key(self.error_code):
+        if self.error_code in hresult_errors.ERROR_MESSAGES:
             error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]
             error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] 
             return 'OAUT SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -286,9 +286,9 @@ class FLAGGED_WORD_BLOB(NDRSTRUCT):
         if msg is None: msg = self.__class__.__name__
         ind = ' '*indent
         if msg != '':
-            print "%s" % (msg)
+            print("%s" % (msg))
         value = ''
-        print '%sasData: %s' % (ind,self['asData']),
+        print('%sasData: %s' % (ind,self['asData']), end=' ')
 
 # 2.2.23.2 BSTR Type Definition
 class BSTR(NDRPOINTER):
@@ -979,9 +979,9 @@ def enumerateMethods(iInterface):
     for x in range(iTypeAttr['ppTypeAttr']['cFuncs']):
         funcDesc = iTypeInfo.GetFuncDesc(x)
         names = iTypeInfo.GetNames(funcDesc['ppFuncDesc']['memid'], 255)
-        print names['rgBstrNames'][0]['asData']
+        print(names['rgBstrNames'][0]['asData'])
         funcDesc.dump()
-        print '='*80
+        print('='*80)
         if names['pcNames'] > 0:
             name = names['rgBstrNames'][0]['asData']
             methods[name] = {}
--- impacket/dcerpc/v5/dcom/scmp.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/dcom/scmp.py
@@ -32,7 +32,7 @@ class DCERPCSessionError(DCERPCException):
         DCERPCException.__init__(self, error_string, error_code, packet)
 
     def __str__( self ):
-        if hresult_errors.ERROR_MESSAGES.has_key(self.error_code):
+        if self.error_code in hresult_errors.ERROR_MESSAGES:
             error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]
             error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] 
             return 'SCMP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -301,8 +301,8 @@ class IVssSnapshotMgmt(IRemUnknown2):
         req['ProviderId'] = providerId
         try:
             resp = self.request(req, self._iid, uuid = self.get_iPid())
-        except DCERPCException, e:
-            print e
+        except DCERPCException as e:
+            print(e)
             from impacket.winregistry import hexdump
             data = e.get_packet()
             hexdump(data)
--- impacket/dcerpc/v5/dcom/vds.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/dcom/vds.py
@@ -32,7 +32,7 @@ class DCERPCSessionError(DCERPCException):
         DCERPCException.__init__(self, error_string, error_code, packet)
 
     def __str__( self ):
-        if hresult_errors.ERROR_MESSAGES.has_key(self.error_code):
+        if self.error_code in hresult_errors.ERROR_MESSAGES:
             error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]
             error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] 
             return 'VDS SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -198,7 +198,7 @@ class IEnumVdsObject(IRemUnknown2):
         request['celt'] = celt
         try:
             resp = self.request(request, uuid = self.get_iPid())
-        except Exception, e:
+        except Exception as e:
             resp = e.get_packet()
             # If it is S_FALSE(1) means less items were returned
             if resp['ErrorCode'] != 1:
@@ -238,7 +238,7 @@ class IVdsService(IRemUnknown2):
         request['ORPCthis']['flags'] = 0
         try:
             resp = self.request(request, uuid = self.get_iPid())
-        except Exception, e:
+        except Exception as e:
             resp = e.get_packet()
         return resp 
 
--- impacket/dcerpc/v5/dcom/wmi.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/dcom/wmi.py
@@ -38,11 +38,11 @@ from impacket.structure import Structure
 def format_structure(d, level=0):
     x = ""
     if isinstance(d, collections.Mapping):
-        lenk = max(map(lambda x: len(str(x)), d.keys()))
-        for k, v in d.items():
+        lenk = max([len(str(x)) for x in list(d.keys())])
+        for k, v in list(d.items()):
             key_text = "\n" + " "*level + " "*(lenk - len(str(k))) + str(k)
             x += key_text + ": " + format_structure(v, level=level+lenk)
-    elif isinstance(d, collections.Iterable) and not isinstance(d, basestring):
+    elif isinstance(d, collections.Iterable) and not isinstance(d, str):
         for e in d:
             x += "\n" + " "*level + "- " + format_structure(e, level=level+4)
     else:
@@ -61,7 +61,7 @@ class DCERPCSessionError(DCERPCException):
         DCERPCException.__init__(self, error_string, error_code, packet)
 
     def __str__( self ):
-        if hresult_errors.ERROR_MESSAGES.has_key(self.error_code):
+        if self.error_code in hresult_errors.ERROR_MESSAGES:
             error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]
             error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1] 
             return 'WMI SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -501,7 +501,7 @@ class PROPERTY_LOOKUP_TABLE(Structure):
 
             propTable = propTable[self.PropertyLookupSize:]
 
-        return OrderedDict(sorted(properties.items(), key=lambda x:x[1]['order']))
+        return OrderedDict(sorted(list(properties.items()), key=lambda x:x[1]['order']))
         #return properties
 
 # 2.2.66 Heap
@@ -539,7 +539,7 @@ class CLASS_PART(Structure):
     def getProperties(self):
         heap = self["ClassHeap"]["HeapItem"]
         properties =  self["PropertyLookupTable"].getProperties(self["ClassHeap"]["HeapItem"])
-        sorted_props = sorted(properties.keys(), key=lambda k: properties[k]['order'])
+        sorted_props = sorted(list(properties.keys()), key=lambda k: properties[k]['order'])
         valueTableOff = (len(properties) - 1) / 4 + 1
         valueTable = self['NdTable_ValueTable'][valueTableOff:]
         for key in sorted_props:
@@ -787,7 +787,7 @@ class INSTANCE_TYPE(Structure):
         heap = self["InstanceHeap"]["HeapItem"]
         valueTableOff = (len(properties) - 1) / 4 + 1
         valueTable = self['NdTable_ValueTable'][valueTableOff:]
-        sorted_props = sorted(properties.keys(), key=lambda k: properties[k]['order'])
+        sorted_props = sorted(list(properties.keys()), key=lambda k: properties[k]['order'])
         for key in sorted_props:
             pType = properties[key]['type'] & (~(CIM_ARRAY_FLAG|Inherited))
             if properties[key]['type'] & CIM_ARRAY_FLAG:
@@ -868,11 +868,11 @@ class OBJECT_BLOCK(Structure):
         qualifiers = pClass.getQualifiers()
 
         for qualifier in qualifiers:
-            print "[%s]" % qualifier
+            print("[%s]" % qualifier)
 
         className = pClass.getClassName()
 
-        print "class %s \n{" % className
+        print("class %s \n{" % className)
 
         properties = pClass.getProperties()
         if cInstance is not None:
@@ -883,52 +883,52 @@ class OBJECT_BLOCK(Structure):
                 qualifiers = properties[pName]['qualifiers']
                 for qName in qualifiers:
                     if qName != 'CIMTYPE':
-                        print '\t[%s(%s)]' % (qName, qualifiers[qName])
-                print "\t%s %s" % (properties[pName]['stype'], properties[pName]['name']),
+                        print('\t[%s(%s)]' % (qName, qualifiers[qName]))
+                print("\t%s %s" % (properties[pName]['stype'], properties[pName]['name']), end=' ')
                 if properties[pName]['value'] is not None:
                     if properties[pName]['type'] == CIM_TYPE_ENUM.CIM_TYPE_OBJECT.value:
-                        print '= IWbemClassObject\n'
+                        print('= IWbemClassObject\n')
                     elif properties[pName]['type'] == CIM_TYPE_ENUM.CIM_ARRAY_OBJECT.value:
                         if properties[pName]['value'] == 0:
-                            print '= %s\n' % properties[pName]['value']
+                            print('= %s\n' % properties[pName]['value'])
                         else:
-                            print '= %s\n' % list('IWbemClassObject' for _ in range(len(properties[pName]['value'])))
+                            print('= %s\n' % list('IWbemClassObject' for _ in range(len(properties[pName]['value']))))
                     else:
-                        print '= %s\n' % properties[pName]['value']
+                        print('= %s\n' % properties[pName]['value'])
                 else:
-                    print '\n'
+                    print('\n')
 
-        print 
+        print() 
         methods = pClass.getMethods()
         for methodName in methods:
             for qualifier in methods[methodName]['qualifiers']:
-                print '\t[%s]' % qualifier
+                print('\t[%s]' % qualifier)
 
             if methods[methodName]['InParams'] is None and methods[methodName]['OutParams'] is None: 
-                print '\t%s %s();\n' % ('void', methodName)
+                print('\t%s %s();\n' % ('void', methodName))
             if methods[methodName]['InParams'] is None and len(methods[methodName]['OutParams']) == 1:
-                print '\t%s %s();\n' % (methods[methodName]['OutParams']['ReturnValue']['stype'], methodName)
+                print('\t%s %s();\n' % (methods[methodName]['OutParams']['ReturnValue']['stype'], methodName))
             else:
                 returnValue = ''
                 if methods[methodName]['OutParams'] is not None:
                     # Search the Return Value
                     #returnValue = (item for item in method['OutParams'] if item["name"] == "ReturnValue").next()
-                    if methods[methodName]['OutParams'].has_key('ReturnValue'):
+                    if 'ReturnValue' in methods[methodName]['OutParams']:
                         returnValue = methods[methodName]['OutParams']['ReturnValue']['stype']
  
-                print '\t%s %s(\n' % (returnValue, methodName),
+                print('\t%s %s(\n' % (returnValue, methodName), end=' ')
                 if methods[methodName]['InParams'] is not None:
                     for pName  in methods[methodName]['InParams']:
-                        print '\t\t[in]    %s %s,' % (methods[methodName]['InParams'][pName]['stype'], pName)
+                        print('\t\t[in]    %s %s,' % (methods[methodName]['InParams'][pName]['stype'], pName))
 
                 if methods[methodName]['OutParams'] is not None:
                     for pName in methods[methodName]['OutParams']:
                         if pName != 'ReturnValue':
-                            print '\t\t[out]    %s %s,' % (methods[methodName]['OutParams'][pName]['stype'], pName)
+                            print('\t\t[out]    %s %s,' % (methods[methodName]['OutParams'][pName]['stype'], pName))
 
-                print '\t);\n'
+                print('\t);\n')
 
-        print "}"
+        print("}")
 
     def parseClass(self, pClass, cInstance = None):
         classDict = OrderedDict()
@@ -2301,7 +2301,7 @@ class IWbemClassObject(IRemUnknown):
             # Let's see if there's a key property so we can ExecMethod
             keyProperty = None
             for pName in properties:
-                if properties[pName]['qualifiers'].has_key('key'):
+                if 'key' in properties[pName]['qualifiers']:
                     keyProperty = pName
 
             if keyProperty is None:
@@ -2311,7 +2311,7 @@ class IWbemClassObject(IRemUnknown):
                     classObject,_ = self.__iWbemServices.GetObject(self.getClassName())
                     self.__methods = classObject.getMethods()
 
-                if self.__methods.has_key(attr):
+                if attr in self.__methods:
                     # Now we gotta build the class name to be called through ExecMethod
                     if self.getProperties()[keyProperty]['stype'] != 'string':
                         instanceName = '%s.%s=%s' % (
@@ -2619,7 +2619,7 @@ class IWbemClassObject(IRemUnknown):
 
                 ndTable = 0
                 for i in range(len(args)):
-                    paramDefinition = methodDefinition['InParams'].values()[i]
+                    paramDefinition = list(methodDefinition['InParams'].values())[i]
                     inArg = args[i]
 
                     pType = paramDefinition['type'] & (~(CIM_ARRAY_FLAG|Inherited)) 
@@ -2651,7 +2651,7 @@ class IWbemClassObject(IRemUnknown):
                             ndTable |= 3 << (2*i)
                     else:
                         strIn = ENCODED_STRING()
-                        if type(inArg) is unicode:
+                        if type(inArg) is str:
                             # The Encoded-String-Flag is set to 0x01 if the sequence of characters that follows
                             # consists of UTF-16 characters (as specified in [UNICODE]) followed by a UTF-16 null
                             # terminator.
@@ -2729,7 +2729,7 @@ class IWbemClassObject(IRemUnknown):
                 return self.__iWbemServices.ExecMethod(classOrInstance, methodDefinition['name'], pInParams = objRefCustomIn )
                 #return self.__iWbemServices.ExecMethod('Win32_Process.Handle="436"', methodDefinition['name'],
                 #                                       pInParams=objRefCustomIn).getObject().ctCurrent['properties']
-            except Exception, e:
+            except Exception as e:
                 if LOG.level == logging.DEBUG:
                     import traceback
                     traceback.print_exc()
--- impacket/dcerpc/v5/dcomrt.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/dcomrt.py
@@ -70,7 +70,7 @@ class DCERPCSessionError(DCERPCException):
         DCERPCException.__init__(self, error_string, error_code, packet)
 
     def __str__( self ):
-        if hresult_errors.ERROR_MESSAGES.has_key(self.error_code):
+        if self.error_code in hresult_errors.ERROR_MESSAGES:
             error_msg_short = hresult_errors.ERROR_MESSAGES[self.error_code][0]
             error_msg_verbose = hresult_errors.ERROR_MESSAGES[self.error_code][1]
             return 'DCOM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -963,20 +963,20 @@ class DCOMConnection:
 
     @classmethod
     def addOid(cls, target, oid):
-        if DCOMConnection.OID_ADD.has_key(target) is False:
+        if (target in DCOMConnection.OID_ADD) is False:
             DCOMConnection.OID_ADD[target] = set()
         DCOMConnection.OID_ADD[target].add(oid)
-        if DCOMConnection.OID_SET.has_key(target) is False:
+        if (target in DCOMConnection.OID_SET) is False:
             DCOMConnection.OID_SET[target] = {}
             DCOMConnection.OID_SET[target]['oids'] = set()
             DCOMConnection.OID_SET[target]['setid'] = 0
 
     @classmethod
     def delOid(cls, target, oid):
-        if DCOMConnection.OID_DEL.has_key(target) is False:
+        if (target in DCOMConnection.OID_DEL) is False:
             DCOMConnection.OID_DEL[target] = set()
         DCOMConnection.OID_DEL[target].add(oid)
-        if DCOMConnection.OID_SET.has_key(target) is False:
+        if (target in DCOMConnection.OID_SET) is False:
             DCOMConnection.OID_SET[target] = {}
             DCOMConnection.OID_SET[target]['oids'] = set()
             DCOMConnection.OID_SET[target]['setid'] = 0
@@ -991,18 +991,18 @@ class DCOMConnection:
             for target in DCOMConnection.OID_SET:
                 addedOids = set()
                 deletedOids = set()
-                if DCOMConnection.OID_ADD.has_key(target):
+                if target in DCOMConnection.OID_ADD:
                     addedOids = DCOMConnection.OID_ADD[target]
                     del(DCOMConnection.OID_ADD[target])
 
-                if DCOMConnection.OID_DEL.has_key(target):
+                if target in DCOMConnection.OID_DEL:
                     deletedOids = DCOMConnection.OID_DEL[target]
                     del(DCOMConnection.OID_DEL[target])
 
                 objExporter = IObjectExporter(DCOMConnection.PORTMAPS[target])
 
                 if len(addedOids) > 0 or len(deletedOids) > 0:
-                    if DCOMConnection.OID_SET[target].has_key('setid'):
+                    if 'setid' in DCOMConnection.OID_SET[target]:
                         setId = DCOMConnection.OID_SET[target]['setid']
                     else:
                         setId = 0
@@ -1012,7 +1012,7 @@ class DCOMConnection:
                     DCOMConnection.OID_SET[target]['setid'] = resp['pSetId']
                 else:
                     objExporter.SimplePing(DCOMConnection.OID_SET[target]['setid'])
-        except Exception, e:
+        except Exception as e:
             # There might be exceptions when sending packets 
             # We should try to continue tho.
             LOG.error(str(e))
@@ -1021,7 +1021,7 @@ class DCOMConnection:
         DCOMConnection.PINGTIMER = Timer(120,DCOMConnection.pingServer)
         try:
             DCOMConnection.PINGTIMER.start()
-        except Exception, e:
+        except Exception as e:
             if str(e).find('threads can only be started once') < 0:
                 raise e
 
@@ -1031,7 +1031,7 @@ class DCOMConnection:
                 DCOMConnection.PINGTIMER = Timer(120, DCOMConnection.pingServer)
             try:
                 DCOMConnection.PINGTIMER.start()
-            except Exception, e:
+            except Exception as e:
                 if str(e).find('threads can only be started once') < 0:
                     raise e
 
@@ -1069,7 +1069,7 @@ class DCOMConnection:
                 DCOMConnection.PINGTIMER.cancel()
                 DCOMConnection.PINGTIMER.join()
                 DCOMConnection.PINGTIMER = None
-        if INTERFACE.CONNECTIONS.has_key(self.__target):
+        if self.__target in INTERFACE.CONNECTIONS:
             del(INTERFACE.CONNECTIONS[self.__target][currentThread().getName()])
         self.__portmap.disconnect()
         #print INTERFACE.CONNECTIONS
@@ -1124,7 +1124,7 @@ class INTERFACE:
             self.__objRef = objRef
             self.__ipidRemUnknown = ipidRemUnknown
             # We gotta check if we have a container inside our connection list, if not, create
-            if INTERFACE.CONNECTIONS.has_key(self.__target) is not True:
+            if (self.__target in INTERFACE.CONNECTIONS) is not True:
                 INTERFACE.CONNECTIONS[self.__target] = {}
                 INTERFACE.CONNECTIONS[self.__target][currentThread().getName()] = {}
 
@@ -1213,9 +1213,9 @@ class INTERFACE:
 
 
     def connect(self, iid = None):
-        if INTERFACE.CONNECTIONS.has_key(self.__target) is True:
-            if INTERFACE.CONNECTIONS[self.__target].has_key(currentThread().getName()) and \
-                            INTERFACE.CONNECTIONS[self.__target][currentThread().getName()].has_key(self.__oxid) is True:
+        if (self.__target in INTERFACE.CONNECTIONS) is True:
+            if currentThread().getName() in INTERFACE.CONNECTIONS[self.__target] and \
+                            (self.__oxid in INTERFACE.CONNECTIONS[self.__target][currentThread().getName()]) is True:
                 dce = INTERFACE.CONNECTIONS[self.__target][currentThread().getName()][self.__oxid]['dce']
                 currentBinding = INTERFACE.CONNECTIONS[self.__target][currentThread().getName()][self.__oxid]['currentBinding']
                 if currentBinding == iid:
@@ -1308,7 +1308,7 @@ class INTERFACE:
         dce = self.get_dce_rpc()
         try:
             resp = dce.request(req, uuid)
-        except Exception, e:
+        except Exception as e:
             if str(e).find('RPC_E_DISCONNECTED') >= 0:
                 msg = str(e) + '\n'
                 msg += "DCOM keep-alive pinging it might not be working as expected. You can't be idle for more than 14 minutes!\n"
--- impacket/dcerpc/v5/dhcpm.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/dhcpm.py
@@ -47,11 +47,11 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__(self):
         key = self.error_code
-        if system_errors.ERROR_MESSAGES.has_key(key):
+        if key in system_errors.ERROR_MESSAGES:
             error_msg_short = system_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]
             return 'DHCPM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
-        elif self.ERROR_MESSAGES.has_key(key):
+        elif key in self.ERROR_MESSAGES:
             error_msg_short = self.ERROR_MESSAGES[key][0]
             error_msg_verbose = self.ERROR_MESSAGES[key][1]
             return 'DHCPM SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -815,7 +815,7 @@ def hDhcpGetOptionValue(dce, optionID, scopetype=DHCP_
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('ERROR_NO_MORE_ITEMS') < 0:
                 raise
             resp = e.get_packet()
@@ -842,7 +842,7 @@ def hDhcpEnumOptionValues(dce, scopetype=DHCP_OPTION_S
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('ERROR_NO_MORE_ITEMS') < 0:
                 raise
             resp = e.get_packet()
@@ -872,7 +872,7 @@ def hDhcpEnumOptionValuesV5(dce, flags=DHCP_FLAGS_OPTI
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('ERROR_NO_MORE_ITEMS') < 0:
                 raise
             resp = e.get_packet()
@@ -900,7 +900,7 @@ def hDhcpGetOptionValueV5(dce, option_id, flags=DHCP_F
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('ERROR_NO_MORE_ITEMS') < 0:
                 raise
             resp = e.get_packet()
@@ -924,7 +924,7 @@ def hDhcpGetAllOptionValues(dce, scopetype=DHCP_OPTION
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('ERROR_NO_MORE_ITEMS') < 0:
                 raise
             resp = e.get_packet()
@@ -940,7 +940,7 @@ def hDhcpEnumSubnets(dce, preferredMaximum=0xffffffff)
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('STATUS_MORE_ENTRIES') < 0:
                 raise
             resp = e.get_packet()
@@ -957,7 +957,7 @@ def hDhcpEnumSubnetClientsVQ(dce, preferredMaximum=0xf
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('STATUS_MORE_ENTRIES') < 0:
                 raise
             resp = e.get_packet()
@@ -974,7 +974,7 @@ def hDhcpEnumSubnetClientsV4(dce, preferredMaximum=0xf
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('STATUS_MORE_ENTRIES') < 0:
                 raise
             resp = e.get_packet()
@@ -991,7 +991,7 @@ def hDhcpEnumSubnetClientsV5(dce, subnetAddress=0, pre
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCSessionError, e:
+        except DCERPCSessionError as e:
             if str(e).find('STATUS_MORE_ENTRIES') < 0:
                 raise
             resp = e.get_packet()
@@ -1010,7 +1010,7 @@ def hDhcpEnumSubnetElementsV5(dce, subnet_address, ele
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('ERROR_NO_MORE_ITEMS') < 0:
                 raise
             resp = e.get_packet()
--- impacket/dcerpc/v5/drsuapi.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/drsuapi.py
@@ -47,11 +47,11 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__( self ):
         key = self.error_code
-        if hresult_errors.ERROR_MESSAGES.has_key(key):
+        if key in hresult_errors.ERROR_MESSAGES:
             error_msg_short = hresult_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = hresult_errors.ERROR_MESSAGES[key][1]
             return 'DRSR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
-        elif system_errors.ERROR_MESSAGES.has_key(key & 0xffff):
+        elif key & 0xffff in system_errors.ERROR_MESSAGES:
             error_msg_short = system_errors.ERROR_MESSAGES[key & 0xffff][0]
             error_msg_verbose = system_errors.ERROR_MESSAGES[key & 0xffff][1]
             return 'DRSR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -89,12 +89,12 @@ class EXOP_ERR(NDRENUM):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print msg,
+            print(msg, end=' ')
 
         try:
-            print " %s" % self.enumItems(self.fields['Data']).name,
+            print(" %s" % self.enumItems(self.fields['Data']).name, end=' ')
         except ValueError:
-            print " %d" % self.fields['Data']
+            print(" %d" % self.fields['Data'])
 
 # 4.1.10.2.18 EXOP_REQ Codes
 EXOP_FSMO_REQ_ROLE = 0x00000001
@@ -607,7 +607,7 @@ class WCHAR_ARRAY(NDRUniConformantArray):
                 # We might have Unicode chars in here, let's use unichr instead
                 LOG.debug('ValueError exception on %s' % self.fields[key])
                 LOG.debug('Switching to unichr()')
-                return ''.join([unichr(i) for i in self.fields[key]])
+                return ''.join([chr(i) for i in self.fields[key]])
 
         else:
             return NDR.__getitem__(self,key)
@@ -1488,22 +1488,22 @@ if __name__ == '__main__':
     oid4 = '1.2.840.113556.1.5.7000.53'
 
     o0 = MakeAttid(prefixTable, oid0)
-    print hex(o0)
+    print(hex(o0))
     o1 = MakeAttid(prefixTable, oid1)
-    print hex(o1)
+    print(hex(o1))
     o2 = MakeAttid(prefixTable, oid2)
-    print hex(o2)
+    print(hex(o2))
     o3 = MakeAttid(prefixTable, oid3)
-    print hex(o3)
+    print(hex(o3))
     o4 = MakeAttid(prefixTable, oid4)
-    print hex(o4)
+    print(hex(o4))
     jj = OidFromAttid(prefixTable, o0)
-    print jj
+    print(jj)
     jj = OidFromAttid(prefixTable, o1)
-    print jj
+    print(jj)
     jj = OidFromAttid(prefixTable, o2)
-    print jj
+    print(jj)
     jj = OidFromAttid(prefixTable, o3)
-    print jj
+    print(jj)
     jj = OidFromAttid(prefixTable, o4)
-    print jj
+    print(jj)
--- impacket/dcerpc/v5/dtypes.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/dtypes.py
@@ -95,9 +95,9 @@ class STR(NDRSTRUCT):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print "%s" % msg,
+            print("%s" % msg, end=' ')
         # Here just print the data
-        print " %r" % (self['Data']),
+        print(" %r" % (self['Data']), end=' ')
 
     def __setitem__(self, key, value):
         if key == 'Data':
@@ -134,9 +134,9 @@ class WSTR(NDRSTRUCT):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print "%s" % msg,
+            print("%s" % msg, end=' ')
         # Here just print the data
-        print " %r" % (self['Data']),
+        print(" %r" % (self['Data']), end=' ')
 
     def getDataLen(self, data):
         return self["ActualCount"]*2 
@@ -358,12 +358,12 @@ class RPC_UNICODE_STRING(NDRSTRUCT):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print "%s" % msg,
+            print("%s" % msg, end=' ')
 
         if isinstance(self.fields['Data'] , NDRPOINTERNULL):
-            print " NULL",
+            print(" NULL", end=' ')
         elif self.fields['Data']['ReferentID'] == 0:
-            print " NULL",
+            print(" NULL", end=' ')
         else:
             return self.fields['Data'].dump('',indent)
 
@@ -459,17 +459,17 @@ class PRPC_SID(NDRPOINTER):
 PSID = PRPC_SID
 
 # 2.4.3 ACCESS_MASK
-GENERIC_READ            = 0x80000000L
-GENERIC_WRITE           = 0x4000000L
-GENERIC_EXECUTE         = 0x20000000L
-GENERIC_ALL             = 0x10000000L
-MAXIMUM_ALLOWED         = 0x02000000L
-ACCESS_SYSTEM_SECURITY  = 0x01000000L
-SYNCHRONIZE             = 0x00100000L
-WRITE_OWNER             = 0x00080000L
-WRITE_DACL              = 0x00040000L
-READ_CONTROL            = 0x00020000L
-DELETE                  = 0x00010000L
+GENERIC_READ            = 0x80000000
+GENERIC_WRITE           = 0x4000000
+GENERIC_EXECUTE         = 0x20000000
+GENERIC_ALL             = 0x10000000
+MAXIMUM_ALLOWED         = 0x02000000
+ACCESS_SYSTEM_SECURITY  = 0x01000000
+SYNCHRONIZE             = 0x00100000
+WRITE_OWNER             = 0x00080000
+WRITE_DACL              = 0x00040000
+READ_CONTROL            = 0x00020000
+DELETE                  = 0x00010000
 
 # 2.4.5.1 ACL--RPC Representation
 class ACL(NDRSTRUCT):
--- impacket/dcerpc/v5/epm.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/epm.py
@@ -41,7 +41,7 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__( self ):
         key = self.error_code
-        if self.error_messages.has_key(key):
+        if key in self.error_messages:
             error_msg_short = self.error_messages[key]
             return 'EPM SessionError: code: 0x%x - %s ' % (self.error_code, error_msg_short)
         else:
@@ -1335,7 +1335,7 @@ def PrintStringBinding(floors, serverAddr = '0.0.0.0')
             # If the address were 0.0.0.0 it would have to be replaced by the remote host's IP.
             if tmp_address2 == '0.0.0.0':
                 tmp_address2 = serverAddr
-            if tmp_address <> '':
+            if tmp_address != '':
                 return tmp_address % tmp_address2
             else:
                 return 'IP: %s' % tmp_address2
@@ -1345,7 +1345,7 @@ def PrintStringBinding(floors, serverAddr = '0.0.0.0')
             n = len(floor['RelatedData'])
             tmp_address2 = ('%02X' * n) % unpack("%dB" % n, floor['RelatedData'])
 
-            if tmp_address <> '':
+            if tmp_address != '':
                 return tmp_address % tmp_address2
             else:
                 return 'SPX: %s' % tmp_address2
@@ -1356,7 +1356,7 @@ def PrintStringBinding(floors, serverAddr = '0.0.0.0')
         elif floor['ProtocolData'] == chr(0x10):
             return 'ncalrpc:[%s]' % floor['RelatedData'][:len(floor['RelatedData'])-1]
         elif floor['ProtocolData'] == chr(0x01) or floor['ProtocolData'] == chr(0x11):
-            if tmp_address <> '':
+            if tmp_address != '':
                 return tmp_address % floor['RelatedData'][:len(floor['RelatedData'])-1]
             else:
                 return 'NetBIOS: %s' % floor['RelatedData'] 
--- impacket/dcerpc/v5/even6.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/even6.py
@@ -33,7 +33,7 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__(self):
         key = self.error_code
-        if system_errors.ERROR_MESSAGES.has_key(key):
+        if key in system_errors.ERROR_MESSAGES:
             error_msg_short = system_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = system_errors.ERROR_MESSAGES[key][1]
             return 'EVEN6 SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -315,7 +315,7 @@ def hEvtRpcQueryNext(dce, handle, numRequestedRecords,
     while status == system_errors.ERROR_MORE_DATA:
         try:
             resp = dce.request(request)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('ERROR_NO_MORE_ITEMS') < 0:
                 raise
             elif str(e).find('ERROR_TIMEOUT') < 0:
--- impacket/dcerpc/v5/lsad.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/lsad.py
@@ -36,7 +36,7 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__( self ):
         key = self.error_code
-        if nt_errors.ERROR_MESSAGES.has_key(key):
+        if key in nt_errors.ERROR_MESSAGES:
             error_msg_short = nt_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] 
             return 'LSAD SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -150,9 +150,9 @@ class STRING(NDRSTRUCT):
         if msg is None: msg = self.__class__.__name__
         ind = ' '*indent
         if msg != '':
-            print "%s" % (msg),
+            print("%s" % (msg), end=' ')
         # Here just print the data
-        print " %r" % (self['Data']),
+        print(" %r" % (self['Data']), end=' ')
 
     def __setitem__(self, key, value):
         if key == 'Data':
--- impacket/dcerpc/v5/mimilib.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/mimilib.py
@@ -36,7 +36,7 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__( self ):
         key = self.error_code
-        if nt_errors.ERROR_MESSAGES.has_key(key):
+        if key in nt_errors.ERROR_MESSAGES:
             error_msg_short = nt_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] 
             return 'Mimikatz SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -180,7 +180,7 @@ OPNUMS = {
 class MimiDiffeH:
     def __init__(self):
         self.G = 2
-        self.P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFFL
+        self.P = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF
         self.privateKey = random.getrandbits(1024)
         #self.privateKey = int('A'*128, base=16)
 
@@ -224,12 +224,12 @@ if __name__ == '__main__':
     bob.P = 23
     bob.privateKey = 15
 
-    print 'Alice pubKey'
+    print('Alice pubKey')
     hexdump(alice.genPublicKey())
-    print 'Bob pubKey'
+    print('Bob pubKey')
     hexdump(bob.genPublicKey())
 
-    print 'Secret'
+    print('Secret')
     hexdump(alice.getSharedSecret(bob.genPublicKey()))
     hexdump(bob.getSharedSecret(alice.genPublicKey()))
 
--- impacket/dcerpc/v5/ndr.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/ndr.py
@@ -76,7 +76,7 @@ class NDR(object):
             if self._isNDR64 is False:
                 # Ok, let's change everything
                 self._isNDR64 = True
-                for fieldName in self.fields.keys():
+                for fieldName in list(self.fields.keys()):
                     if isinstance(self.fields[fieldName], NDR):
                         self.fields[fieldName].changeTransferSyntax(newSyntax)
                 # Finally, I change myself
@@ -94,7 +94,7 @@ class NDR(object):
                         if fieldTypeOrClass != self.fields[fieldName].__class__ and isinstance(self.fields[fieldName], NDRPOINTERNULL) is False:
                             backupData = self[fieldName]
                             self.fields[fieldName] = fieldTypeOrClass(isNDR64 = self._isNDR64)
-                            if self.fields[fieldName].fields.has_key('Data'):
+                            if 'Data' in self.fields[fieldName].fields:
                                 self.fields[fieldName].fields['Data'] = backupData
                             else:
                                 self[fieldName] = backupData
@@ -109,7 +109,7 @@ class NDR(object):
             value = NDRPOINTERNULL(isNDR64 = self._isNDR64)
             if isinstance(self.fields[key], NDRPOINTER):
                 self.fields[key] = value
-            elif self.fields[key].fields.has_key('Data'):
+            elif 'Data' in self.fields[key].fields:
                 if isinstance(self.fields[key].fields['Data'], NDRPOINTER):
                     self.fields[key].fields['Data'] = value
         elif isinstance(value, NDR):
@@ -131,7 +131,7 @@ class NDR(object):
 
     def __getitem__(self, key):
         if isinstance(self.fields[key], NDR):
-            if self.fields[key].fields.has_key('Data'):
+            if 'Data' in self.fields[key].fields:
                 return self.fields[key]['Data']
         return self.fields[key]
 
@@ -156,38 +156,38 @@ class NDR(object):
     def dumpRaw(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         ind = ' '*indent
-        print "\n%s" % msg
+        print("\n%s" % msg)
         for field in self.commonHdr+self.structure+self.referent:
             i = field[0] 
             if i in self.fields:
                 if isinstance(self.fields[i], NDR):
                     self.fields[i].dumpRaw('%s%s:{' % (ind,i), indent = indent + 4)
-                    print "%s}" % ind
+                    print("%s}" % ind)
 
                 elif isinstance(self.fields[i], list):
-                    print "%s[" % ind
+                    print("%s[" % ind)
                     for num,j in enumerate(self.fields[i]):
                        if isinstance(j, NDR):
                            j.dumpRaw('%s%s:' % (ind,i), indent = indent + 4)
-                           print "%s," % ind
+                           print("%s," % ind)
                        else:
-                           print "%s%s: {%r}," % (ind, i, j)
-                    print "%s]" % ind
+                           print("%s%s: {%r}," % (ind, i, j))
+                    print("%s]" % ind)
 
                 else:
-                    print "%s%s: {%r}" % (ind,i,self[i])
+                    print("%s%s: {%r}" % (ind,i,self[i]))
 
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         ind = ' '*indent
         if msg != '':
-            print "%s" % msg,
+            print("%s" % msg, end=' ')
         for fieldName, fieldType in self.commonHdr+self.structure+self.referent:
             if fieldName in self.fields:
                 if isinstance(self.fields[fieldName], NDR):
                     self.fields[fieldName].dump('\n%s%-31s' % (ind, fieldName+':'), indent = indent + 4),
                 else:
-                    print " %r" % (self[fieldName]),
+                    print(" %r" % (self[fieldName]), end=' ')
 
     def getAlignment(self):
         return self.align
@@ -228,7 +228,7 @@ class NDR(object):
 
                 data += res
                 soFar += len(res)
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error packing field '%s | %s' in %s" % (fieldName, fieldTypeOrClass, self.__class__))
                 raise
@@ -257,7 +257,7 @@ class NDR(object):
 
                 data = data[size:]
                 soFar += size
-            except Exception,e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error unpacking field '%s | %s | %r'" % (fieldName, fieldTypeOrClass, data[:256]))
                 raise
@@ -369,12 +369,12 @@ class NDRBOOLEAN(NDRSMALL):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print msg,
+            print(msg, end=' ')
 
         if self['Data'] > 0:
-            print " TRUE"
+            print(" TRUE")
         else:
-            print " FALSE"
+            print(" FALSE")
 
 class NDRCHAR(NDR):
     align = 1
@@ -434,8 +434,7 @@ class EnumType(type):
     def __getattr__(self, attr):
         return self.enumItems[attr].value
 
-class NDRENUM(NDR):
-    __metaclass__ = EnumType
+class NDRENUM(NDR, metaclass=EnumType):
     align = 2
     align64 = 4
     structure = (
@@ -462,9 +461,9 @@ class NDRENUM(NDR):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print msg,
+            print(msg, end=' ')
 
-        print " %s" % self.enumItems(self.fields['Data']).name,
+        print(" %s" % self.enumItems(self.fields['Data']).name, end=' ')
 
 # NDR Constructed Types (arrays, strings, structures, unions, variant structures, pipes and pointers)
 class NDRCONSTRUCTEDTYPE(NDR):
@@ -498,7 +497,7 @@ class NDRCONSTRUCTEDTYPE(NDR):
         if hasattr(self,'referent') is False:
             return ''
 
-        if self.fields.has_key('ReferentID'):
+        if 'ReferentID' in self.fields:
             if self['ReferentID'] == 0:
                 return ''
 
@@ -544,7 +543,7 @@ class NDRCONSTRUCTEDTYPE(NDR):
                     data += self.fields[fieldName].getDataReferent(soFar0 + len(data))
                 soFar = soFar0 + len(data)
 
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error packing field '%s | %s' in %s" % (fieldName, fieldTypeOrClass, self.__class__))
                 raise
@@ -623,7 +622,7 @@ class NDRCONSTRUCTEDTYPE(NDR):
 
         soFar0 = soFar
 
-        if self.fields.has_key('ReferentID'):
+        if 'ReferentID' in self.fields:
             if self['ReferentID'] == 0:
                 # NULL Pointer, there's no referent for it
                 return 0
@@ -653,7 +652,7 @@ class NDRCONSTRUCTEDTYPE(NDR):
                     size += self.fields[fieldName].fromStringReferent(data[size:], soFar + size)
                 data = data[size:]
                 soFar += size
-            except Exception,e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error unpacking field '%s | %s | %r'" % (fieldName, fieldTypeOrClass, data[:256]))
                 raise
@@ -676,20 +675,20 @@ class NDRArray(NDRCONSTRUCTEDTYPE):
         if msg is None: msg = self.__class__.__name__
         ind = ' '*indent
         if msg != '':
-            print msg,
+            print(msg, end=' ')
 
         if isinstance(self['Data'], list):
-            print "\n%s[" % ind
+            print("\n%s[" % ind)
             ind += ' '*4
             for num,j in enumerate(self.fields['Data']):
                if isinstance(j, NDR):
                    j.dump('%s' % ind, indent = indent + 4),
-                   print "," 
+                   print(",") 
                else:
-                   print "%s %r," % (ind,j)
-            print "%s]" % ind[:-4],
+                   print("%s %r," % (ind,j))
+            print("%s]" % ind[:-4], end=' ')
         else:
-            print " %r" % self['Data'],
+            print(" %r" % self['Data'], end=' ')
 
     def setArraySize(self, size):
         self.arraySize = size
@@ -736,7 +735,7 @@ class NDRArray(NDRCONSTRUCTEDTYPE):
                 res = self.pack(fieldName, fieldTypeOrClass, soFar)
                 data += res
                 soFar = soFar0 + len(data)
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error packing field '%s | %s' in %s" % (fieldName, fieldTypeOrClass, self.__class__))
                 raise
@@ -799,7 +798,7 @@ class NDRArray(NDRCONSTRUCTEDTYPE):
 
                 data = data[size:]
                 soFar += size
-            except Exception,e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error unpacking field '%s | %s | %r'" % (fieldName, fieldTypeOrClass, data[:256]))
                 raise
@@ -958,7 +957,7 @@ class NDRUniConformantVaryingArray(NDRArray):
                 res = self.pack(fieldName, fieldTypeOrClass, soFar)
                 data += res
                 soFar = soFar0 + len(data)
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error packing field '%s | %s' in %s" % (fieldName, fieldTypeOrClass, self.__class__))
                 raise
@@ -1063,7 +1062,7 @@ class NDRSTRUCT(NDRCONSTRUCTEDTYPE):
                     res = self.pack(fieldName, fieldTypeOrClass, soFar)
                 data += res
                 soFar = soFar0 + len(data) + len(arrayPadding) + arrayItemSize
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error packing field '%s | %s' in %s" % (fieldName, fieldTypeOrClass, self.__class__))
                 raise
@@ -1159,7 +1158,7 @@ class NDRSTRUCT(NDRCONSTRUCTEDTYPE):
 
                 data = data[size:]
                 soFar += size
-            except Exception,e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error unpacking field '%s | %s | %r'" % (fieldName, fieldTypeOrClass, data[:256]))
                 raise
@@ -1253,14 +1252,14 @@ class NDRUNION(NDRCONSTRUCTEDTYPE):
         if key == 'tag':
             # We're writing the tag, we now should set the right item for the structure
             self.structure = ()
-            if self.union.has_key(value):
+            if value in self.union:
                 self.structure = (self.union[value]),
                 # Init again the structure
                 self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)
                 self.fields['tag']['Data'] = value
             else:
                 # Let's see if we have a default value
-                if self.union.has_key('default'):
+                if 'default' in self.union:
                     if self.union['default'] is None:
                         self.structure = ()
                     else:
@@ -1297,7 +1296,7 @@ class NDRUNION(NDRCONSTRUCTEDTYPE):
                 res = self.pack(fieldName, fieldTypeOrClass, soFar)
                 data += res
                 soFar = soFar0 + len(data)
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error packing field '%s | %s' in %s" % (fieldName, fieldTypeOrClass, self.__class__))
                 raise
@@ -1333,7 +1332,7 @@ class NDRUNION(NDRCONSTRUCTEDTYPE):
                 res = self.pack(fieldName, fieldTypeOrClass, soFar)
                 data += res
                 soFar = soFar0 + len(data)
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error packing field '%s | %s' in %s" % (fieldName, fieldTypeOrClass, self.__class__))
                 raise
@@ -1357,12 +1356,12 @@ class NDRUNION(NDRCONSTRUCTEDTYPE):
             # We need to know the tag type and unpack it
             tagtype = self.commonHdr[0][1].structure[0][1].split('=')[0]
             tag = unpack(tagtype, data[:calcsize(tagtype)])[0]
-            if self.union.has_key(tag):
+            if tag in self.union:
                 self.structure = (self.union[tag]),
                 self.__init__(None, isNDR64=self._isNDR64, topLevel = self.topLevel)
             else:
                 # Let's see if we have a default value
-                if self.union.has_key('default'):
+                if 'default' in self.union:
                     if self.union['default'] is None:
                         self.structure = ()
                     else:
@@ -1384,7 +1383,7 @@ class NDRUNION(NDRCONSTRUCTEDTYPE):
 
                 data = data[size:]
                 soFar += size
-            except Exception,e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error unpacking field '%s | %s | %r'" % (fieldName, fieldTypeOrClass, data[:256]))
                 raise
@@ -1421,7 +1420,7 @@ class NDRUNION(NDRCONSTRUCTEDTYPE):
 
                 data = data[size:]
                 soFar += size
-            except Exception,e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error unpacking field '%s | %s | %r'" % (fieldName, fieldTypeOrClass, data[:256]))
                 raise
@@ -1448,7 +1447,7 @@ class NDRUNION(NDRCONSTRUCTEDTYPE):
                 align = tmpAlign
 
         if self._isNDR64:
-            for fieldName, fieldTypeOrClass in self.union.itervalues():
+            for fieldName, fieldTypeOrClass in self.union.values():
                 tmpAlign = fieldTypeOrClass(isNDR64 = self._isNDR64).getAlignment()
                 if tmpAlign > align:
                     align = tmpAlign
@@ -1470,9 +1469,9 @@ class NDRPOINTERNULL(NDR):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print "%s" % msg,
+            print("%s" % msg, end=' ')
         # Here we just print NULL
-        print " NULL",
+        print(" NULL", end=' ')
 
 NULL = NDRPOINTERNULL()
 
@@ -1507,16 +1506,16 @@ class NDRPOINTER(NDRSTRUCT):
            self.fromString(data)
 
     def __setitem__(self, key, value):
-        if self.fields.has_key(key) is False:
+        if (key in self.fields) is False:
             # Key not found.. let's send it to the referent to handle, maybe it's there
             return self.fields['Data'].__setitem__(key,value)
         else:
             return NDRSTRUCT.__setitem__(self,key,value)
 
     def __getitem__(self, key):
-        if self.fields.has_key(key):
+        if key in self.fields:
             if isinstance(self.fields[key], NDR):
-                if self.fields[key].fields.has_key('Data'):
+                if 'Data' in self.fields[key].fields:
                     return self.fields[key]['Data']
             return self.fields[key]
         else:
@@ -1570,15 +1569,15 @@ class NDRPOINTER(NDRSTRUCT):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print "%s" % msg,
+            print("%s" % msg, end=' ')
         # Here we just print the referent
         if isinstance(self.fields['Data'], NDR):
             self.fields['Data'].dump('', indent = indent)
         else:
             if self['ReferentID'] == 0:
-                print " NULL",
+                print(" NULL", end=' ')
             else:
-                print " %r" % (self['Data']),
+                print(" %r" % (self['Data']), end=' ')
 
     def getAlignment(self):
         if self._isNDR64 is True:
@@ -1649,7 +1648,7 @@ class NDRCALL(NDRCONSTRUCTEDTYPE):
 
     def dump(self, msg = None, indent = 0):
         NDRCONSTRUCTEDTYPE.dump(self, msg, indent)
-        print '\n\n'
+        print('\n\n')
 
     def getData(self, soFar = 0):
         data = ''
@@ -1692,7 +1691,7 @@ class NDRCALL(NDRCONSTRUCTEDTYPE):
                     soFar = soFar0 + len(data)
                     data += self.fields[fieldName].getDataReferent(soFar)
                     soFar = soFar0 + len(data)
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error packing field '%s | %s' in %s" % (fieldName, fieldTypeOrClass, self.__class__))
                 raise
@@ -1720,7 +1719,7 @@ class NDRCALL(NDRCONSTRUCTEDTYPE):
                     size += self.fields[fieldName].fromStringReferent(data[size:], soFar + size)
                 data = data[size:]
                 soFar += size
-            except Exception,e:
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.error("Error unpacking field '%s | %s | %r'" % (fieldName, fieldTypeOrClass, data[:256]))
                 raise
@@ -1747,24 +1746,24 @@ class NDRTest:
             return self.theClass(isNDR64 = isNDR64)
 
     def test(self, isNDR64 = False):
-        print
-        print "-"*70
+        print()
+        print("-"*70)
         testName = self.__class__.__name__
-        print "starting test: %s (NDR64 = %s)....." % (testName, isNDR64)
+        print("starting test: %s (NDR64 = %s)....." % (testName, isNDR64))
         a = self.create(isNDR64 = isNDR64)
         self.populate(a)
         a.dump("packing.....")
         a_str = str(a)
-        print "packed:" 
+        print("packed:") 
         hexdump(a_str)
-        print "unpacking....."
+        print("unpacking.....")
         b = self.create(a_str, isNDR64 = isNDR64)
         b.dump("unpacked.....")
-        print "\nrepacking....."
+        print("\nrepacking.....")
         b_str = str(b)
         if b_str != a_str:
-            print "ERROR: original packed and repacked don't match"
-            print "packed: " 
+            print("ERROR: original packed and repacked don't match")
+            print("packed: ") 
             hexdump(b_str)
             raise
 
--- impacket/dcerpc/v5/rpcrt.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/rpcrt.py
@@ -119,427 +119,427 @@ rpc_cont_def_result = {
 #http://www.opengroup.org/onlinepubs/9629399/apdxn.htm
 
 rpc_status_codes = {
-    0x00000005L : 'rpc_s_access_denied',
-    0x00000008L : 'Authentication type not recognized',
-    0x000006D8L : 'rpc_fault_cant_perform', 
-    0x000006C6L : 'rpc_x_invalid_bound',                # the arrays bound are invalid
-    0x000006E4L : 'rpc_s_cannot_support: The requested operation is not supported.',               # some operation is not supported
-    0x000006F7L : 'rpc_x_bad_stub_data',                # the stub data is invalid, doesn't match with the IDL definition
-    0x1C010001L : 'nca_s_comm_failure',                 # unable to get response from server:
-    0x1C010002L : 'nca_s_op_rng_error',                 # bad operation number in call
-    0x1C010003L : 'nca_s_unk_if',                       # unknown interface
-    0x1C010006L : 'nca_s_wrong_boot_time',              # client passed server wrong server boot time
-    0x1C010009L : 'nca_s_you_crashed',                  # a restarted server called back a client
-    0x1C01000BL : 'nca_s_proto_error',                  # someone messed up the protocol
-    0x1C010013L : 'nca_s_out_args_too_big ',            # output args too big
-    0x1C010014L : 'nca_s_server_too_busy',              # server is too busy to handle call
-    0x1C010015L : 'nca_s_fault_string_too_long',        # string argument longer than declared max len
-    0x1C010017L : 'nca_s_unsupported_type ',            # no implementation of generic operation for object
-    0x1C000001L : 'nca_s_fault_int_div_by_zero',
-    0x1C000002L : 'nca_s_fault_addr_error ',
-    0x1C000003L : 'nca_s_fault_fp_div_zero',
-    0x1C000004L : 'nca_s_fault_fp_underflow',
-    0x1C000005L : 'nca_s_fault_fp_overflow',
-    0x1C000006L : 'nca_s_fault_invalid_tag',
-    0x1C000007L : 'nca_s_fault_invalid_bound ',
-    0x1C000008L : 'nca_s_rpc_version_mismatch',
-    0x1C000009L : 'nca_s_unspec_reject ',
-    0x1C00000AL : 'nca_s_bad_actid',
-    0x1C00000BL : 'nca_s_who_are_you_failed',
-    0x1C00000CL : 'nca_s_manager_not_entered ',
-    0x1C00000DL : 'nca_s_fault_cancel',
-    0x1C00000EL : 'nca_s_fault_ill_inst',
-    0x1C00000FL : 'nca_s_fault_fp_error',
-    0x1C000010L : 'nca_s_fault_int_overflow',
-    0x1C000012L : 'nca_s_fault_unspec',
-    0x1C000013L : 'nca_s_fault_remote_comm_failure ',
-    0x1C000014L : 'nca_s_fault_pipe_empty ',
-    0x1C000015L : 'nca_s_fault_pipe_closed',
-    0x1C000016L : 'nca_s_fault_pipe_order ',
-    0x1C000017L : 'nca_s_fault_pipe_discipline',
-    0x1C000018L : 'nca_s_fault_pipe_comm_error',
-    0x1C000019L : 'nca_s_fault_pipe_memory',
-    0x1C00001AL : 'nca_s_fault_context_mismatch ',
-    0x1C00001BL : 'nca_s_fault_remote_no_memory ',
-    0x1C00001CL : 'nca_s_invalid_pres_context_id',
-    0x1C00001DL : 'nca_s_unsupported_authn_level',
-    0x1C00001FL : 'nca_s_invalid_checksum ',
-    0x1C000020L : 'nca_s_invalid_crc',
-    0x1C000021L : 'nca_s_fault_user_defined',
-    0x1C000022L : 'nca_s_fault_tx_open_failed',
-    0x1C000023L : 'nca_s_fault_codeset_conv_error',
-    0x1C000024L : 'nca_s_fault_object_not_found ',
-    0x1C000025L : 'nca_s_fault_no_client_stub',
-    0x16c9a000L : "rpc_s_mod",
-    0x16c9a001L : "rpc_s_op_rng_error",
-    0x16c9a002L : "rpc_s_cant_create_socket",
-    0x16c9a003L : "rpc_s_cant_bind_socket",
-    0x16c9a004L : "rpc_s_not_in_call",
-    0x16c9a005L : "rpc_s_no_port",
-    0x16c9a006L : "rpc_s_wrong_boot_time",
-    0x16c9a007L : "rpc_s_too_many_sockets",
-    0x16c9a008L : "rpc_s_illegal_register",
-    0x16c9a009L : "rpc_s_cant_recv",
-    0x16c9a00aL : "rpc_s_bad_pkt",
-    0x16c9a00bL : "rpc_s_unbound_handle",
-    0x16c9a00cL : "rpc_s_addr_in_use",
-    0x16c9a00dL : "rpc_s_in_args_too_big",
-    0x16c9a00eL : "rpc_s_string_too_long",
-    0x16c9a00fL : "rpc_s_too_many_objects",
-    0x16c9a010L : "rpc_s_binding_has_no_auth",
-    0x16c9a011L : "rpc_s_unknown_authn_service",
-    0x16c9a012L : "rpc_s_no_memory",
-    0x16c9a013L : "rpc_s_cant_nmalloc",
-    0x16c9a014L : "rpc_s_call_faulted",
-    0x16c9a015L : "rpc_s_call_failed",
-    0x16c9a016L : "rpc_s_comm_failure",
-    0x16c9a017L : "rpc_s_rpcd_comm_failure",
-    0x16c9a018L : "rpc_s_illegal_family_rebind",
-    0x16c9a019L : "rpc_s_invalid_handle",
-    0x16c9a01aL : "rpc_s_coding_error",
-    0x16c9a01bL : "rpc_s_object_not_found",
-    0x16c9a01cL : "rpc_s_cthread_not_found",
-    0x16c9a01dL : "rpc_s_invalid_binding",
-    0x16c9a01eL : "rpc_s_already_registered",
-    0x16c9a01fL : "rpc_s_endpoint_not_found",
-    0x16c9a020L : "rpc_s_invalid_rpc_protseq",
-    0x16c9a021L : "rpc_s_desc_not_registered",
-    0x16c9a022L : "rpc_s_already_listening",
-    0x16c9a023L : "rpc_s_no_protseqs",
-    0x16c9a024L : "rpc_s_no_protseqs_registered",
-    0x16c9a025L : "rpc_s_no_bindings",
-    0x16c9a026L : "rpc_s_max_descs_exceeded",
-    0x16c9a027L : "rpc_s_no_interfaces",
-    0x16c9a028L : "rpc_s_invalid_timeout",
-    0x16c9a029L : "rpc_s_cant_inq_socket",
-    0x16c9a02aL : "rpc_s_invalid_naf_id",
-    0x16c9a02bL : "rpc_s_inval_net_addr",
-    0x16c9a02cL : "rpc_s_unknown_if",
-    0x16c9a02dL : "rpc_s_unsupported_type",
-    0x16c9a02eL : "rpc_s_invalid_call_opt",
-    0x16c9a02fL : "rpc_s_no_fault",
-    0x16c9a030L : "rpc_s_cancel_timeout",
-    0x16c9a031L : "rpc_s_call_cancelled",
-    0x16c9a032L : "rpc_s_invalid_call_handle",
-    0x16c9a033L : "rpc_s_cannot_alloc_assoc",
-    0x16c9a034L : "rpc_s_cannot_connect",
-    0x16c9a035L : "rpc_s_connection_aborted",
-    0x16c9a036L : "rpc_s_connection_closed",
-    0x16c9a037L : "rpc_s_cannot_accept",
-    0x16c9a038L : "rpc_s_assoc_grp_not_found",
-    0x16c9a039L : "rpc_s_stub_interface_error",
-    0x16c9a03aL : "rpc_s_invalid_object",
-    0x16c9a03bL : "rpc_s_invalid_type",
-    0x16c9a03cL : "rpc_s_invalid_if_opnum",
-    0x16c9a03dL : "rpc_s_different_server_instance",
-    0x16c9a03eL : "rpc_s_protocol_error",
-    0x16c9a03fL : "rpc_s_cant_recvmsg",
-    0x16c9a040L : "rpc_s_invalid_string_binding",
-    0x16c9a041L : "rpc_s_connect_timed_out",
-    0x16c9a042L : "rpc_s_connect_rejected",
-    0x16c9a043L : "rpc_s_network_unreachable",
-    0x16c9a044L : "rpc_s_connect_no_resources",
-    0x16c9a045L : "rpc_s_rem_network_shutdown",
-    0x16c9a046L : "rpc_s_too_many_rem_connects",
-    0x16c9a047L : "rpc_s_no_rem_endpoint",
-    0x16c9a048L : "rpc_s_rem_host_down",
-    0x16c9a049L : "rpc_s_host_unreachable",
-    0x16c9a04aL : "rpc_s_access_control_info_inv",
-    0x16c9a04bL : "rpc_s_loc_connect_aborted",
-    0x16c9a04cL : "rpc_s_connect_closed_by_rem",
-    0x16c9a04dL : "rpc_s_rem_host_crashed",
-    0x16c9a04eL : "rpc_s_invalid_endpoint_format",
-    0x16c9a04fL : "rpc_s_unknown_status_code",
-    0x16c9a050L : "rpc_s_unknown_mgr_type",
-    0x16c9a051L : "rpc_s_assoc_creation_failed",
-    0x16c9a052L : "rpc_s_assoc_grp_max_exceeded",
-    0x16c9a053L : "rpc_s_assoc_grp_alloc_failed",
-    0x16c9a054L : "rpc_s_sm_invalid_state",
-    0x16c9a055L : "rpc_s_assoc_req_rejected",
-    0x16c9a056L : "rpc_s_assoc_shutdown",
-    0x16c9a057L : "rpc_s_tsyntaxes_unsupported",
-    0x16c9a058L : "rpc_s_context_id_not_found",
-    0x16c9a059L : "rpc_s_cant_listen_socket",
-    0x16c9a05aL : "rpc_s_no_addrs",
-    0x16c9a05bL : "rpc_s_cant_getpeername",
-    0x16c9a05cL : "rpc_s_cant_get_if_id",
-    0x16c9a05dL : "rpc_s_protseq_not_supported",
-    0x16c9a05eL : "rpc_s_call_orphaned",
-    0x16c9a05fL : "rpc_s_who_are_you_failed",
-    0x16c9a060L : "rpc_s_unknown_reject",
-    0x16c9a061L : "rpc_s_type_already_registered",
-    0x16c9a062L : "rpc_s_stop_listening_disabled",
-    0x16c9a063L : "rpc_s_invalid_arg",
-    0x16c9a064L : "rpc_s_not_supported",
-    0x16c9a065L : "rpc_s_wrong_kind_of_binding",
-    0x16c9a066L : "rpc_s_authn_authz_mismatch",
-    0x16c9a067L : "rpc_s_call_queued",
-    0x16c9a068L : "rpc_s_cannot_set_nodelay",
-    0x16c9a069L : "rpc_s_not_rpc_tower",
-    0x16c9a06aL : "rpc_s_invalid_rpc_protid",
-    0x16c9a06bL : "rpc_s_invalid_rpc_floor",
-    0x16c9a06cL : "rpc_s_call_timeout",
-    0x16c9a06dL : "rpc_s_mgmt_op_disallowed",
-    0x16c9a06eL : "rpc_s_manager_not_entered",
-    0x16c9a06fL : "rpc_s_calls_too_large_for_wk_ep",
-    0x16c9a070L : "rpc_s_server_too_busy",
-    0x16c9a071L : "rpc_s_prot_version_mismatch",
-    0x16c9a072L : "rpc_s_rpc_prot_version_mismatch",
-    0x16c9a073L : "rpc_s_ss_no_import_cursor",
-    0x16c9a074L : "rpc_s_fault_addr_error",
-    0x16c9a075L : "rpc_s_fault_context_mismatch",
-    0x16c9a076L : "rpc_s_fault_fp_div_by_zero",
-    0x16c9a077L : "rpc_s_fault_fp_error",
-    0x16c9a078L : "rpc_s_fault_fp_overflow",
-    0x16c9a079L : "rpc_s_fault_fp_underflow",
-    0x16c9a07aL : "rpc_s_fault_ill_inst",
-    0x16c9a07bL : "rpc_s_fault_int_div_by_zero",
-    0x16c9a07cL : "rpc_s_fault_int_overflow",
-    0x16c9a07dL : "rpc_s_fault_invalid_bound",
-    0x16c9a07eL : "rpc_s_fault_invalid_tag",
-    0x16c9a07fL : "rpc_s_fault_pipe_closed",
-    0x16c9a080L : "rpc_s_fault_pipe_comm_error",
-    0x16c9a081L : "rpc_s_fault_pipe_discipline",
-    0x16c9a082L : "rpc_s_fault_pipe_empty",
-    0x16c9a083L : "rpc_s_fault_pipe_memory",
-    0x16c9a084L : "rpc_s_fault_pipe_order",
-    0x16c9a085L : "rpc_s_fault_remote_comm_failure",
-    0x16c9a086L : "rpc_s_fault_remote_no_memory",
-    0x16c9a087L : "rpc_s_fault_unspec",
-    0x16c9a088L : "uuid_s_bad_version",
-    0x16c9a089L : "uuid_s_socket_failure",
-    0x16c9a08aL : "uuid_s_getconf_failure",
-    0x16c9a08bL : "uuid_s_no_address",
-    0x16c9a08cL : "uuid_s_overrun",
-    0x16c9a08dL : "uuid_s_internal_error",
-    0x16c9a08eL : "uuid_s_coding_error",
-    0x16c9a08fL : "uuid_s_invalid_string_uuid",
-    0x16c9a090L : "uuid_s_no_memory",
-    0x16c9a091L : "rpc_s_no_more_entries",
-    0x16c9a092L : "rpc_s_unknown_ns_error",
-    0x16c9a093L : "rpc_s_name_service_unavailable",
-    0x16c9a094L : "rpc_s_incomplete_name",
-    0x16c9a095L : "rpc_s_group_not_found",
-    0x16c9a096L : "rpc_s_invalid_name_syntax",
-    0x16c9a097L : "rpc_s_no_more_members",
-    0x16c9a098L : "rpc_s_no_more_interfaces",
-    0x16c9a099L : "rpc_s_invalid_name_service",
-    0x16c9a09aL : "rpc_s_no_name_mapping",
-    0x16c9a09bL : "rpc_s_profile_not_found",
-    0x16c9a09cL : "rpc_s_not_found",
-    0x16c9a09dL : "rpc_s_no_updates",
-    0x16c9a09eL : "rpc_s_update_failed",
-    0x16c9a09fL : "rpc_s_no_match_exported",
-    0x16c9a0a0L : "rpc_s_entry_not_found",
-    0x16c9a0a1L : "rpc_s_invalid_inquiry_context",
-    0x16c9a0a2L : "rpc_s_interface_not_found",
-    0x16c9a0a3L : "rpc_s_group_member_not_found",
-    0x16c9a0a4L : "rpc_s_entry_already_exists",
-    0x16c9a0a5L : "rpc_s_nsinit_failure",
-    0x16c9a0a6L : "rpc_s_unsupported_name_syntax",
-    0x16c9a0a7L : "rpc_s_no_more_elements",
-    0x16c9a0a8L : "rpc_s_no_ns_permission",
-    0x16c9a0a9L : "rpc_s_invalid_inquiry_type",
-    0x16c9a0aaL : "rpc_s_profile_element_not_found",
-    0x16c9a0abL : "rpc_s_profile_element_replaced",
-    0x16c9a0acL : "rpc_s_import_already_done",
-    0x16c9a0adL : "rpc_s_database_busy",
-    0x16c9a0aeL : "rpc_s_invalid_import_context",
-    0x16c9a0afL : "rpc_s_uuid_set_not_found",
-    0x16c9a0b0L : "rpc_s_uuid_member_not_found",
-    0x16c9a0b1L : "rpc_s_no_interfaces_exported",
-    0x16c9a0b2L : "rpc_s_tower_set_not_found",
-    0x16c9a0b3L : "rpc_s_tower_member_not_found",
-    0x16c9a0b4L : "rpc_s_obj_uuid_not_found",
-    0x16c9a0b5L : "rpc_s_no_more_bindings",
-    0x16c9a0b6L : "rpc_s_invalid_priority",
-    0x16c9a0b7L : "rpc_s_not_rpc_entry",
-    0x16c9a0b8L : "rpc_s_invalid_lookup_context",
-    0x16c9a0b9L : "rpc_s_binding_vector_full",
-    0x16c9a0baL : "rpc_s_cycle_detected",
-    0x16c9a0bbL : "rpc_s_nothing_to_export",
-    0x16c9a0bcL : "rpc_s_nothing_to_unexport",
-    0x16c9a0bdL : "rpc_s_invalid_vers_option",
-    0x16c9a0beL : "rpc_s_no_rpc_data",
-    0x16c9a0bfL : "rpc_s_mbr_picked",
-    0x16c9a0c0L : "rpc_s_not_all_objs_unexported",
-    0x16c9a0c1L : "rpc_s_no_entry_name",
-    0x16c9a0c2L : "rpc_s_priority_group_done",
-    0x16c9a0c3L : "rpc_s_partial_results",
-    0x16c9a0c4L : "rpc_s_no_env_setup",
-    0x16c9a0c5L : "twr_s_unknown_sa",
-    0x16c9a0c6L : "twr_s_unknown_tower",
-    0x16c9a0c7L : "twr_s_not_implemented",
-    0x16c9a0c8L : "rpc_s_max_calls_too_small",
-    0x16c9a0c9L : "rpc_s_cthread_create_failed",
-    0x16c9a0caL : "rpc_s_cthread_pool_exists",
-    0x16c9a0cbL : "rpc_s_cthread_no_such_pool",
-    0x16c9a0ccL : "rpc_s_cthread_invoke_disabled",
-    0x16c9a0cdL : "ept_s_cant_perform_op",
-    0x16c9a0ceL : "ept_s_no_memory",
-    0x16c9a0cfL : "ept_s_database_invalid",
-    0x16c9a0d0L : "ept_s_cant_create",
-    0x16c9a0d1L : "ept_s_cant_access",
-    0x16c9a0d2L : "ept_s_database_already_open",
-    0x16c9a0d3L : "ept_s_invalid_entry",
-    0x16c9a0d4L : "ept_s_update_failed",
-    0x16c9a0d5L : "ept_s_invalid_context",
-    0x16c9a0d6L : "ept_s_not_registered",
-    0x16c9a0d7L : "ept_s_server_unavailable",
-    0x16c9a0d8L : "rpc_s_underspecified_name",
-    0x16c9a0d9L : "rpc_s_invalid_ns_handle",
-    0x16c9a0daL : "rpc_s_unknown_error",
-    0x16c9a0dbL : "rpc_s_ss_char_trans_open_fail",
-    0x16c9a0dcL : "rpc_s_ss_char_trans_short_file",
-    0x16c9a0ddL : "rpc_s_ss_context_damaged",
-    0x16c9a0deL : "rpc_s_ss_in_null_context",
-    0x16c9a0dfL : "rpc_s_socket_failure",
-    0x16c9a0e0L : "rpc_s_unsupported_protect_level",
-    0x16c9a0e1L : "rpc_s_invalid_checksum",
-    0x16c9a0e2L : "rpc_s_invalid_credentials",
-    0x16c9a0e3L : "rpc_s_credentials_too_large",
-    0x16c9a0e4L : "rpc_s_call_id_not_found",
-    0x16c9a0e5L : "rpc_s_key_id_not_found",
-    0x16c9a0e6L : "rpc_s_auth_bad_integrity",
-    0x16c9a0e7L : "rpc_s_auth_tkt_expired",
-    0x16c9a0e8L : "rpc_s_auth_tkt_nyv",
-    0x16c9a0e9L : "rpc_s_auth_repeat",
-    0x16c9a0eaL : "rpc_s_auth_not_us",
-    0x16c9a0ebL : "rpc_s_auth_badmatch",
-    0x16c9a0ecL : "rpc_s_auth_skew",
-    0x16c9a0edL : "rpc_s_auth_badaddr",
-    0x16c9a0eeL : "rpc_s_auth_badversion",
-    0x16c9a0efL : "rpc_s_auth_msg_type",
-    0x16c9a0f0L : "rpc_s_auth_modified",
-    0x16c9a0f1L : "rpc_s_auth_badorder",
-    0x16c9a0f2L : "rpc_s_auth_badkeyver",
-    0x16c9a0f3L : "rpc_s_auth_nokey",
-    0x16c9a0f4L : "rpc_s_auth_mut_fail",
-    0x16c9a0f5L : "rpc_s_auth_baddirection",
-    0x16c9a0f6L : "rpc_s_auth_method",
-    0x16c9a0f7L : "rpc_s_auth_badseq",
-    0x16c9a0f8L : "rpc_s_auth_inapp_cksum",
-    0x16c9a0f9L : "rpc_s_auth_field_toolong",
-    0x16c9a0faL : "rpc_s_invalid_crc",
-    0x16c9a0fbL : "rpc_s_binding_incomplete",
-    0x16c9a0fcL : "rpc_s_key_func_not_allowed",
-    0x16c9a0fdL : "rpc_s_unknown_stub_rtl_if_vers",
-    0x16c9a0feL : "rpc_s_unknown_ifspec_vers",
-    0x16c9a0ffL : "rpc_s_proto_unsupp_by_auth",
-    0x16c9a100L : "rpc_s_authn_challenge_malformed",
-    0x16c9a101L : "rpc_s_protect_level_mismatch",
-    0x16c9a102L : "rpc_s_no_mepv",
-    0x16c9a103L : "rpc_s_stub_protocol_error",
-    0x16c9a104L : "rpc_s_class_version_mismatch",
-    0x16c9a105L : "rpc_s_helper_not_running",
-    0x16c9a106L : "rpc_s_helper_short_read",
-    0x16c9a107L : "rpc_s_helper_catatonic",
-    0x16c9a108L : "rpc_s_helper_aborted",
-    0x16c9a109L : "rpc_s_not_in_kernel",
-    0x16c9a10aL : "rpc_s_helper_wrong_user",
-    0x16c9a10bL : "rpc_s_helper_overflow",
-    0x16c9a10cL : "rpc_s_dg_need_way_auth",
-    0x16c9a10dL : "rpc_s_unsupported_auth_subtype",
-    0x16c9a10eL : "rpc_s_wrong_pickle_type",
-    0x16c9a10fL : "rpc_s_not_listening",
-    0x16c9a110L : "rpc_s_ss_bad_buffer",
-    0x16c9a111L : "rpc_s_ss_bad_es_action",
-    0x16c9a112L : "rpc_s_ss_wrong_es_version",
-    0x16c9a113L : "rpc_s_fault_user_defined",
-    0x16c9a114L : "rpc_s_ss_incompatible_codesets",
-    0x16c9a115L : "rpc_s_tx_not_in_transaction",
-    0x16c9a116L : "rpc_s_tx_open_failed",
-    0x16c9a117L : "rpc_s_partial_credentials",
-    0x16c9a118L : "rpc_s_ss_invalid_codeset_tag",
-    0x16c9a119L : "rpc_s_mgmt_bad_type",
-    0x16c9a11aL : "rpc_s_ss_invalid_char_input",
-    0x16c9a11bL : "rpc_s_ss_short_conv_buffer",
-    0x16c9a11cL : "rpc_s_ss_iconv_error",
-    0x16c9a11dL : "rpc_s_ss_no_compat_codeset",
-    0x16c9a11eL : "rpc_s_ss_no_compat_charsets",
-    0x16c9a11fL : "dce_cs_c_ok",
-    0x16c9a120L : "dce_cs_c_unknown",
-    0x16c9a121L : "dce_cs_c_notfound",
-    0x16c9a122L : "dce_cs_c_cannot_open_file",
-    0x16c9a123L : "dce_cs_c_cannot_read_file",
-    0x16c9a124L : "dce_cs_c_cannot_allocate_memory",
-    0x16c9a125L : "rpc_s_ss_cleanup_failed",
-    0x16c9a126L : "rpc_svc_desc_general",
-    0x16c9a127L : "rpc_svc_desc_mutex",
-    0x16c9a128L : "rpc_svc_desc_xmit",
-    0x16c9a129L : "rpc_svc_desc_recv",
-    0x16c9a12aL : "rpc_svc_desc_dg_state",
-    0x16c9a12bL : "rpc_svc_desc_cancel",
-    0x16c9a12cL : "rpc_svc_desc_orphan",
-    0x16c9a12dL : "rpc_svc_desc_cn_state",
-    0x16c9a12eL : "rpc_svc_desc_cn_pkt",
-    0x16c9a12fL : "rpc_svc_desc_pkt_quotas",
-    0x16c9a130L : "rpc_svc_desc_auth",
-    0x16c9a131L : "rpc_svc_desc_source",
-    0x16c9a132L : "rpc_svc_desc_stats",
-    0x16c9a133L : "rpc_svc_desc_mem",
-    0x16c9a134L : "rpc_svc_desc_mem_type",
-    0x16c9a135L : "rpc_svc_desc_dg_pktlog",
-    0x16c9a136L : "rpc_svc_desc_thread_id",
-    0x16c9a137L : "rpc_svc_desc_timestamp",
-    0x16c9a138L : "rpc_svc_desc_cn_errors",
-    0x16c9a139L : "rpc_svc_desc_conv_thread",
-    0x16c9a13aL : "rpc_svc_desc_pid",
-    0x16c9a13bL : "rpc_svc_desc_atfork",
-    0x16c9a13cL : "rpc_svc_desc_cma_thread",
-    0x16c9a13dL : "rpc_svc_desc_inherit",
-    0x16c9a13eL : "rpc_svc_desc_dg_sockets",
-    0x16c9a13fL : "rpc_svc_desc_timer",
-    0x16c9a140L : "rpc_svc_desc_threads",
-    0x16c9a141L : "rpc_svc_desc_server_call",
-    0x16c9a142L : "rpc_svc_desc_nsi",
-    0x16c9a143L : "rpc_svc_desc_dg_pkt",
-    0x16c9a144L : "rpc_m_cn_ill_state_trans_sa",
-    0x16c9a145L : "rpc_m_cn_ill_state_trans_ca",
-    0x16c9a146L : "rpc_m_cn_ill_state_trans_sg",
-    0x16c9a147L : "rpc_m_cn_ill_state_trans_cg",
-    0x16c9a148L : "rpc_m_cn_ill_state_trans_sr",
-    0x16c9a149L : "rpc_m_cn_ill_state_trans_cr",
-    0x16c9a14aL : "rpc_m_bad_pkt_type",
-    0x16c9a14bL : "rpc_m_prot_mismatch",
-    0x16c9a14cL : "rpc_m_frag_toobig",
-    0x16c9a14dL : "rpc_m_unsupp_stub_rtl_if",
-    0x16c9a14eL : "rpc_m_unhandled_callstate",
-    0x16c9a14fL : "rpc_m_call_failed",
-    0x16c9a150L : "rpc_m_call_failed_no_status",
-    0x16c9a151L : "rpc_m_call_failed_errno",
-    0x16c9a152L : "rpc_m_call_failed_s",
-    0x16c9a153L : "rpc_m_call_failed_c",
-    0x16c9a154L : "rpc_m_errmsg_toobig",
-    0x16c9a155L : "rpc_m_invalid_srchattr",
-    0x16c9a156L : "rpc_m_nts_not_found",
-    0x16c9a157L : "rpc_m_invalid_accbytcnt",
-    0x16c9a158L : "rpc_m_pre_v2_ifspec",
-    0x16c9a159L : "rpc_m_unk_ifspec",
-    0x16c9a15aL : "rpc_m_recvbuf_toosmall",
-    0x16c9a15bL : "rpc_m_unalign_authtrl",
-    0x16c9a15cL : "rpc_m_unexpected_exc",
-    0x16c9a15dL : "rpc_m_no_stub_data",
-    0x16c9a15eL : "rpc_m_eventlist_full",
-    0x16c9a15fL : "rpc_m_unk_sock_type",
-    0x16c9a160L : "rpc_m_unimp_call",
-    0x16c9a161L : "rpc_m_invalid_seqnum",
-    0x16c9a162L : "rpc_m_cant_create_uuid",
-    0x16c9a163L : "rpc_m_pre_v2_ss",
-    0x16c9a164L : "rpc_m_dgpkt_pool_corrupt",
-    0x16c9a165L : "rpc_m_dgpkt_bad_free",
-    0x16c9a166L : "rpc_m_lookaside_corrupt",
-    0x16c9a167L : "rpc_m_alloc_fail",
-    0x16c9a168L : "rpc_m_realloc_fail",
-    0x16c9a169L : "rpc_m_cant_open_file",
-    0x16c9a16aL : "rpc_m_cant_read_addr",
-    0x16c9a16bL : "rpc_svc_desc_libidl",
-    0x16c9a16cL : "rpc_m_ctxrundown_nomem",
-    0x16c9a16dL : "rpc_m_ctxrundown_exc",
-    0x16c9a16eL : "rpc_s_fault_codeset_conv_error",
-    0x16c9a16fL : "rpc_s_no_call_active",
-    0x16c9a170L : "rpc_s_cannot_support",
-    0x16c9a171L : "rpc_s_no_context_available",
+    0x00000005 : 'rpc_s_access_denied',
+    0x00000008 : 'Authentication type not recognized',
+    0x000006D8 : 'rpc_fault_cant_perform', 
+    0x000006C6 : 'rpc_x_invalid_bound',                # the arrays bound are invalid
+    0x000006E4 : 'rpc_s_cannot_support: The requested operation is not supported.',               # some operation is not supported
+    0x000006F7 : 'rpc_x_bad_stub_data',                # the stub data is invalid, doesn't match with the IDL definition
+    0x1C010001 : 'nca_s_comm_failure',                 # unable to get response from server:
+    0x1C010002 : 'nca_s_op_rng_error',                 # bad operation number in call
+    0x1C010003 : 'nca_s_unk_if',                       # unknown interface
+    0x1C010006 : 'nca_s_wrong_boot_time',              # client passed server wrong server boot time
+    0x1C010009 : 'nca_s_you_crashed',                  # a restarted server called back a client
+    0x1C01000B : 'nca_s_proto_error',                  # someone messed up the protocol
+    0x1C010013 : 'nca_s_out_args_too_big ',            # output args too big
+    0x1C010014 : 'nca_s_server_too_busy',              # server is too busy to handle call
+    0x1C010015 : 'nca_s_fault_string_too_long',        # string argument longer than declared max len
+    0x1C010017 : 'nca_s_unsupported_type ',            # no implementation of generic operation for object
+    0x1C000001 : 'nca_s_fault_int_div_by_zero',
+    0x1C000002 : 'nca_s_fault_addr_error ',
+    0x1C000003 : 'nca_s_fault_fp_div_zero',
+    0x1C000004 : 'nca_s_fault_fp_underflow',
+    0x1C000005 : 'nca_s_fault_fp_overflow',
+    0x1C000006 : 'nca_s_fault_invalid_tag',
+    0x1C000007 : 'nca_s_fault_invalid_bound ',
+    0x1C000008 : 'nca_s_rpc_version_mismatch',
+    0x1C000009 : 'nca_s_unspec_reject ',
+    0x1C00000A : 'nca_s_bad_actid',
+    0x1C00000B : 'nca_s_who_are_you_failed',
+    0x1C00000C : 'nca_s_manager_not_entered ',
+    0x1C00000D : 'nca_s_fault_cancel',
+    0x1C00000E : 'nca_s_fault_ill_inst',
+    0x1C00000F : 'nca_s_fault_fp_error',
+    0x1C000010 : 'nca_s_fault_int_overflow',
+    0x1C000012 : 'nca_s_fault_unspec',
+    0x1C000013 : 'nca_s_fault_remote_comm_failure ',
+    0x1C000014 : 'nca_s_fault_pipe_empty ',
+    0x1C000015 : 'nca_s_fault_pipe_closed',
+    0x1C000016 : 'nca_s_fault_pipe_order ',
+    0x1C000017 : 'nca_s_fault_pipe_discipline',
+    0x1C000018 : 'nca_s_fault_pipe_comm_error',
+    0x1C000019 : 'nca_s_fault_pipe_memory',
+    0x1C00001A : 'nca_s_fault_context_mismatch ',
+    0x1C00001B : 'nca_s_fault_remote_no_memory ',
+    0x1C00001C : 'nca_s_invalid_pres_context_id',
+    0x1C00001D : 'nca_s_unsupported_authn_level',
+    0x1C00001F : 'nca_s_invalid_checksum ',
+    0x1C000020 : 'nca_s_invalid_crc',
+    0x1C000021 : 'nca_s_fault_user_defined',
+    0x1C000022 : 'nca_s_fault_tx_open_failed',
+    0x1C000023 : 'nca_s_fault_codeset_conv_error',
+    0x1C000024 : 'nca_s_fault_object_not_found ',
+    0x1C000025 : 'nca_s_fault_no_client_stub',
+    0x16c9a000 : "rpc_s_mod",
+    0x16c9a001 : "rpc_s_op_rng_error",
+    0x16c9a002 : "rpc_s_cant_create_socket",
+    0x16c9a003 : "rpc_s_cant_bind_socket",
+    0x16c9a004 : "rpc_s_not_in_call",
+    0x16c9a005 : "rpc_s_no_port",
+    0x16c9a006 : "rpc_s_wrong_boot_time",
+    0x16c9a007 : "rpc_s_too_many_sockets",
+    0x16c9a008 : "rpc_s_illegal_register",
+    0x16c9a009 : "rpc_s_cant_recv",
+    0x16c9a00a : "rpc_s_bad_pkt",
+    0x16c9a00b : "rpc_s_unbound_handle",
+    0x16c9a00c : "rpc_s_addr_in_use",
+    0x16c9a00d : "rpc_s_in_args_too_big",
+    0x16c9a00e : "rpc_s_string_too_long",
+    0x16c9a00f : "rpc_s_too_many_objects",
+    0x16c9a010 : "rpc_s_binding_has_no_auth",
+    0x16c9a011 : "rpc_s_unknown_authn_service",
+    0x16c9a012 : "rpc_s_no_memory",
+    0x16c9a013 : "rpc_s_cant_nmalloc",
+    0x16c9a014 : "rpc_s_call_faulted",
+    0x16c9a015 : "rpc_s_call_failed",
+    0x16c9a016 : "rpc_s_comm_failure",
+    0x16c9a017 : "rpc_s_rpcd_comm_failure",
+    0x16c9a018 : "rpc_s_illegal_family_rebind",
+    0x16c9a019 : "rpc_s_invalid_handle",
+    0x16c9a01a : "rpc_s_coding_error",
+    0x16c9a01b : "rpc_s_object_not_found",
+    0x16c9a01c : "rpc_s_cthread_not_found",
+    0x16c9a01d : "rpc_s_invalid_binding",
+    0x16c9a01e : "rpc_s_already_registered",
+    0x16c9a01f : "rpc_s_endpoint_not_found",
+    0x16c9a020 : "rpc_s_invalid_rpc_protseq",
+    0x16c9a021 : "rpc_s_desc_not_registered",
+    0x16c9a022 : "rpc_s_already_listening",
+    0x16c9a023 : "rpc_s_no_protseqs",
+    0x16c9a024 : "rpc_s_no_protseqs_registered",
+    0x16c9a025 : "rpc_s_no_bindings",
+    0x16c9a026 : "rpc_s_max_descs_exceeded",
+    0x16c9a027 : "rpc_s_no_interfaces",
+    0x16c9a028 : "rpc_s_invalid_timeout",
+    0x16c9a029 : "rpc_s_cant_inq_socket",
+    0x16c9a02a : "rpc_s_invalid_naf_id",
+    0x16c9a02b : "rpc_s_inval_net_addr",
+    0x16c9a02c : "rpc_s_unknown_if",
+    0x16c9a02d : "rpc_s_unsupported_type",
+    0x16c9a02e : "rpc_s_invalid_call_opt",
+    0x16c9a02f : "rpc_s_no_fault",
+    0x16c9a030 : "rpc_s_cancel_timeout",
+    0x16c9a031 : "rpc_s_call_cancelled",
+    0x16c9a032 : "rpc_s_invalid_call_handle",
+    0x16c9a033 : "rpc_s_cannot_alloc_assoc",
+    0x16c9a034 : "rpc_s_cannot_connect",
+    0x16c9a035 : "rpc_s_connection_aborted",
+    0x16c9a036 : "rpc_s_connection_closed",
+    0x16c9a037 : "rpc_s_cannot_accept",
+    0x16c9a038 : "rpc_s_assoc_grp_not_found",
+    0x16c9a039 : "rpc_s_stub_interface_error",
+    0x16c9a03a : "rpc_s_invalid_object",
+    0x16c9a03b : "rpc_s_invalid_type",
+    0x16c9a03c : "rpc_s_invalid_if_opnum",
+    0x16c9a03d : "rpc_s_different_server_instance",
+    0x16c9a03e : "rpc_s_protocol_error",
+    0x16c9a03f : "rpc_s_cant_recvmsg",
+    0x16c9a040 : "rpc_s_invalid_string_binding",
+    0x16c9a041 : "rpc_s_connect_timed_out",
+    0x16c9a042 : "rpc_s_connect_rejected",
+    0x16c9a043 : "rpc_s_network_unreachable",
+    0x16c9a044 : "rpc_s_connect_no_resources",
+    0x16c9a045 : "rpc_s_rem_network_shutdown",
+    0x16c9a046 : "rpc_s_too_many_rem_connects",
+    0x16c9a047 : "rpc_s_no_rem_endpoint",
+    0x16c9a048 : "rpc_s_rem_host_down",
+    0x16c9a049 : "rpc_s_host_unreachable",
+    0x16c9a04a : "rpc_s_access_control_info_inv",
+    0x16c9a04b : "rpc_s_loc_connect_aborted",
+    0x16c9a04c : "rpc_s_connect_closed_by_rem",
+    0x16c9a04d : "rpc_s_rem_host_crashed",
+    0x16c9a04e : "rpc_s_invalid_endpoint_format",
+    0x16c9a04f : "rpc_s_unknown_status_code",
+    0x16c9a050 : "rpc_s_unknown_mgr_type",
+    0x16c9a051 : "rpc_s_assoc_creation_failed",
+    0x16c9a052 : "rpc_s_assoc_grp_max_exceeded",
+    0x16c9a053 : "rpc_s_assoc_grp_alloc_failed",
+    0x16c9a054 : "rpc_s_sm_invalid_state",
+    0x16c9a055 : "rpc_s_assoc_req_rejected",
+    0x16c9a056 : "rpc_s_assoc_shutdown",
+    0x16c9a057 : "rpc_s_tsyntaxes_unsupported",
+    0x16c9a058 : "rpc_s_context_id_not_found",
+    0x16c9a059 : "rpc_s_cant_listen_socket",
+    0x16c9a05a : "rpc_s_no_addrs",
+    0x16c9a05b : "rpc_s_cant_getpeername",
+    0x16c9a05c : "rpc_s_cant_get_if_id",
+    0x16c9a05d : "rpc_s_protseq_not_supported",
+    0x16c9a05e : "rpc_s_call_orphaned",
+    0x16c9a05f : "rpc_s_who_are_you_failed",
+    0x16c9a060 : "rpc_s_unknown_reject",
+    0x16c9a061 : "rpc_s_type_already_registered",
+    0x16c9a062 : "rpc_s_stop_listening_disabled",
+    0x16c9a063 : "rpc_s_invalid_arg",
+    0x16c9a064 : "rpc_s_not_supported",
+    0x16c9a065 : "rpc_s_wrong_kind_of_binding",
+    0x16c9a066 : "rpc_s_authn_authz_mismatch",
+    0x16c9a067 : "rpc_s_call_queued",
+    0x16c9a068 : "rpc_s_cannot_set_nodelay",
+    0x16c9a069 : "rpc_s_not_rpc_tower",
+    0x16c9a06a : "rpc_s_invalid_rpc_protid",
+    0x16c9a06b : "rpc_s_invalid_rpc_floor",
+    0x16c9a06c : "rpc_s_call_timeout",
+    0x16c9a06d : "rpc_s_mgmt_op_disallowed",
+    0x16c9a06e : "rpc_s_manager_not_entered",
+    0x16c9a06f : "rpc_s_calls_too_large_for_wk_ep",
+    0x16c9a070 : "rpc_s_server_too_busy",
+    0x16c9a071 : "rpc_s_prot_version_mismatch",
+    0x16c9a072 : "rpc_s_rpc_prot_version_mismatch",
+    0x16c9a073 : "rpc_s_ss_no_import_cursor",
+    0x16c9a074 : "rpc_s_fault_addr_error",
+    0x16c9a075 : "rpc_s_fault_context_mismatch",
+    0x16c9a076 : "rpc_s_fault_fp_div_by_zero",
+    0x16c9a077 : "rpc_s_fault_fp_error",
+    0x16c9a078 : "rpc_s_fault_fp_overflow",
+    0x16c9a079 : "rpc_s_fault_fp_underflow",
+    0x16c9a07a : "rpc_s_fault_ill_inst",
+    0x16c9a07b : "rpc_s_fault_int_div_by_zero",
+    0x16c9a07c : "rpc_s_fault_int_overflow",
+    0x16c9a07d : "rpc_s_fault_invalid_bound",
+    0x16c9a07e : "rpc_s_fault_invalid_tag",
+    0x16c9a07f : "rpc_s_fault_pipe_closed",
+    0x16c9a080 : "rpc_s_fault_pipe_comm_error",
+    0x16c9a081 : "rpc_s_fault_pipe_discipline",
+    0x16c9a082 : "rpc_s_fault_pipe_empty",
+    0x16c9a083 : "rpc_s_fault_pipe_memory",
+    0x16c9a084 : "rpc_s_fault_pipe_order",
+    0x16c9a085 : "rpc_s_fault_remote_comm_failure",
+    0x16c9a086 : "rpc_s_fault_remote_no_memory",
+    0x16c9a087 : "rpc_s_fault_unspec",
+    0x16c9a088 : "uuid_s_bad_version",
+    0x16c9a089 : "uuid_s_socket_failure",
+    0x16c9a08a : "uuid_s_getconf_failure",
+    0x16c9a08b : "uuid_s_no_address",
+    0x16c9a08c : "uuid_s_overrun",
+    0x16c9a08d : "uuid_s_internal_error",
+    0x16c9a08e : "uuid_s_coding_error",
+    0x16c9a08f : "uuid_s_invalid_string_uuid",
+    0x16c9a090 : "uuid_s_no_memory",
+    0x16c9a091 : "rpc_s_no_more_entries",
+    0x16c9a092 : "rpc_s_unknown_ns_error",
+    0x16c9a093 : "rpc_s_name_service_unavailable",
+    0x16c9a094 : "rpc_s_incomplete_name",
+    0x16c9a095 : "rpc_s_group_not_found",
+    0x16c9a096 : "rpc_s_invalid_name_syntax",
+    0x16c9a097 : "rpc_s_no_more_members",
+    0x16c9a098 : "rpc_s_no_more_interfaces",
+    0x16c9a099 : "rpc_s_invalid_name_service",
+    0x16c9a09a : "rpc_s_no_name_mapping",
+    0x16c9a09b : "rpc_s_profile_not_found",
+    0x16c9a09c : "rpc_s_not_found",
+    0x16c9a09d : "rpc_s_no_updates",
+    0x16c9a09e : "rpc_s_update_failed",
+    0x16c9a09f : "rpc_s_no_match_exported",
+    0x16c9a0a0 : "rpc_s_entry_not_found",
+    0x16c9a0a1 : "rpc_s_invalid_inquiry_context",
+    0x16c9a0a2 : "rpc_s_interface_not_found",
+    0x16c9a0a3 : "rpc_s_group_member_not_found",
+    0x16c9a0a4 : "rpc_s_entry_already_exists",
+    0x16c9a0a5 : "rpc_s_nsinit_failure",
+    0x16c9a0a6 : "rpc_s_unsupported_name_syntax",
+    0x16c9a0a7 : "rpc_s_no_more_elements",
+    0x16c9a0a8 : "rpc_s_no_ns_permission",
+    0x16c9a0a9 : "rpc_s_invalid_inquiry_type",
+    0x16c9a0aa : "rpc_s_profile_element_not_found",
+    0x16c9a0ab : "rpc_s_profile_element_replaced",
+    0x16c9a0ac : "rpc_s_import_already_done",
+    0x16c9a0ad : "rpc_s_database_busy",
+    0x16c9a0ae : "rpc_s_invalid_import_context",
+    0x16c9a0af : "rpc_s_uuid_set_not_found",
+    0x16c9a0b0 : "rpc_s_uuid_member_not_found",
+    0x16c9a0b1 : "rpc_s_no_interfaces_exported",
+    0x16c9a0b2 : "rpc_s_tower_set_not_found",
+    0x16c9a0b3 : "rpc_s_tower_member_not_found",
+    0x16c9a0b4 : "rpc_s_obj_uuid_not_found",
+    0x16c9a0b5 : "rpc_s_no_more_bindings",
+    0x16c9a0b6 : "rpc_s_invalid_priority",
+    0x16c9a0b7 : "rpc_s_not_rpc_entry",
+    0x16c9a0b8 : "rpc_s_invalid_lookup_context",
+    0x16c9a0b9 : "rpc_s_binding_vector_full",
+    0x16c9a0ba : "rpc_s_cycle_detected",
+    0x16c9a0bb : "rpc_s_nothing_to_export",
+    0x16c9a0bc : "rpc_s_nothing_to_unexport",
+    0x16c9a0bd : "rpc_s_invalid_vers_option",
+    0x16c9a0be : "rpc_s_no_rpc_data",
+    0x16c9a0bf : "rpc_s_mbr_picked",
+    0x16c9a0c0 : "rpc_s_not_all_objs_unexported",
+    0x16c9a0c1 : "rpc_s_no_entry_name",
+    0x16c9a0c2 : "rpc_s_priority_group_done",
+    0x16c9a0c3 : "rpc_s_partial_results",
+    0x16c9a0c4 : "rpc_s_no_env_setup",
+    0x16c9a0c5 : "twr_s_unknown_sa",
+    0x16c9a0c6 : "twr_s_unknown_tower",
+    0x16c9a0c7 : "twr_s_not_implemented",
+    0x16c9a0c8 : "rpc_s_max_calls_too_small",
+    0x16c9a0c9 : "rpc_s_cthread_create_failed",
+    0x16c9a0ca : "rpc_s_cthread_pool_exists",
+    0x16c9a0cb : "rpc_s_cthread_no_such_pool",
+    0x16c9a0cc : "rpc_s_cthread_invoke_disabled",
+    0x16c9a0cd : "ept_s_cant_perform_op",
+    0x16c9a0ce : "ept_s_no_memory",
+    0x16c9a0cf : "ept_s_database_invalid",
+    0x16c9a0d0 : "ept_s_cant_create",
+    0x16c9a0d1 : "ept_s_cant_access",
+    0x16c9a0d2 : "ept_s_database_already_open",
+    0x16c9a0d3 : "ept_s_invalid_entry",
+    0x16c9a0d4 : "ept_s_update_failed",
+    0x16c9a0d5 : "ept_s_invalid_context",
+    0x16c9a0d6 : "ept_s_not_registered",
+    0x16c9a0d7 : "ept_s_server_unavailable",
+    0x16c9a0d8 : "rpc_s_underspecified_name",
+    0x16c9a0d9 : "rpc_s_invalid_ns_handle",
+    0x16c9a0da : "rpc_s_unknown_error",
+    0x16c9a0db : "rpc_s_ss_char_trans_open_fail",
+    0x16c9a0dc : "rpc_s_ss_char_trans_short_file",
+    0x16c9a0dd : "rpc_s_ss_context_damaged",
+    0x16c9a0de : "rpc_s_ss_in_null_context",
+    0x16c9a0df : "rpc_s_socket_failure",
+    0x16c9a0e0 : "rpc_s_unsupported_protect_level",
+    0x16c9a0e1 : "rpc_s_invalid_checksum",
+    0x16c9a0e2 : "rpc_s_invalid_credentials",
+    0x16c9a0e3 : "rpc_s_credentials_too_large",
+    0x16c9a0e4 : "rpc_s_call_id_not_found",
+    0x16c9a0e5 : "rpc_s_key_id_not_found",
+    0x16c9a0e6 : "rpc_s_auth_bad_integrity",
+    0x16c9a0e7 : "rpc_s_auth_tkt_expired",
+    0x16c9a0e8 : "rpc_s_auth_tkt_nyv",
+    0x16c9a0e9 : "rpc_s_auth_repeat",
+    0x16c9a0ea : "rpc_s_auth_not_us",
+    0x16c9a0eb : "rpc_s_auth_badmatch",
+    0x16c9a0ec : "rpc_s_auth_skew",
+    0x16c9a0ed : "rpc_s_auth_badaddr",
+    0x16c9a0ee : "rpc_s_auth_badversion",
+    0x16c9a0ef : "rpc_s_auth_msg_type",
+    0x16c9a0f0 : "rpc_s_auth_modified",
+    0x16c9a0f1 : "rpc_s_auth_badorder",
+    0x16c9a0f2 : "rpc_s_auth_badkeyver",
+    0x16c9a0f3 : "rpc_s_auth_nokey",
+    0x16c9a0f4 : "rpc_s_auth_mut_fail",
+    0x16c9a0f5 : "rpc_s_auth_baddirection",
+    0x16c9a0f6 : "rpc_s_auth_method",
+    0x16c9a0f7 : "rpc_s_auth_badseq",
+    0x16c9a0f8 : "rpc_s_auth_inapp_cksum",
+    0x16c9a0f9 : "rpc_s_auth_field_toolong",
+    0x16c9a0fa : "rpc_s_invalid_crc",
+    0x16c9a0fb : "rpc_s_binding_incomplete",
+    0x16c9a0fc : "rpc_s_key_func_not_allowed",
+    0x16c9a0fd : "rpc_s_unknown_stub_rtl_if_vers",
+    0x16c9a0fe : "rpc_s_unknown_ifspec_vers",
+    0x16c9a0ff : "rpc_s_proto_unsupp_by_auth",
+    0x16c9a100 : "rpc_s_authn_challenge_malformed",
+    0x16c9a101 : "rpc_s_protect_level_mismatch",
+    0x16c9a102 : "rpc_s_no_mepv",
+    0x16c9a103 : "rpc_s_stub_protocol_error",
+    0x16c9a104 : "rpc_s_class_version_mismatch",
+    0x16c9a105 : "rpc_s_helper_not_running",
+    0x16c9a106 : "rpc_s_helper_short_read",
+    0x16c9a107 : "rpc_s_helper_catatonic",
+    0x16c9a108 : "rpc_s_helper_aborted",
+    0x16c9a109 : "rpc_s_not_in_kernel",
+    0x16c9a10a : "rpc_s_helper_wrong_user",
+    0x16c9a10b : "rpc_s_helper_overflow",
+    0x16c9a10c : "rpc_s_dg_need_way_auth",
+    0x16c9a10d : "rpc_s_unsupported_auth_subtype",
+    0x16c9a10e : "rpc_s_wrong_pickle_type",
+    0x16c9a10f : "rpc_s_not_listening",
+    0x16c9a110 : "rpc_s_ss_bad_buffer",
+    0x16c9a111 : "rpc_s_ss_bad_es_action",
+    0x16c9a112 : "rpc_s_ss_wrong_es_version",
+    0x16c9a113 : "rpc_s_fault_user_defined",
+    0x16c9a114 : "rpc_s_ss_incompatible_codesets",
+    0x16c9a115 : "rpc_s_tx_not_in_transaction",
+    0x16c9a116 : "rpc_s_tx_open_failed",
+    0x16c9a117 : "rpc_s_partial_credentials",
+    0x16c9a118 : "rpc_s_ss_invalid_codeset_tag",
+    0x16c9a119 : "rpc_s_mgmt_bad_type",
+    0x16c9a11a : "rpc_s_ss_invalid_char_input",
+    0x16c9a11b : "rpc_s_ss_short_conv_buffer",
+    0x16c9a11c : "rpc_s_ss_iconv_error",
+    0x16c9a11d : "rpc_s_ss_no_compat_codeset",
+    0x16c9a11e : "rpc_s_ss_no_compat_charsets",
+    0x16c9a11f : "dce_cs_c_ok",
+    0x16c9a120 : "dce_cs_c_unknown",
+    0x16c9a121 : "dce_cs_c_notfound",
+    0x16c9a122 : "dce_cs_c_cannot_open_file",
+    0x16c9a123 : "dce_cs_c_cannot_read_file",
+    0x16c9a124 : "dce_cs_c_cannot_allocate_memory",
+    0x16c9a125 : "rpc_s_ss_cleanup_failed",
+    0x16c9a126 : "rpc_svc_desc_general",
+    0x16c9a127 : "rpc_svc_desc_mutex",
+    0x16c9a128 : "rpc_svc_desc_xmit",
+    0x16c9a129 : "rpc_svc_desc_recv",
+    0x16c9a12a : "rpc_svc_desc_dg_state",
+    0x16c9a12b : "rpc_svc_desc_cancel",
+    0x16c9a12c : "rpc_svc_desc_orphan",
+    0x16c9a12d : "rpc_svc_desc_cn_state",
+    0x16c9a12e : "rpc_svc_desc_cn_pkt",
+    0x16c9a12f : "rpc_svc_desc_pkt_quotas",
+    0x16c9a130 : "rpc_svc_desc_auth",
+    0x16c9a131 : "rpc_svc_desc_source",
+    0x16c9a132 : "rpc_svc_desc_stats",
+    0x16c9a133 : "rpc_svc_desc_mem",
+    0x16c9a134 : "rpc_svc_desc_mem_type",
+    0x16c9a135 : "rpc_svc_desc_dg_pktlog",
+    0x16c9a136 : "rpc_svc_desc_thread_id",
+    0x16c9a137 : "rpc_svc_desc_timestamp",
+    0x16c9a138 : "rpc_svc_desc_cn_errors",
+    0x16c9a139 : "rpc_svc_desc_conv_thread",
+    0x16c9a13a : "rpc_svc_desc_pid",
+    0x16c9a13b : "rpc_svc_desc_atfork",
+    0x16c9a13c : "rpc_svc_desc_cma_thread",
+    0x16c9a13d : "rpc_svc_desc_inherit",
+    0x16c9a13e : "rpc_svc_desc_dg_sockets",
+    0x16c9a13f : "rpc_svc_desc_timer",
+    0x16c9a140 : "rpc_svc_desc_threads",
+    0x16c9a141 : "rpc_svc_desc_server_call",
+    0x16c9a142 : "rpc_svc_desc_nsi",
+    0x16c9a143 : "rpc_svc_desc_dg_pkt",
+    0x16c9a144 : "rpc_m_cn_ill_state_trans_sa",
+    0x16c9a145 : "rpc_m_cn_ill_state_trans_ca",
+    0x16c9a146 : "rpc_m_cn_ill_state_trans_sg",
+    0x16c9a147 : "rpc_m_cn_ill_state_trans_cg",
+    0x16c9a148 : "rpc_m_cn_ill_state_trans_sr",
+    0x16c9a149 : "rpc_m_cn_ill_state_trans_cr",
+    0x16c9a14a : "rpc_m_bad_pkt_type",
+    0x16c9a14b : "rpc_m_prot_mismatch",
+    0x16c9a14c : "rpc_m_frag_toobig",
+    0x16c9a14d : "rpc_m_unsupp_stub_rtl_if",
+    0x16c9a14e : "rpc_m_unhandled_callstate",
+    0x16c9a14f : "rpc_m_call_failed",
+    0x16c9a150 : "rpc_m_call_failed_no_status",
+    0x16c9a151 : "rpc_m_call_failed_errno",
+    0x16c9a152 : "rpc_m_call_failed_s",
+    0x16c9a153 : "rpc_m_call_failed_c",
+    0x16c9a154 : "rpc_m_errmsg_toobig",
+    0x16c9a155 : "rpc_m_invalid_srchattr",
+    0x16c9a156 : "rpc_m_nts_not_found",
+    0x16c9a157 : "rpc_m_invalid_accbytcnt",
+    0x16c9a158 : "rpc_m_pre_v2_ifspec",
+    0x16c9a159 : "rpc_m_unk_ifspec",
+    0x16c9a15a : "rpc_m_recvbuf_toosmall",
+    0x16c9a15b : "rpc_m_unalign_authtrl",
+    0x16c9a15c : "rpc_m_unexpected_exc",
+    0x16c9a15d : "rpc_m_no_stub_data",
+    0x16c9a15e : "rpc_m_eventlist_full",
+    0x16c9a15f : "rpc_m_unk_sock_type",
+    0x16c9a160 : "rpc_m_unimp_call",
+    0x16c9a161 : "rpc_m_invalid_seqnum",
+    0x16c9a162 : "rpc_m_cant_create_uuid",
+    0x16c9a163 : "rpc_m_pre_v2_ss",
+    0x16c9a164 : "rpc_m_dgpkt_pool_corrupt",
+    0x16c9a165 : "rpc_m_dgpkt_bad_free",
+    0x16c9a166 : "rpc_m_lookaside_corrupt",
+    0x16c9a167 : "rpc_m_alloc_fail",
+    0x16c9a168 : "rpc_m_realloc_fail",
+    0x16c9a169 : "rpc_m_cant_open_file",
+    0x16c9a16a : "rpc_m_cant_read_addr",
+    0x16c9a16b : "rpc_svc_desc_libidl",
+    0x16c9a16c : "rpc_m_ctxrundown_nomem",
+    0x16c9a16d : "rpc_m_ctxrundown_exc",
+    0x16c9a16e : "rpc_s_fault_codeset_conv_error",
+    0x16c9a16f : "rpc_s_no_call_active",
+    0x16c9a170 : "rpc_s_cannot_support",
+    0x16c9a171 : "rpc_s_no_context_available",
 }
 
 class DCERPCException(Exception):
@@ -575,7 +575,7 @@ class DCERPCException(Exception):
         key = self.error_code
         if self.error_string is not None:
             return self.error_string
-        if rpc_status_codes.has_key(key):
+        if key in rpc_status_codes:
             error_msg_short = rpc_status_codes[key]
             return 'DCERPC Runtime Error: code: 0x%x - %s ' % (self.error_code, error_msg_short)
         else:
@@ -816,9 +816,9 @@ class DCERPC:
         # default is 0: don'fragment. v4 will override this method
         self._max_user_frag = 0
 
-    def send(self, data): raise RuntimeError, 'virtual method. Not implemented in subclass'
-    def recv(self): raise RuntimeError, 'virtual method. Not implemented in subclass'
-    def alter_ctx(self, newUID, bogus_binds = ''): raise RuntimeError, 'virtual method. Not implemented in subclass'
+    def send(self, data): raise RuntimeError('virtual method. Not implemented in subclass')
+    def recv(self): raise RuntimeError('virtual method. Not implemented in subclass')
+    def alter_ctx(self, newUID, bogus_binds = ''): raise RuntimeError('virtual method. Not implemented in subclass')
     def set_credentials(self, username, password, domain = '', lmhash = '', nthash = '', aesKey = '', TGT=None, TGS=None): pass
     def set_auth_level(self, auth_level): pass
     def set_auth_type(self, auth_type, callback = None): pass
@@ -842,7 +842,7 @@ class DCERPC:
 
         if  answer[-4:] != '\x00\x00\x00\x00' and checkError is True:
             error_code = unpack('<L', answer[-4:])[0]
-            if rpc_status_codes.has_key(error_code):
+            if error_code in rpc_status_codes:
                 # This is an error we can handle
                 exception = DCERPCException(error_code = error_code)
             else:    
@@ -1022,9 +1022,9 @@ class DCERPC_v5(DCERPC):
             else:
                 resp = MSRPCBindNak(resp['pduData'])
                 status_code = resp['RejectedReason']
-            if rpc_status_codes.has_key(status_code):
+            if status_code in rpc_status_codes:
                 raise DCERPCException(error_code = status_code)
-            elif rpc_provider_reason.has_key(status_code):
+            elif status_code in rpc_provider_reason:
                 raise DCERPCException("Bind context rejected: %s" % rpc_provider_reason[status_code])
             else:
                 raise DCERPCException('Unknown DCE RPC fault status code: %.8x' % status_code)
@@ -1295,12 +1295,12 @@ class DCERPC_v5(DCERPC):
 
             if response_header['type'] == MSRPC_FAULT and response_header['frag_len'] >= off+4:
                 status_code = unpack("<L",response_data[off:off+4])[0]
-                if rpc_status_codes.has_key(status_code):
+                if status_code in rpc_status_codes:
                     raise DCERPCException(rpc_status_codes[status_code])
-                elif rpc_status_codes.has_key(status_code & 0xffff):
+                elif status_code & 0xffff in rpc_status_codes:
                     raise DCERPCException(rpc_status_codes[status_code & 0xffff])
                 else:
-                    if hresult_errors.ERROR_MESSAGES.has_key(status_code):
+                    if status_code in hresult_errors.ERROR_MESSAGES:
                         error_msg_short = hresult_errors.ERROR_MESSAGES[status_code][0]
                         error_msg_verbose = hresult_errors.ERROR_MESSAGES[status_code][1] 
                         raise DCERPCException('%s - %s' % (error_msg_short, error_msg_verbose))
@@ -1647,14 +1647,14 @@ class DCERPCServer(Thread):
             response         = MSRPCRespHeader(data)
             response['type'] = MSRPC_RESPONSE
             # Serve the opnum requested, if not, fails
-            if self._listenUUIDS[self._boundUUID]['CallBacks'].has_key(request['op_num']):
+            if request['op_num'] in self._listenUUIDS[self._boundUUID]['CallBacks']:
                 # Call the function 
                 returnData          = self._listenUUIDS[self._boundUUID]['CallBacks'][request['op_num']](request['pduData'])
                 response['pduData'] = returnData
             else:
                 LOG.error('Unsupported DCERPC opnum %d called for interface %s' % (request['op_num'], bin_to_uuidtup(self._boundUUID)))
                 response['type']    = MSRPC_FAULT
-                response['pduData'] = pack('<L',0x000006E4L)
+                response['pduData'] = pack('<L',0x000006E4)
             response['frag_len'] = len(response)
             return response
         else:
--- impacket/dcerpc/v5/rrp.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/rrp.py
@@ -35,7 +35,7 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__( self ):
         key = self.error_code
-        if system_errors.ERROR_MESSAGES.has_key(key):
+        if key in system_errors.ERROR_MESSAGES:
             error_msg_short = system_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] 
             return 'RRP SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -813,7 +813,7 @@ def hBaseRegEnumValue(dce, hKey, dwIndex, dataLen=256)
             request['lpcbData'] = dataLen
             request['lpcbLen'] = dataLen
             resp = dce.request(request)
-        except DCERPCSessionError, e:
+        except DCERPCSessionError as e:
             if retries > 1:
                 LOG.debug('Too many retries when calling hBaseRegEnumValue, aborting')
                 raise
@@ -886,7 +886,7 @@ def hBaseRegQueryValue(dce, hKey, lpValueName, dataLen
             request['lpcbData'] = dataLen
             request['lpcbLen'] = dataLen
             resp = dce.request(request)
-        except DCERPCSessionError, e:
+        except DCERPCSessionError as e:
             if retries > 1:
                 LOG.debug('Too many retries when calling hBaseRegQueryValue, aborting')
                 raise
--- impacket/dcerpc/v5/samr.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/samr.py
@@ -38,7 +38,7 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__( self ):
         key = self.error_code
-        if nt_errors.ERROR_MESSAGES.has_key(key):
+        if key in nt_errors.ERROR_MESSAGES:
             error_msg_short = nt_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = nt_errors.ERROR_MESSAGES[key][1] 
             return 'SAMR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -300,9 +300,9 @@ class RPC_STRING(NDRSTRUCT):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print "%s" % msg,
+            print("%s" % msg, end=' ')
         # Here just print the data
-        print " %r" % (self['Data']),
+        print(" %r" % (self['Data']), end=' ')
 
 class PRPC_STRING(NDRPOINTER):
     referent = (
--- impacket/dcerpc/v5/scmr.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/scmr.py
@@ -35,7 +35,7 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__( self ):
         key = self.error_code
-        if system_errors.ERROR_MESSAGES.has_key(key):
+        if key in system_errors.ERROR_MESSAGES:
             error_msg_short = system_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] 
             return 'SCMR SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -1282,7 +1282,7 @@ def hREnumServicesStatusW(dce, hSCManager, dwServiceTy
 
     try:
         resp = dce.request(enumServicesStatus)
-    except DCERPCSessionError, e:
+    except DCERPCSessionError as e:
         if e.get_error_code() == system_errors.ERROR_MORE_DATA:
             resp = e.get_packet()
             enumServicesStatus['cbBufSize'] = resp['pcbBytesNeeded']
@@ -1332,7 +1332,7 @@ def hRQueryServiceConfigW(dce, hService):
     queryService['cbBufSize'] = 0
     try:
         resp = dce.request(queryService)
-    except DCERPCSessionError, e:
+    except DCERPCSessionError as e:
         if e.get_error_code() == system_errors.ERROR_INSUFFICIENT_BUFFER:
             resp = e.get_packet()
             queryService['cbBufSize'] = resp['pcbBytesNeeded']
--- impacket/dcerpc/v5/srvs.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/srvs.py
@@ -34,7 +34,7 @@ class DCERPCSessionError(DCERPCException):
 
     def __str__( self ):
         key = self.error_code
-        if system_errors.ERROR_MESSAGES.has_key(key):
+        if key in system_errors.ERROR_MESSAGES:
             error_msg_short = system_errors.ERROR_MESSAGES[key][0]
             error_msg_verbose = system_errors.ERROR_MESSAGES[key][1] 
             return 'SRVS SessionError: code: 0x%x - %s - %s' % (self.error_code, error_msg_short, error_msg_verbose)
@@ -1753,9 +1753,9 @@ class WCHAR_ARRAY(NDRSTRUCT):
     def dump(self, msg = None, indent = 0):
         if msg is None: msg = self.__class__.__name__
         if msg != '':
-            print "%s" % msg,
+            print("%s" % msg, end=' ')
         # Here just print the data
-        print " %r" % (self['Data']),
+        print(" %r" % (self['Data']), end=' ')
 
     def __setitem__(self, key, value):
         if key == 'Data':
--- impacket/dcerpc/v5/transport.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dcerpc/v5/transport.py
@@ -138,15 +138,15 @@ class DCERPCTransport:
         self.set_credentials('','')
 
     def connect(self):
-        raise RuntimeError, 'virtual function'
+        raise RuntimeError('virtual function')
     def send(self,data=0, forceWriteAndx = 0, forceRecv = 0):
-        raise RuntimeError, 'virtual function'
+        raise RuntimeError('virtual function')
     def recv(self, forceRecv = 0, count = 0):
-        raise RuntimeError, 'virtual function'
+        raise RuntimeError('virtual function')
     def disconnect(self):
-        raise RuntimeError, 'virtual function'
+        raise RuntimeError('virtual function')
     def get_socket(self):
-        raise RuntimeError, 'virtual function'
+        raise RuntimeError('virtual function')
 
     def get_connect_timeout(self):
         return self.__connect_timeout
@@ -256,7 +256,7 @@ class UDPTransport(DCERPCTransport):
             af, socktype, proto, canonname, sa = socket.getaddrinfo(self.getRemoteHost(), self.get_dport(), 0, socket.SOCK_DGRAM)[0]
             self.__socket = socket.socket(af, socktype, proto)
             self.__socket.settimeout(self.get_connect_timeout())
-        except socket.error, msg:
+        except socket.error as msg:
             self.__socket = None
             raise DCERPCException("Could not connect: %s" % msg)
 
@@ -297,7 +297,7 @@ class TCPTransport(DCERPCTransport):
         try:
             self.__socket.settimeout(self.get_connect_timeout())
             self.__socket.connect(sa)
-        except socket.error, msg:
+        except socket.error as msg:
             self.__socket.close()
             raise DCERPCException("Could not connect: %s" % msg)
         return 1
@@ -305,7 +305,7 @@ class TCPTransport(DCERPCTransport):
     def disconnect(self):
         try:
             self.__socket.close()
-        except socket.error, msg:
+        except socket.error as msg:
             self.__socket = None
             return 0
         return 1
--- impacket/dns.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dns.py
@@ -31,7 +31,7 @@
 import socket
 import struct
 
-from ImpactPacket import ProtocolPacket
+from .ImpactPacket import ProtocolPacket
 
 
 class DNSFlags():
@@ -152,7 +152,7 @@ class DNSType():
     
     @staticmethod
     def getTypeName(type):
-        for item, value in DNSType.__dict__.items():
+        for item, value in list(DNSType.__dict__.items()):
             if value == type:
                 return item
     
@@ -168,7 +168,7 @@ class DNSClass():
     
     @staticmethod
     def getClassName(type):
-        for item, value in DNSClass.__dict__.items():
+        for item, value in list(DNSClass.__dict__.items()):
             if value == type:
                 return item
 
@@ -613,4 +613,4 @@ if __name__ == "__main__":
     
     for pkt in pkts:
         d = DNS(pkt)
-        print d
+        print(d)
--- impacket/dot11.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/dot11.py
@@ -14,8 +14,8 @@ import struct
 import string
 from binascii import crc32
 
-from ImpactPacket import ProtocolPacket
-from Dot11Crypto import RC4
+from .ImpactPacket import ProtocolPacket
+from .Dot11Crypto import RC4
 
 frequency = {
     2412: 1,    2417: 2,    2422: 3,    2427: 4,    2432: 5,    2437: 6,    2442: 7,    2447: 8,    2452: 9,
@@ -467,7 +467,7 @@ class Dot11(ProtocolPacket):    
         self.header.set_byte(0, nb)
         
     def compute_checksum(self,bytes):
-        crcle=crc32(bytes)&0xffffffffL
+        crcle=crc32(bytes)&0xffffffff
         # ggrr this crc32 is in little endian, convert it to big endian 
         crc=struct.pack('<L', crcle)
          # Convert to long
@@ -1125,7 +1125,7 @@ class Dot11WEPData(ProtocolPacket):
         self.tail.set_long(-4, nb)
     
     def get_computed_icv(self):
-        crcle=crc32(self.body_string)&0xffffffffL
+        crcle=crc32(self.body_string)&0xffffffff
         # This crc32 is in little endian, convert it to big endian 
         crc=struct.pack('<L', crcle)
          # Convert to long
@@ -2224,7 +2224,7 @@ class Dot11ManagementHelper(ProtocolPacket):
 
     def __calculate_elements_length(self, elements):
         gen_tp=self._find_element(elements, None )
-        (match,offset,length)=gen_tp.next()
+        (match,offset,length)=next(gen_tp)
         if match != -1:
             # element_id is None, then __find_tagged_parameter must return -1
             raise Exception("Internal Error %s"%match)
@@ -2234,7 +2234,7 @@ class Dot11ManagementHelper(ProtocolPacket):
         elements=self.get_header_as_string()[self.__HEADER_BASE_SIZE:]
         gen_tp=self._find_element(elements, element_id )
         while True:
-            (match,offset,length)=gen_tp.next()
+            (match,offset,length)=next(gen_tp)
             if match != 0:
                 return
             value_offset=offset+2
@@ -2245,7 +2245,7 @@ class Dot11ManagementHelper(ProtocolPacket):
     def _get_element(self, element_id):
         gen_get_element=self._get_elements_generator(element_id)
         try:
-            s=gen_get_element.next()
+            s=next(gen_get_element)
             
             if s is None:
                 raise Exception("gen_get_element salio con None in _get_element!!!")
@@ -2262,7 +2262,7 @@ class Dot11ManagementHelper(ProtocolPacket):
         gen_tp=self._find_element(elements, element_id )
         found=False
         while True:
-            (match,offset,length)=gen_tp.next()
+            (match,offset,length)=next(gen_tp)
             if match != 0:
                 break
             start=self.__HEADER_BASE_SIZE+offset
@@ -2285,7 +2285,7 @@ class Dot11ManagementHelper(ProtocolPacket):
         gen_tp=self._find_element(elements, element_id )
         found=False
         while True:
-            (match,offset,length)=gen_tp.next()
+            (match,offset,length)=next(gen_tp)
             start=self.__HEADER_BASE_SIZE+offset
             if match == 0 and replace:
                 # Replace
@@ -2371,7 +2371,7 @@ class Dot11ManagementBeacon(Dot11ManagementHelper):
         if not human_readable:
             return rates
             
-        rates_Mbs=tuple(map(lambda x: (x&0x7F)*0.5,rates))
+        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])
         return rates_Mbs
 
     def set_supported_rates(self, rates):
@@ -2466,7 +2466,7 @@ class Dot11ManagementBeacon(Dot11ManagementHelper):
         gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)
         try:
             while 1:
-                s=gen_get_element.next()
+                s=next(gen_get_element)
                 
                 if s is None:
                     raise Exception("gen_get_element salio con None!!!")
@@ -2526,7 +2526,7 @@ class Dot11ManagementProbeRequest(Dot11ManagementHelpe
         if not human_readable:
             return rates
             
-        rates_Mbs=tuple(map(lambda x: (x&0x7F)*0.5,rates))
+        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])
         return rates_Mbs
 
     def set_supported_rates(self, rates):
@@ -2702,7 +2702,7 @@ class Dot11ManagementAuthentication(Dot11ManagementHel
         gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)
         try:
             while 1:
-                s=gen_get_element.next()
+                s=next(gen_get_element)
                 
                 if s is None:
                     raise Exception("gen_get_element salio con None!!!")
@@ -2790,7 +2790,7 @@ class Dot11ManagementAssociationRequest(Dot11Managemen
         if not human_readable:
             return rates
             
-        rates_Mbs=tuple(map(lambda x: (x&0x7F)*0.5,rates))
+        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])
         return rates_Mbs
 
     def set_supported_rates(self, rates):
@@ -2826,7 +2826,7 @@ class Dot11ManagementAssociationRequest(Dot11Managemen
         gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)
         try:
             while 1:
-                s=gen_get_element.next()
+                s=next(gen_get_element)
                 
                 if s is None:
                     raise Exception("gen_get_element salio con None!!!")
@@ -2909,7 +2909,7 @@ class Dot11ManagementAssociationResponse(Dot11Manageme
         if not human_readable:
             return rates
             
-        rates_Mbs=tuple(map(lambda x: (x&0x7F)*0.5,rates))
+        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])
         return rates_Mbs
 
     def set_supported_rates(self, rates):
@@ -2934,7 +2934,7 @@ class Dot11ManagementAssociationResponse(Dot11Manageme
         gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)
         try:
             while 1:
-                s=gen_get_element.next()
+                s=next(gen_get_element)
                 
                 if s is None:
                     raise Exception("gen_get_element salio con None!!!")
@@ -3024,7 +3024,7 @@ class Dot11ManagementReassociationRequest(Dot11Managem
         if not human_readable:
             return rates
             
-        rates_Mbs=tuple(map(lambda x: (x&0x7F)*0.5,rates))
+        rates_Mbs=tuple([(x&0x7F)*0.5 for x in rates])
         return rates_Mbs
 
     def set_supported_rates(self, rates):
@@ -3060,7 +3060,7 @@ class Dot11ManagementReassociationRequest(Dot11Managem
         gen_get_element=self._get_elements_generator(DOT11_MANAGEMENT_ELEMENTS.VENDOR_SPECIFIC)
         try:
             while 1:
-                s=gen_get_element.next()
+                s=next(gen_get_element)
                 
                 if s is None:
                     raise Exception("gen_get_element salio con None!!!")
--- impacket/ese.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/ese.py
@@ -435,17 +435,17 @@ def hexdump(data):
     strLen = len(x)
     i = 0
     while i < strLen:
-        print "%04x  " % i,
+        print("%04x  " % i, end=' ')
         for j in range(16):
             if i+j < strLen:
-                print "%02X" % ord(x[i+j]),
+                print("%02X" % ord(x[i+j]), end=' ')
 
             else:
-                print "  ",
+                print("  ", end=' ')
             if j%16 == 7:
-                print "",
-        print " ",
-        print ''.join(pretty_print(x) for x in x[i:i+16] )
+                print("", end=' ')
+        print(" ", end=' ')
+        print(''.join(pretty_print(x) for x in x[i:i+16] ))
         i += 16
 
 def getUnixTime(t):
@@ -464,35 +464,35 @@ class ESENT_PAGE:
     def printFlags(self):
         flags = self.record['PageFlags']
         if flags & FLAGS_EMPTY:
-            print "\tEmpty"
+            print("\tEmpty")
         if flags & FLAGS_INDEX:
-            print "\tIndex"
+            print("\tIndex")
         if flags & FLAGS_LEAF:
-            print "\tLeaf"
+            print("\tLeaf")
         else:
-            print "\tBranch"
+            print("\tBranch")
         if flags & FLAGS_LONG_VALUE:
-            print "\tLong Value"
+            print("\tLong Value")
         if flags & FLAGS_NEW_CHECKSUM:
-            print "\tNew Checksum"
+            print("\tNew Checksum")
         if flags & FLAGS_NEW_FORMAT:
-            print "\tNew Format"
+            print("\tNew Format")
         if flags & FLAGS_PARENT:
-            print "\tParent"
+            print("\tParent")
         if flags & FLAGS_ROOT:
-            print "\tRoot"
+            print("\tRoot")
         if flags & FLAGS_SPACE_TREE:
-            print "\tSpace Tree"
+            print("\tSpace Tree")
 
     def dump(self):
         baseOffset = len(self.record)
         self.record.dump()
         tags = self.data[-4*self.record['FirstAvailablePageTag']:]
 
-        print "FLAGS: "
+        print("FLAGS: ")
         self.printFlags()
 
-        print
+        print()
 
         for i in range(self.record['FirstAvailablePageTag']):
             tag = tags[-4:]
@@ -508,7 +508,7 @@ class ESENT_PAGE:
                 pageFlags = (unpack('<H', tag[2:])[0] & 0xe000) >> 13
                 valueOffset = unpack('<H',tag[2:])[0] & 0x1fff
                 
-            print "TAG %-8d offset:0x%-6x flags:0x%-4x valueSize:0x%x" % (i,valueOffset,pageFlags,valueSize)
+            print("TAG %-8d offset:0x%-6x flags:0x%-4x valueSize:0x%x" % (i,valueOffset,pageFlags,valueSize))
             #hexdump(self.getTag(i)[1])
             tags = tags[:-4]
 
@@ -620,21 +620,21 @@ class ESENT_DB:
     def printCatalog(self):
         indent = '    '
 
-        print "Database version: 0x%x, 0x%x" % (self.__DBHeader['Version'], self.__DBHeader['FileFormatRevision'] )
-        print "Page size: %d " % self.__pageSize
-        print "Number of pages: %d" % self.__totalPages
-        print 
-        print "Catalog for %s" % self.__fileName
-        for table in self.__tables.keys():
-            print "[%s]" % table
-            print "%sColumns " % indent
-            for column in self.__tables[table]['Columns'].keys():
+        print("Database version: 0x%x, 0x%x" % (self.__DBHeader['Version'], self.__DBHeader['FileFormatRevision'] ))
+        print("Page size: %d " % self.__pageSize)
+        print("Number of pages: %d" % self.__totalPages)
+        print() 
+        print("Catalog for %s" % self.__fileName)
+        for table in list(self.__tables.keys()):
+            print("[%s]" % table)
+            print("%sColumns " % indent)
+            for column in list(self.__tables[table]['Columns'].keys()):
                 record = self.__tables[table]['Columns'][column]['Record']
-                print "%s%-5d%-30s%s" % (indent*2, record['Identifier'], column,ColumnTypeToName[record['ColumnType']])
-            print "%sIndexes"% indent
-            for index in self.__tables[table]['Indexes'].keys():
-                print "%s%s" % (indent*2, index)
-            print ""
+                print("%s%-5d%-30s%s" % (indent*2, record['Identifier'], column,ColumnTypeToName[record['ColumnType']]))
+            print("%sIndexes"% indent)
+            for index in list(self.__tables[table]['Indexes'].keys()):
+                print("%s%s" % (indent*2, index))
+            print("")
 
     def __addItem(self, entry):
         dataDefinitionHeader = ESENT_DATA_DEFINITION_HEADER(entry['EntryData'])
@@ -846,7 +846,7 @@ class ESENT_DB:
  
         columns = cursor['TableData']['Columns'] 
         
-        for column in columns.keys():
+        for column in list(columns.keys()):
             columnRecord = columns[column]['Record']
             #columnRecord.dump()
             if columnRecord['Identifier'] <= dataDefinitionHeader['LastFixedSize']:
@@ -900,17 +900,17 @@ class ESENT_DB:
                 
                     # Calculate length of variable items
                     # Ugly.. should be redone
-                    prevKey = taggedItems.keys()[0]
+                    prevKey = list(taggedItems.keys())[0]
                     for i in range(1,len(taggedItems)):
                         offset0, length, flags = taggedItems[prevKey]
-                        offset, _, _ = taggedItems.items()[i][1]
+                        offset, _, _ = list(taggedItems.items())[i][1]
                         taggedItems[prevKey] = (offset0, offset-offset0, flags)
                         #print "ID: %d, Offset: %d, Len: %d, flags: %d" % (prevKey, offset0, offset-offset0, flags)
-                        prevKey = taggedItems.keys()[i]
+                        prevKey = list(taggedItems.keys())[i]
                     taggedItemsParsed = True
  
                 # Tagged data type
-                if taggedItems.has_key(columnRecord['Identifier']):
+                if columnRecord['Identifier'] in taggedItems:
                     offsetItem = variableDataBytesProcessed + variableSizeOffset + taggedItems[columnRecord['Identifier']][0] 
                     itemSize = taggedItems[columnRecord['Identifier']][1]
                     # If item have flags, we should skip them
--- impacket/examples/ntlmrelayx/attacks/__init__.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/attacks/__init__.py
@@ -59,7 +59,7 @@ for file in pkg_resources.resource_listdir('impacket.e
             else:
                 # Single class
                 pluginClasses.add(getattr(module, getattr(module, 'PROTOCOL_ATTACK_CLASS')))
-        except Exception, e:
+        except Exception as e:
             LOG.debug(e)
             pass
 
@@ -67,6 +67,6 @@ for file in pkg_resources.resource_listdir('impacket.e
             for pluginName in pluginClass.PLUGIN_NAMES:
                 LOG.debug('Protocol Attack %s loaded..' % pluginName)
                 PROTOCOL_ATTACKS[pluginName] = pluginClass
-    except Exception, e:
+    except Exception as e:
         LOG.debug(str(e))
 
--- impacket/examples/ntlmrelayx/attacks/httpattack.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/attacks/httpattack.py
@@ -34,9 +34,9 @@ class HTTPAttack(ProtocolAttack):
         #for example with:
         result = self.client.request("GET", "/")
         r1 = self.client.getresponse()
-        print r1.status, r1.reason
+        print(r1.status, r1.reason)
         data1 = r1.read()
-        print data1
+        print(data1)
 
         #Remove protocol from target name
         #safeTargetName = self.client.target.replace('http://','').replace('https://','')
--- impacket/examples/ntlmrelayx/attacks/smbattack.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/attacks/smbattack.py
@@ -79,7 +79,7 @@ class SMBAttack(ProtocolAttack):
 
                 remoteOps  = RemoteOperations(self.__SMBConnection, False)
                 remoteOps.enableRegistry()
-            except Exception, e:
+            except Exception as e:
                 if "rpc_s_access_denied" in str(e): # user doesn't have correct privileges
                     if self.config.enumLocalAdmins:
                         LOG.info("Relayed user doesn't have admin on {}. Attempting to enumerate users who do...".format(self.__SMBConnection.getRemoteHost()))
@@ -89,7 +89,7 @@ class SMBAttack(ProtocolAttack):
                             LOG.info("Host {} has the following local admins (hint: try relaying one of them here...)".format(self.__SMBConnection.getRemoteHost()))
                             for name in localAdminNames:
                                 LOG.info("Host {} local admin member: {} ".format(self.__SMBConnection.getRemoteHost(), name))
-                        except DCERPCException, e:
+                        except DCERPCException as e:
                             LOG.info("SAMR access denied")
                         return
                 # Something else went wrong. aborting
@@ -103,7 +103,7 @@ class SMBAttack(ProtocolAttack):
                     self.__answerTMP = ''
                     self.__SMBConnection.getFile('ADMIN$', 'Temp\\__output', self.__answer)
                     self.__SMBConnection.deleteFile('ADMIN$', 'Temp\\__output')
-                    print self.__answerTMP.decode(self.config.encoding, 'replace')
+                    print(self.__answerTMP.decode(self.config.encoding, 'replace'))
                 else:
                     bootKey = remoteOps.getBootKey()
                     remoteOps._RemoteOperations__serviceDeleted = True
@@ -112,7 +112,7 @@ class SMBAttack(ProtocolAttack):
                     samHashes.dump()
                     samHashes.export(self.__SMBConnection.getRemoteHost()+'_samhashes')
                     LOG.info("Done dumping SAM hashes for host: %s", self.__SMBConnection.getRemoteHost())
-            except Exception, e:
+            except Exception as e:
                 LOG.error(str(e))
             finally:
                 if samHashes is not None:
--- impacket/examples/ntlmrelayx/clients/__init__.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/clients/__init__.py
@@ -89,13 +89,13 @@ for file in pkg_resources.resource_listdir('impacket.e
                     pluginClasses.add(getattr(module, pluginClass))
             else:
                 pluginClasses.add(getattr(module, getattr(module, 'PROTOCOL_CLIENT_CLASS')))
-        except Exception, e:
+        except Exception as e:
             LOG.debug(e)
             pass
 
         for pluginClass in pluginClasses:
             LOG.info('Protocol Client %s loaded..' % pluginClass.PLUGIN_NAME)
             PROTOCOL_CLIENTS[pluginClass.PLUGIN_NAME] = pluginClass
-    except Exception, e:
+    except Exception as e:
         LOG.debug(str(e))
 
--- impacket/examples/ntlmrelayx/servers/httprelayserver.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/servers/httprelayserver.py
@@ -13,8 +13,8 @@
 # Description:
 #             This is the HTTP server which relays the NTLMSSP  messages to other protocols
 
-import SimpleHTTPServer
-import SocketServer
+import http.server
+import socketserver
 import socket
 import base64
 import random
@@ -31,7 +31,7 @@ from impacket.examples.ntlmrelayx.servers.socksserver 
 
 class HTTPRelayServer(Thread):
 
-    class HTTPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
+    class HTTPServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
         def __init__(self, server_address, RequestHandlerClass, config):
             self.config = config
             self.daemon_threads = True
@@ -39,9 +39,9 @@ class HTTPRelayServer(Thread):
                 self.address_family = socket.AF_INET6
             # Tracks the number of times authentication was prompted for WPAD per client
             self.wpad_counters = {}
-            SocketServer.TCPServer.__init__(self,server_address, RequestHandlerClass)
+            socketserver.TCPServer.__init__(self,server_address, RequestHandlerClass)
 
-    class HTTPHandler(SimpleHTTPServer.SimpleHTTPRequestHandler):
+    class HTTPHandler(http.server.SimpleHTTPRequestHandler):
         def __init__(self,request, client_address, server):
             self.server = server
             self.protocol_version = 'HTTP/1.1'
@@ -60,17 +60,17 @@ class HTTPRelayServer(Thread):
                 self.target = self.server.config.target.getTarget(self.server.config.randomtargets)
                 LOG.info("HTTPD: Received connection from %s, attacking target %s://%s" % (client_address[0] ,self.target.scheme, self.target.netloc))
             try:
-                SimpleHTTPServer.SimpleHTTPRequestHandler.__init__(self,request, client_address, server)
-            except Exception, e:
+                http.server.SimpleHTTPRequestHandler.__init__(self,request, client_address, server)
+            except Exception as e:
                 LOG.error(str(e))
                 LOG.debug(traceback.format_exc())
 
         def handle_one_request(self):
             try:
-                SimpleHTTPServer.SimpleHTTPRequestHandler.handle_one_request(self)
+                http.server.SimpleHTTPRequestHandler.handle_one_request(self)
             except KeyboardInterrupt:
                 raise
-            except Exception, e:
+            except Exception as e:
                 LOG.error('Exception in HTTP request handler: %s' % e)
                 LOG.debug(traceback.format_exc())
 
@@ -80,7 +80,7 @@ class HTTPRelayServer(Thread):
         def send_error(self, code, message=None):
             if message.find('RPC_OUT') >=0 or message.find('RPC_IN'):
                 return self.do_GET()
-            return SimpleHTTPServer.SimpleHTTPRequestHandler.send_error(self,code,message)
+            return http.server.SimpleHTTPRequestHandler.send_error(self,code,message)
 
         def serve_wpad(self):
             wpadResponse = self.wpad % (self.server.config.wpad_host, self.server.config.wpad_host)
@@ -252,7 +252,7 @@ class HTTPRelayServer(Thread):
             return
 
         def do_ntlm_negotiate(self, token, proxy):
-            if self.server.config.protocolClients.has_key(self.target.scheme.upper()):
+            if self.target.scheme.upper() in self.server.config.protocolClients:
                 self.client = self.server.config.protocolClients[self.target.scheme.upper()](self.server.config, self.target)
                 # If connection failed, return
                 if not self.client.initConnection():
--- impacket/examples/ntlmrelayx/servers/smbrelayserver.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/servers/smbrelayserver.py
@@ -15,7 +15,7 @@
 #   to other protocols
 
 from threading import Thread
-import ConfigParser
+import configparser
 import struct
 import logging
 import time
@@ -50,7 +50,7 @@ class SMBRelayServer(Thread):
         self.proxyTranslator = None
 
         # Here we write a mini config for the server
-        smbConfig = ConfigParser.ConfigParser()
+        smbConfig = configparser.ConfigParser()
         smbConfig.add_section('global')
         smbConfig.set('global','server_name','server_name')
         smbConfig.set('global','server_os','UNIX')
@@ -107,7 +107,7 @@ class SMBRelayServer(Thread):
         # SMBRelay
         # Get the data for all connections
         smbData = smbServer.getConnectionData('SMBRelay', False)
-        if smbData.has_key(self.target):
+        if self.target in smbData:
             # Remove the previous connection and use the last one
             smbClient = smbData[self.target]['SMBClient']
             del smbClient
@@ -125,7 +125,7 @@ class SMBRelayServer(Thread):
                 extSec = True
             # Init the correct client for our target
             client = self.init_client(extSec)
-        except Exception, e:
+        except Exception as e:
             LOG.error("Connection against target %s://%s FAILED: %s" % (self.target.scheme, self.target.netloc, str(e)))
             self.targetprocessor.logTarget(self.target)
         else:
@@ -218,7 +218,7 @@ class SMBRelayServer(Thread):
                if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider'] and \
                                mechType != TypesMech['NEGOEX - SPNEGO Extended Negotiation Security Mechanism']:
                    # Nope, do we know it?
-                   if MechTypes.has_key(mechType):
+                   if mechType in MechTypes:
                        mechStr = MechTypes[mechType]
                    else:
                        mechStr = hexlify(mechType)
@@ -258,7 +258,7 @@ class SMBRelayServer(Thread):
             client = smbData[self.target]['SMBClient']
             try:
                 challengeMessage = self.do_ntlm_negotiate(client, token)
-            except Exception, e:
+            except Exception as e:
                 # Log this target as processed for this client
                 self.targetprocessor.logTarget(self.target)
                 # Raise exception again to pass it on to the SMB server
@@ -376,7 +376,7 @@ class SMBRelayServer(Thread):
         # Get the data for all connections
         smbData = smbServer.getConnectionData('SMBRelay', False)
 
-        if smbData.has_key(self.target):
+        if self.target in smbData:
             # Remove the previous connection and use the last one
             smbClient = smbData[self.target]['SMBClient']
             del smbClient
@@ -398,7 +398,7 @@ class SMBRelayServer(Thread):
 
             #Init the correct client for our target
             client = self.init_client(extSec)
-        except Exception, e:
+        except Exception as e:
             LOG.error("Connection against target %s://%s FAILED: %s" % (self.target.scheme, self.target.netloc, str(e)))
             self.targetprocessor.logTarget(self.target)
         else:
@@ -457,7 +457,7 @@ class SMBRelayServer(Thread):
                 client = smbData[self.target]['SMBClient']
                 try:
                     challengeMessage = self.do_ntlm_negotiate(client,token)
-                except Exception, e:
+                except Exception as e:
                     # Log this target as processed for this client
                     self.targetprocessor.logTarget(self.target)
                     # Raise exception again to pass it on to the SMB server
@@ -645,7 +645,7 @@ class SMBRelayServer(Thread):
 
     #Initialize the correct client for the relay target
     def init_client(self,extSec):
-        if self.config.protocolClients.has_key(self.target.scheme.upper()):
+        if self.target.scheme.upper() in self.config.protocolClients:
             client = self.config.protocolClients[self.target.scheme.upper()](self.config, self.target, extendedSecurity = extSec)
             client.initConnection()
         else:
--- impacket/examples/ntlmrelayx/servers/socksplugins/imap.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/servers/socksplugins/imap.py
@@ -41,8 +41,8 @@ class IMAPSocksRelay(SocksRelay):
         return 143
 
     def getServerCapabilities(self):
-        for key in self.activeRelays.keys():
-            if self.activeRelays[key].has_key('protocolClient'):
+        for key in list(self.activeRelays.keys()):
+            if 'protocolClient' in self.activeRelays[key]:
                 return self.activeRelays[key]['protocolClient'].session.capabilities
 
     def initConnection(self):
@@ -92,7 +92,7 @@ class IMAPSocksRelay(SocksRelay):
             return False
 
         # Check if we have a connection for the user
-        if self.activeRelays.has_key(self.username):
+        if self.username in self.activeRelays:
             # Check the connection is not inUse
             if self.activeRelays[self.username]['inUse'] is True:
                 LOG.error('IMAP: Connection for %s@%s(%s) is being used at the moment!' % (
@@ -119,9 +119,9 @@ class IMAPSocksRelay(SocksRelay):
         while True:
             try:
                 data = self.socksSocket.recv(self.packetSize)
-            except Exception, e:
+            except Exception as e:
                 # Socks socket (client) closed connection or something else. Not fatal for killing the existing relay
-                print keyword, tag
+                print(keyword, tag)
                 LOG.debug('IMAP: sockSocket recv(): %s' % (str(e)))
                 break
             # If this returns with an empty string, it means the socket was closed
@@ -215,14 +215,14 @@ class IMAPSocksRelay(SocksRelay):
         while keyword != tag and keyword != '+':
             try:
                 data = self.relaySocketFile.readline()
-            except Exception, e:
+            except Exception as e:
                 # This didn't break the connection to the server, don't make it fatal
                 LOG.debug("IMAP relaySocketFile: %s" % str(e))
                 return False
             keyword = data.split(' ', 2)[0]
             try:
                 self.socksSocket.sendall(data)
-            except Exception, e:
+            except Exception as e:
                 LOG.debug("IMAP socksSocket: %s" % str(e))
                 return False
 
--- impacket/examples/ntlmrelayx/servers/socksplugins/imaps.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/servers/socksplugins/imaps.py
@@ -43,7 +43,7 @@ class IMAPSSocksRelay(SSLServerMixin, IMAPSocksRelay):
                 # Shut down TLS connection
                 self.socksSocket.shutdown()
                 return False
-        except Exception, e:
+        except Exception as e:
             LOG.debug('IMAPS: %s' % str(e))
             return False
         # Change our outgoing socket to the SSL object of IMAP4_SSL
--- impacket/examples/ntlmrelayx/servers/socksplugins/mssql.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/servers/socksplugins/mssql.py
@@ -114,7 +114,7 @@ class MSSQLSocksRelay(SocksRelay):
                     self.username = ('/%s' % login['UserName']).upper()
 
         # Check if we have a connection for the user
-        if self.activeRelays.has_key(self.username):
+        if self.username in self.activeRelays:
             # Check the connection is not inUse
             if self.activeRelays[self.username]['inUse'] is True:
                 LOG.error('MSSQL: Connection for %s@%s(%s) is being used at the moment!' % (
@@ -152,7 +152,7 @@ class MSSQLSocksRelay(SocksRelay):
                 tds = self.session.recvTDS()
                 # 4. Send it back to the client
                 self.sendTDS(tds['Type'], tds['Data'], 0)
-        except Exception, e:
+        except Exception as e:
             # Probably an error here
             if LOG.level == logging.DEBUG:
                 import traceback
--- impacket/examples/ntlmrelayx/servers/socksplugins/smb.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/servers/socksplugins/smb.py
@@ -54,8 +54,8 @@ class SMBSocksRelay(SocksRelay):
 
         # Let's verify the target's server SMB version, will need it for later.
         # We're assuming all connections to the target server use the same SMB version
-        for key in activeRelays.keys():
-            if activeRelays[key].has_key('protocolClient'):
+        for key in list(activeRelays.keys()):
+            if 'protocolClient' in activeRelays[key]:
                 self.serverDialect = activeRelays[key]['protocolClient'].session.getDialect()
                 self.isSMB2 = activeRelays[key]['protocolClient'].session.getDialect() is not SMB_DIALECT
                 break
@@ -134,7 +134,7 @@ class SMBSocksRelay(SocksRelay):
                                 data2 = self.clientConnection.getSMBServer()._sess.recv_packet(timeout=1).get_trailer()
                                 self.__NBSession.send_packet(str(data))
                                 data = data2
-                        except Exception, e:
+                        except Exception as e:
                             if str(e).find('timed out') > 0:
                                 pass
                             else:
@@ -151,7 +151,7 @@ class SMBSocksRelay(SocksRelay):
                 packet['Flags'] &= ~(SMB2_FLAGS_SIGNED)
 
                 # Let's be sure the TreeConnect Table is filled with fake data
-                if self.clientConnection.getSMBServer()._Session['TreeConnectTable'].has_key(packet['TreeID']) is False:
+                if (packet['TreeID'] in self.clientConnection.getSMBServer()._Session['TreeConnectTable']) is False:
                     self.clientConnection.getSMBServer()._Session['TreeConnectTable'][packet['TreeID']] = {}
                     self.clientConnection.getSMBServer()._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] = False
 
@@ -182,12 +182,12 @@ class SMBSocksRelay(SocksRelay):
         try:
             packet = NewSMBPacket(data=data.get_trailer())
             smbCommand = SMBCommand(packet['Data'][0])
-        except Exception, e:
+        except Exception as e:
             # Maybe a SMB2 packet?
             try:
                 packet = SMB2Packet(data = data.get_trailer())
                 smbCommand = None
-            except Exception, e:
+            except Exception as e:
                 LOG.error('SOCKS: %s' % str(e))
 
         return packet, smbCommand
@@ -355,7 +355,7 @@ class SMBSocksRelay(SocksRelay):
                     username = ('%s/%s' % (authenticateMessage['domain_name'], authenticateMessage['user_name'])).upper()
 
                 # Check if we have a connection for the user
-                if self.activeRelays.has_key(username):
+                if username in self.activeRelays:
                     LOG.info('SOCKS: Proxying client session for %s@%s(445)' % (username, self.targetHost))
                     errorCode = STATUS_SUCCESS
                     smbClient = self.activeRelays[username]['protocolClient'].session
@@ -417,7 +417,7 @@ class SMBSocksRelay(SocksRelay):
                     mechType = blob['MechTypes'][0]
                     if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:
                         # Nope, do we know it?
-                        if MechTypes.has_key(mechType):
+                        if mechType in MechTypes:
                             mechStr = MechTypes[mechType]
                         else:
                             mechStr = hexlify(mechType)
@@ -509,7 +509,7 @@ class SMBSocksRelay(SocksRelay):
             respToken = SPNEGO_NegTokenResp()
 
             # Check if we have a connection for the user
-            if self.activeRelays.has_key(username):
+            if username in self.activeRelays:
                 LOG.info('SOCKS: Proxying client session for %s@%s(445)' % (username, self.targetHost))
                 errorCode = STATUS_SUCCESS
                 smbClient = self.activeRelays[username]['protocolClient'].session
--- impacket/examples/ntlmrelayx/servers/socksserver.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/servers/socksserver.py
@@ -18,11 +18,11 @@
 # [ ] Port handlers should be dynamically subscribed, and coded in another place. This will help coding
 #     proxies for different protocols (e.g. MSSQL)
 
-import SocketServer
+import socketserver
 import socket
 import time
 import logging
-from Queue import Queue
+from queue import Queue
 from struct import unpack, pack
 from threading import Timer, Thread
 
@@ -177,23 +177,23 @@ class SocksRelay:
 def keepAliveTimer(server):
     LOG.debug('KeepAlive Timer reached. Updating connections')
 
-    for target in server.activeRelays.keys():
-        for port in server.activeRelays[target].keys():
+    for target in list(server.activeRelays.keys()):
+        for port in list(server.activeRelays[target].keys()):
             # Now cycle through the users
-            for user in server.activeRelays[target][port].keys():
+            for user in list(server.activeRelays[target][port].keys()):
                 if user != 'data':
                     # Let's call the keepAlive method for the handler to keep the connection alive
                     if server.activeRelays[target][port][user]['inUse'] is False:
                         LOG.debug('Calling keepAlive() for %s@%s:%s' % (user, target, port))
                         try:
                             server.activeRelays[target][port][user]['protocolClient'].keepAlive()
-                        except Exception, e:
+                        except Exception as e:
                             LOG.debug('SOCKS: %s' % str(e))
                             if str(e).find('Broken pipe') >= 0 or str(e).find('reset by peer') >=0 or \
                                             str(e).find('Invalid argument') >= 0 or str(e).find('Server not connected') >=0:
                                 # Connection died, taking out of the active list
                                 del (server.activeRelays[target][port][user])
-                                if len(server.activeRelays[target][port].keys()) == 1:
+                                if len(list(server.activeRelays[target][port].keys())) == 1:
                                     del (server.activeRelays[target][port])
                                 LOG.debug('Removing active relay for %s@%s:%s' % (user, target, port))
                     else:
@@ -204,12 +204,12 @@ def activeConnectionsWatcher(server):
         # This call blocks until there is data, so it doesn't loop endlessly
         target, port, userName, client, data = activeConnections.get()
         # ToDo: Careful. Dicts are not thread safe right?
-        if server.activeRelays.has_key(target) is not True:
+        if (target in server.activeRelays) is not True:
             server.activeRelays[target] = {}
-        if server.activeRelays[target].has_key(port) is not True:
+        if (port in server.activeRelays[target]) is not True:
             server.activeRelays[target][port] = {}
 
-        if server.activeRelays[target][port].has_key(userName) is not True:
+        if (userName in server.activeRelays[target][port]) is not True:
             LOG.info('SOCKS: Adding %s@%s(%s) to active SOCKS connection. Enjoy' % (userName, target, port))
             server.activeRelays[target][port][userName] = {}
             # This is the protocolClient. Needed because we need to access the killConnection from time to time.
@@ -233,7 +233,7 @@ def webService(server):
 
     @app.route('/')
     def index():
-        print server.activeRelays
+        print(server.activeRelays)
         return "Relays available: %s!" % (len(server.activeRelays))
 
     @app.route('/ntlmrelayx/api/v1.0/relays', methods=['GET'])
@@ -253,7 +253,7 @@ def webService(server):
 
     app.run(host='0.0.0.0', port=9090)
 
-class SocksRequestHandler(SocketServer.BaseRequestHandler):
+class SocksRequestHandler(socketserver.BaseRequestHandler):
     def __init__(self, request, client_address, server):
         self.__socksServer = server
         self.__ip, self.__port = client_address
@@ -262,7 +262,7 @@ class SocksRequestHandler(SocketServer.BaseRequestHand
         self.targetHost = None
         self.targetPort = None
         self.__NBSession= None
-        SocketServer.BaseRequestHandler.__init__(self, request, client_address, server)
+        socketserver.BaseRequestHandler.__init__(self, request, client_address, server)
 
     def sendReplyError(self, error = replyField.CONNECTION_REFUSED):
 
@@ -323,8 +323,8 @@ class SocksRequestHandler(SocketServer.BaseRequestHand
         if self.targetPort != 53:
             # Do we have an active connection for the target host/port asked?
             # Still don't know the username, but it's a start
-            if self.__socksServer.activeRelays.has_key(self.targetHost):
-                if self.__socksServer.activeRelays[self.targetHost].has_key(self.targetPort) is not True:
+            if self.targetHost in self.__socksServer.activeRelays:
+                if (self.targetPort in self.__socksServer.activeRelays[self.targetHost]) is not True:
                     LOG.error('SOCKS: Don\'t have a relay for %s(%s)' % (self.targetHost, self.targetPort))
                     self.sendReplyError(replyField.CONNECTION_REFUSED)
                     return
@@ -340,7 +340,7 @@ class SocksRequestHandler(SocketServer.BaseRequestHand
             try:
                 LOG.debug('SOCKS: Connecting to %s(%s)' %(self.targetHost, self.targetPort))
                 s.connect((self.targetHost, self.targetPort))
-            except Exception, e:
+            except Exception as e:
                 if LOG.level == logging.DEBUG:
                     import traceback
                     traceback.print_exc()
@@ -366,13 +366,13 @@ class SocksRequestHandler(SocketServer.BaseRequestHand
                     s.sendall(data)
                     data = s.recv(8192)
                     self.__connSocket.sendall(data)
-                except Exception, e:
+                except Exception as e:
                     if LOG.level == logging.DEBUG:
                         import traceback
                         traceback.print_exc()
                     LOG.error('SOCKS: ', str(e))
 
-        if self.__socksServer.socksPlugins.has_key(self.targetPort):
+        if self.targetPort in self.__socksServer.socksPlugins:
             LOG.debug('Handler for port %s found %s' % (self.targetPort, self.__socksServer.socksPlugins[self.targetPort]))
             relay = self.__socksServer.socksPlugins[self.targetPort](self.targetHost, self.targetPort, self.__connSocket,
                                   self.__socksServer.activeRelays[self.targetHost][self.targetPort])
@@ -402,7 +402,7 @@ class SocksRequestHandler(SocketServer.BaseRequestHand
                 self.__socksServer.activeRelays[self.targetHost][self.targetPort][relay.username]['inUse'] = True
 
                 relay.tunnelConnection()
-            except Exception, e:
+            except Exception as e:
                 if LOG.level == logging.DEBUG:
                     import traceback
                     traceback.print_exc()
@@ -411,7 +411,7 @@ class SocksRequestHandler(SocketServer.BaseRequestHand
                                 str(e).find('Invalid argument') >= 0:
                     # Connection died, taking out of the active list
                     del(self.__socksServer.activeRelays[self.targetHost][self.targetPort][relay.username])
-                    if len(self.__socksServer.activeRelays[self.targetHost][self.targetPort].keys()) == 1:
+                    if len(list(self.__socksServer.activeRelays[self.targetHost][self.targetPort].keys())) == 1:
                         del(self.__socksServer.activeRelays[self.targetHost][self.targetPort])
                     LOG.debug('Removing active relay for %s@%s:%s' % (relay.username, self.targetHost, self.targetPort))
                     self.sendReplyError(replyField.CONNECTION_REFUSED)
@@ -427,11 +427,11 @@ class SocksRequestHandler(SocketServer.BaseRequestHand
         LOG.debug('SOCKS: Shutting down connection')
         try:
             self.sendReplyError(replyField.CONNECTION_REFUSED)
-        except Exception, e:
+        except Exception as e:
             LOG.debug('SOCKS END: %s' % str(e))
 
 
-class SOCKS(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
+class SOCKS(socketserver.ThreadingMixIn, socketserver.TCPServer):
     def __init__(self, server_address=('0.0.0.0', 1080), handler_class=SocksRequestHandler):
         LOG.info('SOCKS proxy started. Listening at port %d', server_address[1] )
 
@@ -440,8 +440,8 @@ class SOCKS(SocketServer.ThreadingMixIn, SocketServer.
         self.restAPI = None
         self.activeConnectionsWatcher = None
         self.supportedSchemes = []
-        SocketServer.TCPServer.allow_reuse_address = True
-        SocketServer.TCPServer.__init__(self, server_address, handler_class)
+        socketserver.TCPServer.allow_reuse_address = True
+        socketserver.TCPServer.__init__(self, server_address, handler_class)
 
         # Let's register the socksplugins plugins we have
         from impacket.examples.ntlmrelayx.servers.socksplugins import SOCKS_RELAYS
@@ -468,7 +468,7 @@ class SOCKS(SocketServer.ThreadingMixIn, SocketServer.
         self.__timer.stop()
         del self.restAPI
         del self.activeConnectionsWatcher
-        return SocketServer.TCPServer.shutdown(self)
+        return socketserver.TCPServer.shutdown(self)
 
 if __name__ == '__main__':
     from impacket.examples import logger
--- impacket/examples/ntlmrelayx/utils/targetsutils.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/ntlmrelayx/utils/targetsutils.py
@@ -33,7 +33,7 @@
 import os
 import random
 import time
-from urlparse import urlparse
+from urllib.parse import urlparse
 from impacket import LOG
 from threading import Thread
 
@@ -79,7 +79,7 @@ class TargetsProcessor:
                     target = line.strip()
                     if target is not None:
                         self.originalTargets.extend(self.processTarget(target, self.protocolClients))
-        except IOError, e:
+        except IOError as e:
             LOG.error("Could not open file: %s - " % (self.filename, str(e)))
 
         if len(self.originalTargets) == 0:
--- impacket/examples/os_ident.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/os_ident.py
@@ -22,6 +22,7 @@
 
 from impacket.ImpactPacket import *
 from impacket.ImpactDecoder import *
+from functools import reduce
 
 g_nmap1_signature_filename="nmap-os-fingerprints"
 g_nmap2_signature_filename="nmap-os-db"
@@ -30,7 +31,7 @@ class os_id_exception:
     def __init__(self, value):
         self.value = value
     def __str__(self):
-        return `self.value`
+        return repr(self.value)
 
 class os_id_test:
     
@@ -276,7 +277,7 @@ class nmap1_tcp_probe(nmap_tcp_probe):
     # "\003\003\012\001\002\004\001\011\010\012\077\077\077\077\000\000\000\000\000\000"
     # [...]
     tcp_options = [
-        TCPOption(TCPOption.TCPOPT_WINDOW, 012), #\003\003\012
+        TCPOption(TCPOption.TCPOPT_WINDOW, 0o12), #\003\003\012
         TCPOption(TCPOption.TCPOPT_NOP), #\001
         TCPOption(TCPOption.TCPOPT_MAXSEG, mss), #\002\004\001\011
         TCPOption(TCPOption.TCPOPT_TIMESTAMP, 0x3F3F3F3F), #\010\012\077\077\077\077\000\000\000\000
@@ -417,7 +418,7 @@ class nmap2_ecn_probe(nmap_tcp_probe):
     # open port.
     # [...]
     tcp_options = [
-        TCPOption(TCPOption.TCPOPT_WINDOW, 012), #\003\003\012
+        TCPOption(TCPOption.TCPOPT_WINDOW, 0o12), #\003\003\012
         TCPOption(TCPOption.TCPOPT_NOP), #\001
         TCPOption(TCPOption.TCPOPT_MAXSEG, 1460), #\002\004\005\0264
         TCPOption(TCPOption.TCPOPT_SACK_PERMITTED), #\004\002
@@ -665,7 +666,7 @@ class nmap2_tcp_probe_2_6(nmap2_tcp_probe):
     # Timestamp (TSval: 0xFFFFFFFF; TSecr: 0), then SACK permitted. 
     # (...
     tcp_options = [
-        TCPOption(TCPOption.TCPOPT_WINDOW, 012), #\003\003\012
+        TCPOption(TCPOption.TCPOPT_WINDOW, 0o12), #\003\003\012
         TCPOption(TCPOption.TCPOPT_NOP), #\001
         TCPOption(TCPOption.TCPOPT_MAXSEG, mss), #\002\004\001\011
         TCPOption(TCPOption.TCPOPT_TIMESTAMP, 0xFFFFFFFF), #\010\012\377\377\377\377\000\000\000\000
@@ -684,7 +685,7 @@ class nmap2_tcp_probe_7(nmap2_tcp_probe):
     # The exception is that T7 uses a Window scale value of 15 rather than 10
     # [...]
     tcp_options = [
-        TCPOption(TCPOption.TCPOPT_WINDOW, 017), #\003\003\017
+        TCPOption(TCPOption.TCPOPT_WINDOW, 0o17), #\003\003\017
         TCPOption(TCPOption.TCPOPT_NOP), #\001
         TCPOption(TCPOption.TCPOPT_MAXSEG, mss), #\002\004\001\011
         TCPOption(TCPOption.TCPOPT_TIMESTAMP, 0xFFFFFFFF), #\010\012\377\377\377\377\000\000\000\000
@@ -1004,7 +1005,7 @@ class OS_ID:
 
             # Ok, I need to know if the constructor accepts the parameter port
             # We could ask also by co_varnames, but the port parameters is not a standarized... asking by args count :(
-            if t_class.__init__.im_func.func_code.co_argcount == 4:
+            if t_class.__init__.__func__.__code__.co_argcount == 4:
                 test = t_class(self.get_new_id(), [self.__source, self.__target], self.__ports )
             else:
                 test = t_class(self.get_new_id(), [self.__source, self.__target] )
@@ -1348,7 +1349,7 @@ class nmap1_seq_container(os_id_test):
         ipid_diffs = array.array('H', [0] * (self.seq_num_responses - 1))
 
         null_ipids = 1
-        for i in xrange(1, self.seq_num_responses):
+        for i in range(1, self.seq_num_responses):
             prev_ipid = self.seq_responses[i-1].get_ipid()
             cur_ipid = self.seq_responses[i].get_ipid()
 
@@ -1364,13 +1365,13 @@ class nmap1_seq_container(os_id_test):
         # If any diff is > 1000, set to random, if 0, set to constant.
         # If any of the diffs are 1, or all are less than 9, set to incremental.
 
-        for i in xrange(0, self.seq_num_responses - 1):
+        for i in range(0, self.seq_num_responses - 1):
             if ipid_diffs[i] > 1000: return nmap1_seq.IPID_SEQ_RPI
             if ipid_diffs[i] == 0: return nmap1_seq.IPID_SEQ_CONSTANT
 
         is_incremental = 1 # All diferences are less than 9
         is_ms = 1 # All diferences are multiples of 256
-        for i in xrange(0, self.seq_num_responses - 1):
+        for i in range(0, self.seq_num_responses - 1):
             if ipid_diffs[i] == 1: return nmap1_seq.IPID_SEQ_INCR
             if is_ms and ipid_diffs[i] < 2560 and (ipid_diffs[i] % 256) != 0: is_ms = 0
             if ipid_diffs[i] > 9: is_incremental = 0
@@ -1391,7 +1392,7 @@ class nmap1_seq_container(os_id_test):
         # 5) Same with ~100/s.
 
         avg_freq = 0.0
-        for i in xrange(0, self.seq_num_responses - 1):
+        for i in range(0, self.seq_num_responses - 1):
             dhz = self.ts_diffs[i] / self.time_diffs[i]
             avg_freq += dhz / (self.seq_num_responses - 1)
 
@@ -1409,8 +1410,8 @@ class nmap1_seq_container(os_id_test):
         seqclass = nmap1_seq.SEQ_UNKNOWN
 
         if 0 != self.seq_gcd:
-            map(lambda x, gcd = self.seq_gcd: x / gcd, self.seq_diffs)
-            for i in xrange(0, self.seq_num_responses - 1):
+            list(map(lambda x, gcd = self.seq_gcd: x / gcd, self.seq_diffs))
+            for i in range(0, self.seq_num_responses - 1):
                 if abs(self.seq_responses[i+1].get_seq() - self.seq_responses[i].get_seq()) > 50000000:
                     seqclass = nmap1_seq.SEQ_TR;
                     self.index = 9999999
@@ -1531,7 +1532,7 @@ class nmap2_seq_container(os_id_test):
 
         # Random and zero
         null_ipids = 1
-        for i in xrange(1, self.seq_num_responses):
+        for i in range(1, self.seq_num_responses):
             prev_ipid = self.seq_responses[i-1].get_ipid()
             cur_ipid = self.seq_responses[i].get_ipid()
 
@@ -1553,7 +1554,7 @@ class nmap2_seq_container(os_id_test):
 
         # Constant
         all_zero = 1
-        for i in xrange(0, self.seq_num_responses - 1):
+        for i in range(0, self.seq_num_responses - 1):
             if ipid_diffs[i] != 0: 
                 all_zero = 0
                 break
@@ -1563,7 +1564,7 @@ class nmap2_seq_container(os_id_test):
             return
 
         # Random positive increments
-        for i in xrange(0, self.seq_num_responses - 1):
+        for i in range(0, self.seq_num_responses - 1):
             if ipid_diffs[i] > 1000 and \
                ((ipid_diffs[i] % 256 != 0) or \
                 ((ipid_diffs[i] % 256 == 0) and (ipid_diffs[i] >= 25600))):
@@ -1573,7 +1574,7 @@ class nmap2_seq_container(os_id_test):
         # Broken Increment and Incremental
         is_incremental = 1 # All diferences are less than 10
         is_ms = 1 # All diferences are multiples of 256 and no greater than 5120
-        for i in xrange(0, self.seq_num_responses - 1):
+        for i in range(0, self.seq_num_responses - 1):
             if is_ms and ((ipid_diffs[i] > 5120) or (ipid_diffs[i] % 256) != 0): 
                 is_ms = 0
             if is_incremental and ipid_diffs[i] > 9: 
@@ -1606,7 +1607,7 @@ class nmap2_seq_container(os_id_test):
             return
 
         avg_freq = 0.0
-        for i in xrange(0, self.seq_num_responses - 1):
+        for i in range(0, self.seq_num_responses - 1):
             dhz = self.ts_diffs[i] / self.time_diffs[i]
             avg_freq += dhz / (self.seq_num_responses - 1)
 
@@ -1626,7 +1627,7 @@ class nmap2_seq_container(os_id_test):
         seq_gcd = reduce(my_gcd, self.seq_diffs)
 
         seq_avg_rate = 0.0
-        for i in xrange(0, self.seq_num_responses - 1):
+        for i in range(0, self.seq_num_responses - 1):
             seq_avg_rate += self.seq_diffs[i] / self.time_diffs[i]
         seq_avg_rate /= (self.seq_num_responses - 1)
 
@@ -1643,7 +1644,7 @@ class nmap2_seq_container(os_id_test):
             if seq_gcd > 9:
                 div_gcd = seq_gcd
 
-            for i in xrange(0, self.seq_num_responses - 1):
+            for i in range(0, self.seq_num_responses - 1):
                 rtmp = (self.seq_diffs[i] / self.time_diffs[i]) / div_gcd - \
                        seq_avg_rate / div_gcd
                 seq_stddev += rtmp * rtmp
@@ -1675,7 +1676,7 @@ class nmap2_ops_container(os_id_test):
             self.add_result('R', 'N')
             return
 
-        for i in xrange(0, self.seq_num_responses):
+        for i in range(0, self.seq_num_responses):
             tests = nmap2_tcp_tests(self.seq_responses[i].get_ip(),
                                     self.seq_responses[i].get_tcp(),
                                     0,
@@ -1703,7 +1704,7 @@ class nmap2_win_container(os_id_test):
             self.add_result('R', 'N')
             return
 
-        for i in xrange(0, self.seq_num_responses):
+        for i in range(0, self.seq_num_responses):
             tests = nmap2_tcp_tests(self.seq_responses[i].get_ip(),
                                     self.seq_responses[i].get_tcp(),
                                     0,
@@ -1972,9 +1973,9 @@ class NMAP2_Fingerprint:
     def parse_int(self, field, value):
         try:
             return int(value, 16)
-        except ValueError, err:
-            if NMAP2_Fingerprint.literal_conv.has_key( field ):
-                if NMAP2_Fingerprint.literal_conv[field].has_key(value):
+        except ValueError as err:
+            if field in NMAP2_Fingerprint.literal_conv:
+                if value in NMAP2_Fingerprint.literal_conv[field]:
                     return NMAP2_Fingerprint.literal_conv[field][value]
             return 0
 
@@ -2009,14 +2010,14 @@ class NMAP2_Fingerprint:
 
         for test in self.__tests:
             # ignore unknown response lines:
-            if not sample.has_key(test):
+            if test not in sample:
                 continue
         
             for field in self.__tests[test]:
                     # ignore unsupported fields:
-                if not sample[test].has_key(field) or \
-                   not mp.has_key(test) or \
-                   not mp[test].has_key(field):
+                if field not in sample[test] or \
+                   test not in mp or \
+                   field not in mp[test]:
                     continue
             
                 ref = self.__tests[test][field]
@@ -2047,8 +2048,8 @@ class NMAP2_Fingerprint_Matcher:
                 fp = self.parse_fp(fingerprint)
                 similarity = fp.compare(res, mp)
                 if similarity >= threshold: 
-                    print "\"%s\" matches with an accuracy of %.2f%%" \
-                           % (fp.get_id(), similarity)
+                    print("\"%s\" matches with an accuracy of %.2f%%" \
+                           % (fp.get_id(), similarity))
                     output.append((similarity / 100,
                                    fp.get_id(),
                                    (fp.get_os_class().get_vendor(),
@@ -2057,8 +2058,8 @@ class NMAP2_Fingerprint_Matcher:
                                     fp.get_os_class().get_device_type())))
 
             infile.close()
-        except IOError, err:
-            print "IOError: %s", err
+        except IOError as err:
+            print("IOError: %s", err)
 
         return output
 
@@ -2091,7 +2092,7 @@ class NMAP2_Fingerprint_Matcher:
             yield section
 
     def matchpoints(self, infile):
-        return self.sections(infile,"MatchPoints").next()
+        return next(self.sections(infile,"MatchPoints"))
 
     def parse_line(self, line):
         name = line[:line.find("(")]
--- impacket/examples/remcomsvc.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/remcomsvc.py
@@ -1666,4 +1666,4 @@ REMCOMSVC='4d5a90000300000004000000ffff0000b8000000000
 '0000000000000000000000000000000000000000000000000000000000000000000000' \
 '0000000000000000000000000000000000000000000000000000000000000000000000' \
 '0000000000000000000000000000000000000000000000000000000000000000000000' \
-'00000000000000000000' \
+'00000000000000000000'
--- impacket/examples/secretsdump.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/secretsdump.py
@@ -289,7 +289,7 @@ class RemoteFile:
             try:
                 self.__fid = self.__smbConnection.openFile(self.__tid, self.__fileName, desiredAccess=FILE_READ_DATA,
                                                    shareMode=FILE_SHARE_READ)
-            except Exception, e:
+            except Exception as e:
                 if str(e).find('STATUS_SHARING_VIOLATION') >=0:
                     if tries >= 3:
                         raise e
@@ -527,7 +527,7 @@ class RemoteOperations:
             self.__ppartialAttrSet = drsuapi.PARTIAL_ATTR_VECTOR_V1_EXT()
             self.__ppartialAttrSet['dwVersion'] = 1
             self.__ppartialAttrSet['cAttrs'] = len(NTDSHashes.ATTRTYP_TO_ATTID)
-            for attId in NTDSHashes.ATTRTYP_TO_ATTID.values():
+            for attId in list(NTDSHashes.ATTRTYP_TO_ATTID.values()):
                 self.__ppartialAttrSet['rgPartialAttr'].append(drsuapi.MakeAttid(self.__prefixTable , attId))
         request['pmsgIn']['V8']['pPartialAttrSet'] = self.__ppartialAttrSet
         request['pmsgIn']['V8']['PrefixTableDest']['PrefixCount'] = len(self.__prefixTable)
@@ -547,7 +547,7 @@ class RemoteOperations:
                                                                        samr.USER_SERVER_TRUST_ACCOUNT |\
                                                                        samr.USER_INTERDOMAIN_TRUST_ACCOUNT,
                                                     enumerationContext=enumerationContext)
-        except DCERPCException, e:
+        except DCERPCException as e:
             if str(e).find('STATUS_MORE_ENTRIES') < 0:
                 raise
             resp = e.get_packet()
@@ -603,7 +603,7 @@ class RemoteOperations:
             if account.startswith('.\\'):
                 account = account[2:]
             return account
-        except Exception, e:
+        except Exception as e:
             # Don't log if history service is not found, that should be normal
             if serviceName.endswith("_history") is False:
                 LOG.error(e)
@@ -677,7 +677,7 @@ class RemoteOperations:
                 scmr.hRCloseServiceHandle(self.__scmr, self.__serviceHandle)
                 scmr.hRCloseServiceHandle(self.__scmr, self.__scManagerHandle)
                 rpc.disconnect()
-            except Exception, e:
+            except Exception as e:
                 # If service is stopped it'll trigger an exception
                 # If service does not exist it'll trigger an exception
                 # So. we just wanna be sure we delete it, no need to 
@@ -695,7 +695,7 @@ class RemoteOperations:
         if self.__scmr is not None:
             try:
                 self.__scmr.disconnect()
-            except Exception, e:
+            except Exception as e:
                 if str(e).find('STATUS_INVALID_PARAMETER') >=0:
                     pass
                 else:
@@ -717,7 +717,7 @@ class RemoteOperations:
 
         bootKey = unhexlify(bootKey)
 
-        for i in xrange(len(bootKey)):
+        for i in range(len(bootKey)):
             self.__bootKey += bootKey[transforms[i]]
 
         LOG.info('Target system bootKey: 0x%s' % hexlify(self.__bootKey))
@@ -913,7 +913,7 @@ class RemoteOperations:
             try:
                 self.__smbConnection.getFile('ADMIN$', 'Temp\\__output', self.__answer)
                 break
-            except Exception, e:
+            except Exception as e:
                 if tries > 30:
                     # We give up
                     raise Exception('Too many tries trying to list vss shadows')
@@ -994,7 +994,7 @@ class RemoteOperations:
             try:
                 self.__smbConnection.deleteFile('ADMIN$', 'Temp\\__output')
                 break
-            except Exception, e:
+            except Exception as e:
                 if tries >= 30:
                     raise e
                 if str(e).find('STATUS_OBJECT_NAME_NOT_FOUND') >= 0 or str(e).find('STATUS_SHARING_VIOLATION') >=0:
@@ -1575,7 +1575,7 @@ class ResumeSessionMgrInFile(object):
     def getResumeData(self):
         try:
             self.__resumeFile = open(self.__resumeFileName,'rb')
-        except Exception, e:
+        except Exception as e:
             raise Exception('Cannot open resume session file name %s' % str(e))
         resumeSid = self.__resumeFile.read()
         self.__resumeFile.close()
@@ -1593,7 +1593,7 @@ class ResumeSessionMgrInFile(object):
         if not self.__resumeFile:
             try:
                 self.__resumeFile = open(self.__resumeFileName, 'wb+')
-            except Exception, e:
+            except Exception as e:
                 raise Exception('Cannot create "%s" resume session file: %s' % (self.__resumeFileName, str(e)))
 
     def endTransaction(self):
@@ -1664,7 +1664,7 @@ class NTDSHashes:
         0xffffff74:'rc4_hmac',
     }
 
-    INTERNAL_TO_NAME = dict((v,k) for k,v in NAME_TO_INTERNAL.iteritems())
+    INTERNAL_TO_NAME = dict((v,k) for k,v in NAME_TO_INTERNAL.items())
 
     SAM_NORMAL_USER_ACCOUNT = 0x30000000
     SAM_MACHINE_ACCOUNT     = 0x30000001
@@ -1866,7 +1866,7 @@ class NTDSHashes:
                 try:
                     attId = drsuapi.OidFromAttid(prefixTable, attr['attrTyp'])
                     LOOKUP_TABLE = self.ATTRTYP_TO_ATTID
-                except Exception, e:
+                except Exception as e:
                     LOG.debug('Failed to execute OidFromAttid with error %s' % e)
                     # Fallbacking to fixed table and hope for the best
                     attId = attr['attrTyp']
@@ -1921,7 +1921,7 @@ class NTDSHashes:
                         data = data[len(keyDataNew):]
                         keyValue = propertyValueBuffer[keyDataNew['KeyOffset']:][:keyDataNew['KeyLength']]
 
-                        if  self.KERBEROS_TYPE.has_key(keyDataNew['KeyType']):
+                        if  keyDataNew['KeyType'] in self.KERBEROS_TYPE:
                             answer =  "%s:%s:%s" % (userName, self.KERBEROS_TYPE[keyDataNew['KeyType']],hexlify(keyValue))
                         else:
                             answer =  "%s:%s:%s" % (userName, hex(keyDataNew['KeyType']),hexlify(keyValue))
@@ -2064,7 +2064,7 @@ class NTDSHashes:
                 try:
                     attId = drsuapi.OidFromAttid(prefixTable, attr['attrTyp'])
                     LOOKUP_TABLE = self.ATTRTYP_TO_ATTID
-                except Exception, e:
+                except Exception as e:
                     LOG.debug('Failed to execute OidFromAttid with error %s, fallbacking to fixed table' % e)
                     # Fallbacking to fixed table and hope for the best
                     attId = attr['attrTyp']
@@ -2201,7 +2201,7 @@ class NTDSHashes:
                                 raise
                     else:
                         raise Exception('No remote Operations available')
-                except Exception, e:
+                except Exception as e:
                     LOG.debug('Exiting NTDSHashes.dump() because %s' % e)
                     # Target's not a DC
                     return
@@ -2234,7 +2234,7 @@ class NTDSHashes:
                             self.__decryptHash(record, outputFile=hashesOutputFile)
                             if self.__justNTLM is False:
                                 self.__decryptSupplementalInfo(record, None, keysOutputFile, clearTextOutputFile)
-                        except Exception, e:
+                        except Exception as e:
                             if LOG.level == logging.DEBUG:
                                 import traceback
                                 traceback.print_exc()
@@ -2263,7 +2263,7 @@ class NTDSHashes:
                                 self.__decryptHash(record, outputFile=hashesOutputFile)
                                 if self.__justNTLM is False:
                                     self.__decryptSupplementalInfo(record, None, keysOutputFile, clearTextOutputFile)
-                        except Exception, e:
+                        except Exception as e:
                             if LOG.level == logging.DEBUG:
                                 import traceback
                                 traceback.print_exc()
@@ -2329,7 +2329,7 @@ class NTDSHashes:
                             self.__decryptSupplementalInfo(userRecord, userRecord['pmsgOut'][replyVersion]['PrefixTableSrc'][
                                 'pPrefixEntry'], keysOutputFile, clearTextOutputFile)
 
-                    except Exception, e:
+                    except Exception as e:
                         #import traceback
                         #traceback.print_exc()
                         LOG.error("Error while processing user!")
@@ -2382,7 +2382,7 @@ class NTDSHashes:
                                     self.__decryptSupplementalInfo(userRecord, userRecord['pmsgOut'][replyVersion]['PrefixTableSrc'][
                                         'pPrefixEntry'], keysOutputFile, clearTextOutputFile)
 
-                            except Exception, e:
+                            except Exception as e:
                                 if LOG.level == logging.DEBUG:
                                     import traceback
                                     traceback.print_exc()
@@ -2408,7 +2408,7 @@ class NTDSHashes:
                 else:
                     LOG.info('Kerberos keys grabbed')
 
-                for itemKey in self.__kerberosKeys.keys():
+                for itemKey in list(self.__kerberosKeys.keys()):
                     self.__perSecretCallback(NTDSHashes.SECRET_TYPE.NTDS_KERBEROS, itemKey)
 
             # And finally the cleartext pwds
@@ -2418,7 +2418,7 @@ class NTDSHashes:
                 else:
                     LOG.info('ClearText passwords grabbed')
 
-                for itemKey in self.__clearTextPwds.keys():
+                for itemKey in list(self.__clearTextPwds.keys()):
                     self.__perSecretCallback(NTDSHashes.SECRET_TYPE.NTDS_CLEARTEXT, itemKey)
         finally:
             # Resources cleanup
@@ -2437,7 +2437,7 @@ class NTDSHashes:
     def __writeOutput(cls, fd, data):
         try:
             fd.write(data)
-        except Exception, e:
+        except Exception as e:
             LOG.error("Error writing entry, skipping (%s)" % str(e))
             pass
 
@@ -2467,7 +2467,7 @@ class LocalOperations:
 
         tmpKey = unhexlify(tmpKey)
 
-        for i in xrange(len(tmpKey)):
+        for i in range(len(tmpKey)):
             bootKey += tmpKey[transforms[i]]
 
         LOG.info('Target system bootKey: 0x%s' % hexlify(bootKey))
@@ -2496,4 +2496,4 @@ class LocalOperations:
         return True
 
 def _print_helper(*args, **kwargs):
-    print args[-1]
+    print(args[-1])
--- impacket/examples/serviceinstall.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/serviceinstall.py
@@ -65,7 +65,7 @@ class ServiceInstall:
         # First we try to open the service in case it exists. If it does, we remove it.
         try:
             resp =  scmr.hROpenServiceW(self.rpcsvc, handle, self.__service_name+'\x00')
-        except Exception, e:
+        except Exception as e:
             if str(e).find('ERROR_SERVICE_DOES_NOT_EXIST') >= 0:
                 # We're good, pass the exception
                 pass
@@ -181,7 +181,7 @@ class ServiceInstall:
                         scmr.hRCloseServiceHandle(self.rpcsvc, service)
                     scmr.hRCloseServiceHandle(self.rpcsvc, svcManager)
                     return True
-            except Exception, e:
+            except Exception as e:
                 LOG.critical("Error performing the installation, cleaning up: %s" %e)
                 try:
                     scmr.hRControlService(self.rpcsvc, service, scmr.SERVICE_CONTROL_STOP)
--- impacket/examples/smbclient.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/examples/smbclient.py
@@ -69,7 +69,7 @@ class MiniImpacketShell(cmd.Cmd):
         retVal = False
         try:
            retVal = cmd.Cmd.onecmd(self,s)
-        except Exception, e:
+        except Exception as e:
            #import traceback
            #traceback.print_exc()
            LOG.error(e)
@@ -83,11 +83,11 @@ class MiniImpacketShell(cmd.Cmd):
 
     def do_shell(self, line):
         output = os.popen(line).read()
-        print output
+        print(output)
         self.last_output = output
 
     def do_help(self,line):
-        print """
+        print("""
  open {host,port=445} - opens a SMB connection against the target host/port
  login {domain/username,passwd} - logs into the current SMB connection, no parameters for NULL connection. If no password specified, it'll be prompted
  kerberos_login {domain/username,passwd} - logs into the current SMB connection using Kerberos. If no password specified, it'll be prompted. Use the DNS resolvable domain name
@@ -110,7 +110,7 @@ class MiniImpacketShell(cmd.Cmd):
  close - closes the current SMB Session
  exit - terminates the server process (and this session)
 
-"""
+""")
 
     def do_password(self, line):
         if self.loggedIn is False:
@@ -280,12 +280,12 @@ class MiniImpacketShell(cmd.Cmd):
         dce.bind(srvs.MSRPC_UUID_SRVS)
         resp = srvs.hNetrServerGetInfo(dce, 102)
 
-        print "Version Major: %d" % resp['InfoStruct']['ServerInfo102']['sv102_version_major']
-        print "Version Minor: %d" % resp['InfoStruct']['ServerInfo102']['sv102_version_minor']
-        print "Server Name: %s" % resp['InfoStruct']['ServerInfo102']['sv102_name']
-        print "Server Comment: %s" % resp['InfoStruct']['ServerInfo102']['sv102_comment']
-        print "Server UserPath: %s" % resp['InfoStruct']['ServerInfo102']['sv102_userpath']
-        print "Simultaneous Users: %d" % resp['InfoStruct']['ServerInfo102']['sv102_users']
+        print("Version Major: %d" % resp['InfoStruct']['ServerInfo102']['sv102_version_major'])
+        print("Version Minor: %d" % resp['InfoStruct']['ServerInfo102']['sv102_version_minor'])
+        print("Server Name: %s" % resp['InfoStruct']['ServerInfo102']['sv102_name'])
+        print("Server Comment: %s" % resp['InfoStruct']['ServerInfo102']['sv102_comment'])
+        print("Server UserPath: %s" % resp['InfoStruct']['ServerInfo102']['sv102_userpath'])
+        print("Simultaneous Users: %d" % resp['InfoStruct']['ServerInfo102']['sv102_users'])
 
     def do_who(self, line):
         if self.loggedIn is False:
@@ -298,9 +298,9 @@ class MiniImpacketShell(cmd.Cmd):
         resp = srvs.hNetrSessionEnum(dce, NULL, NULL, 10)
 
         for session in resp['InfoStruct']['SessionInfo']['Level10']['Buffer']:
-            print "host: %15s, user: %5s, active: %5d, idle: %5d" % (
+            print("host: %15s, user: %5s, active: %5d, idle: %5d" % (
             session['sesi10_cname'][:-1], session['sesi10_username'][:-1], session['sesi10_time'],
-            session['sesi10_idle_time'])
+            session['sesi10_idle_time']))
 
     def do_shares(self, line):
         if self.loggedIn is False:
@@ -308,7 +308,7 @@ class MiniImpacketShell(cmd.Cmd):
             return
         resp = self.smb.listShares()
         for i in range(len(resp)):
-            print resp[i]['shi1_netname'][:-1]
+            print(resp[i]['shi1_netname'][:-1])
 
     def do_use(self,line):
         if self.loggedIn is False:
@@ -345,9 +345,9 @@ class MiniImpacketShell(cmd.Cmd):
             raise
 
     def do_lcd(self, s):
-        print s
+        print(s)
         if s == '':
-           print os.getcwd()
+           print(os.getcwd())
         else:
            os.chdir(s)
 
@@ -355,7 +355,7 @@ class MiniImpacketShell(cmd.Cmd):
         if self.loggedIn is False:
             LOG.error("Not logged in")
             return
-        print self.pwd
+        print(self.pwd)
 
     def do_ls(self, wildcard, display = True):
         if self.loggedIn is False:
@@ -373,9 +373,9 @@ class MiniImpacketShell(cmd.Cmd):
         pwd = ntpath.normpath(pwd)
         for f in self.smb.listPath(self.share, pwd):
             if display is True:
-                print "%crw-rw-rw- %10d  %s %s" % (
+                print("%crw-rw-rw- %10d  %s %s" % (
                 'd' if f.is_directory() > 0 else '-', f.get_filesize(), time.ctime(float(f.get_mtime_epoch())),
-                f.get_longname())
+                f.get_longname()))
             self.completion.append((f.get_longname(), f.is_directory()))
 
 
--- impacket/krb5/ccache.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/krb5/ccache.py
@@ -72,10 +72,10 @@ class Times(Structure):
         ('renew_till','!L=0'),
     )
     def prettyPrint(self, indent = ''):
-        print "%sAuth : %s" % (indent, datetime.fromtimestamp(self['authtime']).isoformat())
-        print "%sStart: %s" % (indent, datetime.fromtimestamp(self['starttime']).isoformat())
-        print "%sEnd  : %s" % (indent, datetime.fromtimestamp(self['endtime']).isoformat())
-        print "%sRenew: %s" % (indent, datetime.fromtimestamp(self['renew_till']).isoformat())
+        print("%sAuth : %s" % (indent, datetime.fromtimestamp(self['authtime']).isoformat()))
+        print("%sStart: %s" % (indent, datetime.fromtimestamp(self['starttime']).isoformat()))
+        print("%sEnd  : %s" % (indent, datetime.fromtimestamp(self['endtime']).isoformat()))
+        print("%sRenew: %s" % (indent, datetime.fromtimestamp(self['renew_till']).isoformat()))
 
 class Address(Structure):
     structure = (
@@ -230,21 +230,21 @@ class Credential:
         return self.getData()
 
     def prettyPrint(self, indent=''):
-        print "%sClient: %s" % (indent, self.header['client'].prettyPrint())
-        print "%sServer: %s" % (indent, self.header['server'].prettyPrint())
-        print "%s%s" % (indent, self.header['key'].prettyPrint())
-        print "%sTimes: " % indent
+        print("%sClient: %s" % (indent, self.header['client'].prettyPrint()))
+        print("%sServer: %s" % (indent, self.header['server'].prettyPrint()))
+        print("%s%s" % (indent, self.header['key'].prettyPrint()))
+        print("%sTimes: " % indent)
         self.header['time'].prettyPrint('\t\t')
-        print "%sSubKey: %s" % (indent, self.header['is_skey'])
-        print "%sFlags: 0x%x" % (indent, self.header['tktflags'])
-        print "%sAddresses: %d" % (indent, self.header['num_address'])
+        print("%sSubKey: %s" % (indent, self.header['is_skey']))
+        print("%sFlags: 0x%x" % (indent, self.header['tktflags']))
+        print("%sAddresses: %d" % (indent, self.header['num_address']))
         for address in self.addresses:
             address.prettyPrint('\t\t')
-        print "%sAuth Data: %d" % (indent, len(self.authData))
+        print("%sAuth Data: %d" % (indent, len(self.authData)))
         for ad in self.authData:
             ad.prettyPrint('\t\t')
-        print "%sTicket: %s" % (indent, self.ticket.prettyPrint())
-        print "%sSecond Ticket: %s" % (indent, self.secondTicket.prettyPrint())
+        print("%sTicket: %s" % (indent, self.ticket.prettyPrint()))
+        print("%sSecond Ticket: %s" % (indent, self.secondTicket.prettyPrint()))
 
     def toTGT(self):
         tgt_rep = AS_REP()
@@ -516,10 +516,10 @@ class CCache:
         f.close()
 
     def prettyPrint(self):
-        print "Primary Principal: %s" % self.principal.prettyPrint()
-        print "Credentials: "
+        print("Primary Principal: %s" % self.principal.prettyPrint())
+        print("Credentials: ")
         for i, credential in enumerate(self.credentials):
-            print "[%d]" % i
+            print("[%d]" % i)
             credential.prettyPrint('\t') 
 
 
--- impacket/krb5/kerberosv5.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/krb5/kerberosv5.py
@@ -51,7 +51,7 @@ def sendReceive(data, host, kdcHost):
         af, socktype, proto, canonname, sa = socket.getaddrinfo(targetHost, 88, 0, socket.SOCK_STREAM)[0]
         s = socket.socket(af, socktype, proto)
         s.connect(sa)
-    except socket.error, e:
+    except socket.error as e:
         raise socket.error("Connection error (%s:%s)" % (targetHost, 88), e)
 
     s.sendall(messageLen + data)
@@ -140,7 +140,7 @@ def getKerberosTGT(clientName, password, domain, lmhas
 
     try:
         r = sendReceive(message, domain, kdcHost)
-    except KerberosError, e:
+    except KerberosError as e:
         if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
             if supportedCiphers[0] in (constants.EncryptionTypes.aes128_cts_hmac_sha1_96.value, constants.EncryptionTypes.aes256_cts_hmac_sha1_96.value) and aesKey is '':
                 supportedCiphers = (int(constants.EncryptionTypes.rc4_hmac.value),)
@@ -181,7 +181,7 @@ def getKerberosTGT(clientName, password, domain, lmhas
                         salt = ''
                     else:
                         salt = str(etype2['salt'])
-                except PyAsn1Error, e:
+                except PyAsn1Error as e:
                     salt = ''
 
                 encryptionTypesData[etype2['etype']] = salt
@@ -193,7 +193,7 @@ def getKerberosTGT(clientName, password, domain, lmhas
                         salt = ''
                     else:
                         salt = str(etype['salt'])
-                except PyAsn1Error, e:
+                except PyAsn1Error as e:
                     salt = ''
 
                 encryptionTypesData[etype['etype']] = salt
@@ -211,7 +211,7 @@ def getKerberosTGT(clientName, password, domain, lmhas
         key = cipher.string_to_key(password, encryptionTypesData[enctype], None)
 
     if preAuth is True:
-        if encryptionTypesData.has_key(enctype) is False:
+        if (enctype in encryptionTypesData) is False:
             raise Exception('No Encryption Data Available!')
 
         # Let's build the timestamp
@@ -272,7 +272,7 @@ def getKerberosTGT(clientName, password, domain, lmhas
 
         try:
             tgt = sendReceive(encoder.encode(asReq), domain, kdcHost)
-        except Exception, e:
+        except Exception as e:
             if str(e).find('KDC_ERR_ETYPE_NOSUPP') >= 0:
                 if lmhash is '' and nthash is '' and (aesKey is '' or aesKey is None):
                     from impacket.ntlm import compute_lmhash, compute_nthash
@@ -435,7 +435,7 @@ def getKerberosType3(cipher, sessionKey, auth_data):
     #ap_rep = decoder.decode(negTokenResp['ResponseToken'][16:], asn1Spec=AP_REP())[0]
     try:
         krbError = KerberosError(packet = decoder.decode(negTokenResp['ResponseToken'][15:], asn1Spec = KRB_ERROR())[0])
-    except Exception, e:
+    except Exception as e:
         pass
     else:
         raise krbError
@@ -482,7 +482,7 @@ def getKerberosType1(username, password, domain, lmhas
         if useCache is True:
             try:
                 ccache = CCache.loadFile(os.getenv('KRB5CCNAME'))
-            except Exception, e:
+            except Exception as e:
                 # No cache present
                 pass
             else:
@@ -521,7 +521,7 @@ def getKerberosType1(username, password, domain, lmhas
             if TGS is None:
                 try:
                     tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)
-                except KerberosError, e:
+                except KerberosError as e:
                     if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
                         # We might face this if the target does not support AES 
                         # So, if that's the case we'll force using RC4 by converting
@@ -549,7 +549,7 @@ def getKerberosType1(username, password, domain, lmhas
             serverName = Principal('host/%s' % targetName, type=constants.PrincipalNameType.NT_SRV_INST.value)
             try:
                 tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)
-            except KerberosError, e:
+            except KerberosError as e:
                 if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
                     # We might face this if the target does not support AES 
                     # So, if that's the case we'll force using RC4 by converting
--- impacket/krb5/types.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/krb5/types.py
@@ -31,14 +31,14 @@ import struct
 
 from pyasn1.codec.der import decoder
 
-import asn1
-import constants
+from . import asn1
+from . import constants
 
 
 class KerberosException(Exception): pass
 
 def _asn1_decode(data, asn1Spec):
-    if isinstance(data, basestring):
+    if isinstance(data, str):
         data, substrate = decoder.decode(data, asn1Spec=asn1Spec)
         if substrate != '':
             raise KerberosException("asn1 encoding invalid")
@@ -66,7 +66,7 @@ If the value contains no realm, then default_realm wil
             self.type = value.type
             self.components = value.components[:]
             self.realm = value.realm
-        elif isinstance(value, basestring):
+        elif isinstance(value, str):
             m = re.match(r'((?:[^\\]|\\.)+?)(@((?:[^\\@]|\\.)+))?$', value)
             if not m:
                 raise KerberosException("invalid principal syntax")
@@ -85,7 +85,7 @@ If the value contains no realm, then default_realm wil
         elif len(value) == 2:
             self.components = value[0]
             self.realm = value[-1]
-            if isinstance(self.components, basestring):
+            if isinstance(self.components, str):
                 self.components = [self.components]
         elif len(value) >= 2:
             self.components = value[0:-1]
@@ -97,7 +97,7 @@ If the value contains no realm, then default_realm wil
             self.type = type
 
     def __eq__(self, other):
-        if isinstance(other, basestring):
+        if isinstance(other, str):
             other = Principal(other)
 
         return (self.type == constants.PrincipalNameType.NT_UNKNOWN.value or \
@@ -255,15 +255,15 @@ class KerberosTime(object):
 
 if __name__ == '__main__':
     # TODO marc: turn this into a real test
-    print Principal("marc")
-    print Principal(("marc", None))
-    print Principal((("marc",), None))
-    print Principal("marc@ATHENA.MIT.EDU")
-    print Principal("marc", default_realm="ATHENA.MIT.EDU")
-    print Principal("marc@ATHENA.MIT.EDU", default_realm="EXAMPLE.COM")
-    print Principal(("marc", "ATHENA.MIT.EDU"))
-    print Principal((("marc"), "ATHENA.MIT.EDU"))
-    print Principal("marc/root")
-    print Principal(("marc", "root", "ATHENA.MIT.EDU"))
-    print Principal((("marc", "root"), "ATHENA.MIT.EDU"))
-    print Principal("marc\\/root")
+    print(Principal("marc"))
+    print(Principal(("marc", None)))
+    print(Principal((("marc",), None)))
+    print(Principal("marc@ATHENA.MIT.EDU"))
+    print(Principal("marc", default_realm="ATHENA.MIT.EDU"))
+    print(Principal("marc@ATHENA.MIT.EDU", default_realm="EXAMPLE.COM"))
+    print(Principal(("marc", "ATHENA.MIT.EDU")))
+    print(Principal((("marc"), "ATHENA.MIT.EDU")))
+    print(Principal("marc/root"))
+    print(Principal(("marc", "root", "ATHENA.MIT.EDU")))
+    print(Principal((("marc", "root"), "ATHENA.MIT.EDU")))
+    print(Principal("marc\\/root"))
--- impacket/ldap/ldapasn1.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/ldap/ldapasn1.py
@@ -575,7 +575,7 @@ class SDFlagsControlValue(univ.Sequence):
     )
 
 class SDFlagsControl(Control):
-    def __init__(self, criticality=None, flags=0x00000007L, **kwargs):
+    def __init__(self, criticality=None, flags=0x00000007, **kwargs):
         Control.__init__(self, **kwargs)
         self['controlType'] = CONTROL_SDFLAGS
         if criticality is not None:
--- impacket/ldap/ldaptypes.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/ldap/ldaptypes.py
@@ -189,17 +189,17 @@ https://msdn.microsoft.com/en-us/library/cc230294.aspx
 """
 class ACCESS_MASK(Structure):
     # Flag constants
-    GENERIC_READ            = 0x80000000L
-    GENERIC_WRITE           = 0x04000000L
-    GENERIC_EXECUTE         = 0x20000000L
-    GENERIC_ALL             = 0x10000000L
-    MAXIMUM_ALLOWED         = 0x02000000L
-    ACCESS_SYSTEM_SECURITY  = 0x01000000L
-    SYNCHRONIZE             = 0x00100000L
-    WRITE_OWNER             = 0x00080000L
-    WRITE_DACL              = 0x00040000L
-    READ_CONTROL            = 0x00020000L
-    DELETE                  = 0x00010000L
+    GENERIC_READ            = 0x80000000
+    GENERIC_WRITE           = 0x04000000
+    GENERIC_EXECUTE         = 0x20000000
+    GENERIC_ALL             = 0x10000000
+    MAXIMUM_ALLOWED         = 0x02000000
+    ACCESS_SYSTEM_SECURITY  = 0x01000000
+    SYNCHRONIZE             = 0x00100000
+    WRITE_OWNER             = 0x00080000
+    WRITE_DACL              = 0x00040000
+    READ_CONTROL            = 0x00020000
+    DELETE                  = 0x00010000
 
     structure = (
         ('Mask', '<L'),
@@ -460,7 +460,7 @@ class ACL(Structure):
         for i in range(self['AceCount']):
             # If we don't have any data left, return
             if len(self['Data']) == 0:
-                raise Exception, "ACL header indicated there are more ACLs to unpack, but there is no more data"
+                raise Exception("ACL header indicated there are more ACLs to unpack, but there is no more data")
             ace = ACE(data=self['Data'])
             self.aces.append(ace)
             self['Data'] = self['Data'][ace['AceSize']:]
--- impacket/mqtt.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/mqtt.py
@@ -270,7 +270,7 @@ class MQTTConnection:
             try:
                 message = MQTT_Packet(data)
                 remaining = data[len(message):]
-            except Exception, e:
+            except Exception as e:
                 # We need more data
                 remaining = data + self._socket.recv(REQUEST_SIZE)
             else:
@@ -347,7 +347,7 @@ class MQTTConnection:
 
         try:
             data = self.sendReceive(subscribePacket)[0]
-        except Exception, e:
+        except Exception as e:
             raise MQTTSessionError(errorString=str(e))
 
         subAck = MQTT_SubscribeACK(str(data))
@@ -410,7 +410,7 @@ if __name__ == '__main__':
         packets = mqtt.recv()
         for packet in packets:
             publish = MQTT_Publish(str(packet))
-            print '%s -> %s' % (publish['Topic']['Name'], publish['Message'])
+            print('%s -> %s' % (publish['Topic']['Name'], publish['Message']))
 
     mqtt.disconnect()
 
--- impacket/ntlm.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/ntlm.py
@@ -206,7 +206,7 @@ class AV_PAIRS:
         self.fields[key] = (len(value),value)
 
     def __getitem__(self, key):
-        if self.fields.has_key(key):
+        if key in self.fields:
            return self.fields[key]
         return None
 
@@ -232,14 +232,14 @@ class AV_PAIRS:
             tInfo = tInfo[length:]
 
     def dump(self):
-        for i in self.fields.keys():
-            print "%s: {%r}" % (i,self[i])
+        for i in list(self.fields.keys()):
+            print("%s: {%r}" % (i,self[i]))
 
     def getData(self):
-        if self.fields.has_key(NTLMSSP_AV_EOL):
+        if NTLMSSP_AV_EOL in self.fields:
             del self.fields[NTLMSSP_AV_EOL]
         ans = ''
-        for i in self.fields.keys():
+        for i in list(self.fields.keys()):
             ans+= struct.pack('<HH', i, self[i][0])
             ans+= self[i][1]
  
@@ -619,7 +619,7 @@ def getNTLMSSPType3(type1, type2, user, password, doma
     # method we will create a valid ChallengeResponse
     ntlmChallengeResponse = NTLMAuthChallengeResponse(user, password, ntlmChallenge['challenge'])
 
-    clientChallenge = "".join([random.choice(string.digits+string.letters) for _ in xrange(8)])
+    clientChallenge = "".join([random.choice(string.digits+string.letters) for _ in range(8)])
 
     serverName = ntlmChallenge['TargetInfoFields']
 
@@ -658,7 +658,7 @@ def getNTLMSSPType3(type1, type2, user, password, doma
     if ntlmChallenge['flags'] & NTLMSSP_NEGOTIATE_KEY_EXCH:
        # not exactly what I call random tho :\
        # exportedSessionKey = this is the key we should use to sign
-       exportedSessionKey = "".join([random.choice(string.digits+string.letters) for _ in xrange(16)])
+       exportedSessionKey = "".join([random.choice(string.digits+string.letters) for _ in range(16)])
        #exportedSessionKey = "A"*16
        #print "keyExchangeKey %r" % keyExchangeKey
        # Let's generate the right session key based on the challenge flags
@@ -751,7 +751,7 @@ def LMOWFv1(password, lmhash = '', nthash=''):
 def compute_nthash(password):
     # This is done according to Samba's encryption specification (docs/html/ENCRYPTION.html)
     try:
-        password = unicode(password).encode('utf_16le')
+        password = str(password).encode('utf_16le')
     except UnicodeDecodeError:
         import sys
         password = password.decode(sys.getfilesystemencoding()).encode('utf_16le')
--- impacket/smb.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/smb.py
@@ -60,9 +60,9 @@ unicode_support = 0
 unicode_convert = 1
 
 try:
-    from cStringIO import StringIO
+    from io import StringIO
 except ImportError:
-    from StringIO import StringIO
+    from io import StringIO
 
 # Dialect for SMB1
 SMB_DIALECT = 'NT LM 0.12'
@@ -634,9 +634,9 @@ class SharedFile:
     @staticmethod
     def __convert_smbtime(t):
         x = t >> 32
-        y = t & 0xffffffffL
+        y = t & 0xffffffff
         geo_cal_offset = 11644473600.0  # = 369.0 * 365.25 * 24 * 60 * 60 - (3.0 * 24 * 60 * 60 + 6.0 * 60 * 60)
-        return (x * 4.0 * (1 << 30) + (y & 0xfff00000L)) * 1.0e-7 - geo_cal_offset
+        return (x * 4.0 * (1 << 30) + (y & 0xfff00000)) * 1.0e-7 - geo_cal_offset
 
 
 # Contain information about a SMB machine
@@ -681,12 +681,12 @@ class NewSMBPacket(Structure):
     def __init__(self, **kargs):
         Structure.__init__(self, **kargs)
 
-        if self.fields.has_key('Flags2') is False:
+        if ('Flags2' in self.fields) is False:
              self['Flags2'] = 0
-        if self.fields.has_key('Flags1') is False:
+        if ('Flags1' in self.fields) is False:
              self['Flags1'] = 0
 
-        if not kargs.has_key('data'):
+        if 'data' not in kargs:
             self['Data'] = []
 
     def addCommand(self, command):
@@ -714,9 +714,9 @@ class NewSMBPacket(Structure):
                 return 1
             elif self.isMoreProcessingRequired():
                 return 1
-            raise SessionError, ("SMB Library Error", self['ErrorClass'] + (self['_reserved'] << 8), self['ErrorCode'], self['Flags2'] & SMB.FLAGS2_NT_STATUS, self)
+            raise SessionError("SMB Library Error", self['ErrorClass'] + (self['_reserved'] << 8), self['ErrorCode'], self['Flags2'] & SMB.FLAGS2_NT_STATUS, self)
         else:
-            raise UnsupportedFeature, ("Unexpected answer from server: Got %d, Expected %d" % (self['Command'], cmd))
+            raise UnsupportedFeature("Unexpected answer from server: Got %d, Expected %d" % (self['Command'], cmd))
 
 
 class SMBCommand(Structure):
@@ -2582,7 +2582,7 @@ class SMB:
                     if s.get_error_class() == 0x00 and s.get_error_code() == 0x00:
                         return 1
                     else:
-                        raise SessionError, ( "SMB Library Error", s.get_error_class()+ (s.get_reserved() << 8), s.get_error_code() , s.get_flags2() & SMB.FLAGS2_NT_STATUS )
+                        raise SessionError( "SMB Library Error", s.get_error_class()+ (s.get_reserved() << 8), s.get_error_code() , s.get_flags2() & SMB.FLAGS2_NT_STATUS)
                 else:
                     break
         return 0
@@ -2615,7 +2615,7 @@ class SMB:
                         self.__server_name = self._dialects_data['ServerName']
 
                     if self._dialects_parameters['DialectIndex'] == 0xffff:
-                        raise UnsupportedFeature,"Remote server does not know NT LM 0.12"
+                        raise UnsupportedFeature("Remote server does not know NT LM 0.12")
                     return 1
             else:
                 return 0
@@ -2769,7 +2769,7 @@ class SMB:
         self._SigningSessionKey = key
 
     def get_encryption_key(self):
-        if self._dialects_data.fields.has_key('Challenge'):
+        if 'Challenge' in self._dialects_data.fields:
             return self._dialects_data['Challenge']
         else:
             return None
@@ -3275,7 +3275,7 @@ class SMB:
                        pass
 
             # Parse Version to know the target Operating system name. Not provided elsewhere anymore
-            if ntlmChallenge.fields.has_key('Version'):
+            if 'Version' in ntlmChallenge.fields:
                 version = ntlmChallenge['Version']
 
                 if len(version) >= 4:
--- impacket/smb3.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/smb3.py
@@ -244,13 +244,13 @@ class SMB3:
             self.negotiateSession(preferredDialect, negSessionResponse)
 
     def printStatus(self):
-        print "CONNECTION"
-        for i in self._Connection.items():
-            print "%-40s : %s" % i
-        print
-        print "SESSION"
-        for i in self._Session.items():
-            print "%-40s : %s" % i
+        print("CONNECTION")
+        for i in list(self._Connection.items()):
+            print("%-40s : %s" % i)
+        print()
+        print("SESSION")
+        for i in list(self._Session.items()):
+            print("%-40s : %s" % i)
 
     def getKerberos(self):
         return self._doKerberos
@@ -335,7 +335,7 @@ class SMB3:
         packet['SessionID'] = self._Session['SessionID']
 
         # Default the credit charge to 1 unless set by the caller
-        if packet.fields.has_key('CreditCharge') is False:
+        if ('CreditCharge' in packet.fields) is False:
             packet['CreditCharge'] = 1
 
         # Standard credit request after negotiating protocol
@@ -345,7 +345,7 @@ class SMB3:
         messageId = packet['MessageID']
 
         if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:
-            if packet['TreeID'] > 0 and self._Session['TreeConnectTable'].has_key(packet['TreeID']) is True:
+            if packet['TreeID'] > 0 and (packet['TreeID'] in self._Session['TreeConnectTable']) is True:
                 if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:
                     packet['Flags'] = SMB2_FLAGS_SIGNED
                     self.signSMB(packet)
@@ -377,7 +377,7 @@ class SMB3:
 
     def recvSMB(self, packetID = None):
         # First, verify we don't have the packet already
-        if self._Connection['OutstandingResponses'].has_key(packetID):
+        if packetID in self._Connection['OutstandingResponses']:
             return self._Connection['OutstandingResponses'].pop(packetID) 
 
         data = self._NetBIOSSession.recv_packet(self._timeout) 
@@ -772,7 +772,7 @@ class SMB3:
                        pass 
 
                 # Parse Version to know the target Operating system name. Not provided elsewhere anymore
-                if ntlmChallenge.fields.has_key('Version'):
+                if 'Version' in ntlmChallenge.fields:
                     version = ntlmChallenge['Version']
 
                     if len(version) >= 4:
@@ -838,7 +838,7 @@ class SMB3:
 
         #print self._Session['TreeConnectTable']
         share = share.split('\\')[-1]
-        if self._Session['TreeConnectTable'].has_key(share):
+        if share in self._Session['TreeConnectTable']:
             # Already connected, no need to reconnect
             treeEntry =  self._Session['TreeConnectTable'][share]
             treeEntry['NumberOfUses'] += 1
@@ -890,10 +890,10 @@ class SMB3:
            return packet['TreeID'] 
 
     def disconnectTree(self, treeId):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
-        if self._Session['TreeConnectTable'].has_key(treeId):
+        if treeId in self._Session['TreeConnectTable']:
             # More than 1 use? descrease it and return, if not, send the packet
             if self._Session['TreeConnectTable'][treeId]['NumberOfUses'] > 1:
                 treeEntry =  self._Session['TreeConnectTable'][treeId]
@@ -913,7 +913,7 @@ class SMB3:
             del(self._Session['TreeConnectTable'][shareName])
             del(self._Session['TreeConnectTable'][treeId])
             filesIDToBeRemoved = []
-            for fileID in self._Session['OpenTable'].keys():
+            for fileID in list(self._Session['OpenTable'].keys()):
                 if self._Session['OpenTable'][fileID]['TreeConnect'] == treeId:
                     filesIDToBeRemoved.append(fileID)
             for fileIDToBeRemoved in filesIDToBeRemoved:
@@ -921,7 +921,7 @@ class SMB3:
             return True
 
     def create(self, treeId, fileName, desiredAccess, shareMode, creationOptions, creationDisposition, fileAttributes, impersonationLevel = SMB2_IL_IMPERSONATION, securityFlags = 0, oplockLevel = SMB2_OPLOCK_LEVEL_NONE, createContexts = None):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         fileName = string.replace(fileName, '/', '\\')
@@ -944,7 +944,7 @@ class SMB3:
            # Is this file NOT on the root directory?
            if len(fileName.split('\\')) > 2:
                parentDir = ntpath.dirname(pathName)
-           if self.GlobalFileTable.has_key(parentDir):
+           if parentDir in self.GlobalFileTable:
                LOG.critical("Don't know what to do now! :-o")
                raise
            else:
@@ -1016,9 +1016,9 @@ class SMB3:
             return str(createResponse['FileID'])
 
     def close(self, treeId, fileId):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
-        if self._Session['OpenTable'].has_key(fileId) is False:
+        if (fileId in self._Session['OpenTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1047,9 +1047,9 @@ class SMB3:
         # This function should NOT be used for reading files directly, but another higher
         # level function should be used that will break the read into smaller pieces
 
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
-        if self._Session['OpenTable'].has_key(fileId) is False:
+        if (fileId in self._Session['OpenTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1089,9 +1089,9 @@ class SMB3:
         # This function should NOT be used for writing directly to files, but another higher
         # level function should be used that will break the writes into smaller pieces
 
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
-        if self._Session['OpenTable'].has_key(fileId) is False:
+        if (fileId in self._Session['OpenTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1130,9 +1130,9 @@ class SMB3:
             return bytesWritten
 
     def queryDirectory(self, treeId, fileId, searchString = '*', resumeIndex = 0, informationClass = FILENAMES_INFORMATION, maxBufferSize = None, enumRestart = False, singleEntry = False):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
-        if self._Session['OpenTable'].has_key(fileId) is False:
+        if (fileId in self._Session['OpenTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1183,12 +1183,12 @@ class SMB3:
         self.sendSMB(packet)
 
     def ioctl(self, treeId, fileId = None, ctlCode = -1, flags = 0, inputBlob = '',  maxInputResponse = None, maxOutputResponse = None, waitAnswer = 1):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
         if fileId is None:
             fileId = '\xff'*16
         else:
-            if self._Session['OpenTable'].has_key(fileId) is False:
+            if (fileId in self._Session['OpenTable']) is False:
                 raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1224,9 +1224,9 @@ class SMB3:
             return smbIoctlResponse['Buffer']
 
     def flush(self,treeId, fileId):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
-        if self._Session['OpenTable'].has_key(fileId) is False:
+        if (fileId in self._Session['OpenTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1245,9 +1245,9 @@ class SMB3:
             return True
 
     def lock(self, treeId, fileId, locks, lockSequence = 0):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
-        if self._Session['OpenTable'].has_key(fileId) is False:
+        if (fileId in self._Session['OpenTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1307,9 +1307,9 @@ class SMB3:
             return True
 
     def queryInfo(self, treeId, fileId, inputBlob = '', infoType = SMB2_0_INFO_FILE, fileInfoClass = SMB2_FILE_STANDARD_INFO, additionalInformation = 0, flags = 0 ):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
-        if self._Session['OpenTable'].has_key(fileId) is False:
+        if (fileId in self._Session['OpenTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1339,9 +1339,9 @@ class SMB3:
             return queryResponse['Buffer']
 
     def setInfo(self, treeId, fileId, inputBlob = '', infoType = SMB2_0_INFO_FILE, fileInfoClass = SMB2_FILE_STANDARD_INFO, additionalInformation = 0 ):
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
-        if self._Session['OpenTable'].has_key(fileId) is False:
+        if (fileId in self._Session['OpenTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
 
         packet = self.SMB_PACKET()
@@ -1444,7 +1444,7 @@ class SMB3:
                         files.append(smb.SharedFile(fileInfo['CreationTime'],fileInfo['LastAccessTime'],fileInfo['LastChangeTime'],fileInfo['EndOfFile'],fileInfo['AllocationSize'],fileInfo['ExtFileAttributes'],fileInfo['FileName'].decode('utf-16le'), fileInfo['FileName'].decode('utf-16le')))
                         nextOffset = fileInfo['NextEntryOffset']
                         res = res[nextOffset:]
-                except SessionError, e:
+                except SessionError as e:
                     if (e.get_error_code()) != STATUS_NO_MORE_FILES:
                         raise
                     break 
@@ -1578,7 +1578,7 @@ class SMB3:
 
     def waitNamedPipe(self, treeId, pipename, timeout = 5):
         pipename = ntpath.basename(pipename)
-        if self._Session['TreeConnectTable'].has_key(treeId) is False:
+        if (treeId in self._Session['TreeConnectTable']) is False:
             raise SessionError(STATUS_INVALID_PARAMETER)
         if len(pipename) > 0xffff:
             raise SessionError(STATUS_INVALID_PARAMETER)
--- impacket/smbconnection.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/smbconnection.py
@@ -18,7 +18,7 @@ import string
 import socket
 
 from impacket import smb, smb3, nmb, nt_errors, LOG
-from smb3structs import *
+from .smb3structs import *
 
 
 # So the user doesn't need to import smb, the smb3 are already in here
@@ -261,7 +261,7 @@ class SMBConnection:
                 return self._SMBConnection.login(user, password, domain, lmhash, nthash, ntlmFallback)
             else:
                 return self._SMBConnection.login(user, password, domain, lmhash, nthash)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def kerberosLogin(self, user, password, domain='', lmhash='', nthash='', aesKey='', kdcHost=None, TGT=None,
@@ -337,9 +337,9 @@ class SMBConnection:
                                                               TGT, TGS)
                 return self._SMBConnection.kerberosLogin(user, password, domain, lmhash, nthash, aesKey, kdcHost, TGT,
                                                          TGS)
-            except (smb.SessionError, smb3.SessionError), e:
+            except (smb.SessionError, smb3.SessionError) as e:
                 raise SessionError(e.get_error_code(), e.get_error_packet())
-            except KerberosError, e:
+            except KerberosError as e:
                 if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
                     # We might face this if the target does not support AES
                     # So, if that's the case we'll force using RC4 by converting
@@ -357,13 +357,13 @@ class SMBConnection:
     def isGuestSession(self):
         try:
             return self._SMBConnection.isGuestSession()
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def logoff(self):
         try:
             return self._SMBConnection.logoff()
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
 
@@ -376,14 +376,14 @@ class SMBConnection:
                 share = '\\\\' + self.getRemoteHost() + '\\' + share
         try:
             return self._SMBConnection.connect_tree(share)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
 
     def disconnectTree(self, treeId):
         try:
             return self._SMBConnection.disconnect_tree(treeId)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
 
@@ -416,7 +416,7 @@ class SMBConnection:
 
         try:
             return self._SMBConnection.list_path(shareName, path, password)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def createFile(self, treeId, pathName, desiredAccess=GENERIC_ALL,
@@ -460,14 +460,14 @@ class SMBConnection:
 
             try:
                 return self._SMBConnection.nt_create_andx(treeId, pathName, cmd = ntCreate)
-            except (smb.SessionError, smb3.SessionError), e:
+            except (smb.SessionError, smb3.SessionError) as e:
                 raise SessionError(e.get_error_code(), e.get_error_packet())
         else:
             try:
                 return self._SMBConnection.create(treeId, pathName, desiredAccess, shareMode, creationOption,
                                                   creationDisposition, fileAttributes, impersonationLevel,
                                                   securityFlags, oplockLevel, createContexts)
-            except (smb.SessionError, smb3.SessionError), e:
+            except (smb.SessionError, smb3.SessionError) as e:
                 raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def openFile(self, treeId, pathName, desiredAccess=FILE_READ_DATA | FILE_WRITE_DATA, shareMode=FILE_SHARE_READ,
@@ -510,14 +510,14 @@ class SMBConnection:
 
             try:
                 return self._SMBConnection.nt_create_andx(treeId, pathName, cmd = ntCreate)
-            except (smb.SessionError, smb3.SessionError), e:
+            except (smb.SessionError, smb3.SessionError) as e:
                 raise SessionError(e.get_error_code(), e.get_error_packet())
         else:
             try:
                 return self._SMBConnection.create(treeId, pathName, desiredAccess, shareMode, creationOption,
                                                   creationDisposition, fileAttributes, impersonationLevel,
                                                   securityFlags, oplockLevel, createContexts)
-            except (smb.SessionError, smb3.SessionError), e:
+            except (smb.SessionError, smb3.SessionError) as e:
                 raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def writeFile(self, treeId, fileId, data, offset=0):
@@ -533,7 +533,7 @@ class SMBConnection:
         """
         try:
             return self._SMBConnection.writeFile(treeId, fileId, data, offset)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
 
@@ -560,7 +560,7 @@ class SMBConnection:
                 toRead = remainingBytesToRead
             try:
                 bytesRead = self._SMBConnection.read_andx(treeId, fileId, offset, toRead)
-            except (smb.SessionError, smb3.SessionError), e:
+            except (smb.SessionError, smb3.SessionError) as e:
                 if e.get_error_code() == nt_errors.STATUS_END_OF_FILE:
                     toRead = ''
                     break
@@ -593,7 +593,7 @@ class SMBConnection:
         """
         try:
             return self._SMBConnection.close(treeId, fileId)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def deleteFile(self, shareName, pathName):
@@ -608,7 +608,7 @@ class SMBConnection:
         """
         try:
             return self._SMBConnection.remove(shareName, pathName)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def queryInfo(self, treeId, fileId):
@@ -627,7 +627,7 @@ class SMBConnection:
             else:
                 res = self._SMBConnection.queryInfo(treeId, fileId)
             return smb.SMBQueryFileStandardInfo(res)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def createDirectory(self, shareName, pathName ):
@@ -642,7 +642,7 @@ class SMBConnection:
         """
         try:
             return self._SMBConnection.mkdir(shareName, pathName)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def deleteDirectory(self, shareName, pathName):
@@ -657,7 +657,7 @@ class SMBConnection:
         """
         try:
             return self._SMBConnection.rmdir(shareName, pathName)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def waitNamedPipe(self, treeId, pipeName, timeout = 5):
@@ -673,7 +673,7 @@ class SMBConnection:
         """
         try:
             return self._SMBConnection.waitNamedPipe(treeId, pipeName, timeout = timeout)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def transactNamedPipe(self, treeId, fileId, data, waitAnswer = True):
@@ -690,7 +690,7 @@ class SMBConnection:
         """
         try:
             return self._SMBConnection.TransactNamedPipe(treeId, fileId, data, waitAnswer = waitAnswer)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
 
@@ -703,7 +703,7 @@ class SMBConnection:
         """
         try:
             return self._SMBConnection.TransactNamedPipeRecv()
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def writeNamedPipe(self, treeId, fileId, data, waitAnswer = True):
@@ -723,7 +723,7 @@ class SMBConnection:
                 return self._SMBConnection.write_andx(treeId, fileId, data, wait_answer = waitAnswer, write_pipe_mode = True)
             else:
                 return self.writeFile(treeId, fileId, data, 0)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
 
@@ -741,7 +741,7 @@ class SMBConnection:
 
         try:
             return self.readFile(treeId, fileId, bytesToRead = bytesToRead, singleCall = True)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
 
@@ -762,7 +762,7 @@ class SMBConnection:
                 return self._SMBConnection.retr_file(shareName, pathName, callback)
             else:
                 return self._SMBConnection.retr_file(shareName, pathName, callback, shareAccessMode=shareAccessMode)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def putFile(self, shareName, pathName, callback, shareAccessMode = None):
@@ -782,7 +782,7 @@ class SMBConnection:
                 return self._SMBConnection.stor_file(shareName, pathName, callback)
             else:
                 return self._SMBConnection.stor_file(shareName, pathName, callback, shareAccessMode)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def rename(self, shareName, oldPath, newPath):
@@ -799,7 +799,7 @@ class SMBConnection:
 
         try:
             return self._SMBConnection.rename(shareName, oldPath, newPath)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def reconnect(self):
@@ -823,7 +823,7 @@ class SMBConnection:
     def setTimeout(self, timeout):
         try:
             return self._SMBConnection.set_timeout(timeout)
-        except (smb.SessionError, smb3.SessionError), e:
+        except (smb.SessionError, smb3.SessionError) as e:
             raise SessionError(e.get_error_code(), e.get_error_packet())
 
     def getSessionKey(self):
@@ -871,7 +871,7 @@ class SessionError(Exception):
         return nt_errors.ERROR_MESSAGES[self.error]
 
     def __str__( self ):
-        if nt_errors.ERROR_MESSAGES.has_key(self.error):
+        if self.error in nt_errors.ERROR_MESSAGES:
             return 'SMB SessionError: %s(%s)' % (nt_errors.ERROR_MESSAGES[self.error])
         else:
             return 'SMB SessionError: 0x%x' % self.error
--- impacket/smbserver.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/smbserver.py
@@ -20,14 +20,14 @@
 # [ ] Hence.. implement locking
 # estamos en la B
 
-from __future__ import with_statement
+
 import calendar
 import socket
 import time
 import datetime
 import struct
-import ConfigParser
-import SocketServer
+import configparser
+import socketserver
 import threading
 import logging
 import logging.config
@@ -144,7 +144,7 @@ def outputToJohnFormat(challenge, username, domain, lm
             else:
                 # NTLMv1
                 ret_value = {'hash_string':'%s::%s:%s:%s:%s' % (username, domain, hexlify(lmresponse), hexlify(ntresponse), hexlify(challenge)), 'hash_version':'ntlm'}
-        except Exception, e:
+        except Exception as e:
             LOG.error("outputToJohnFormat: %s" % e)
             pass
 
@@ -247,7 +247,7 @@ def openFile(path,fileName, accessMode, fileAttributes
         if sys.platform == 'win32':
             mode |= os.O_BINARY
         fid = os.open(pathName, mode)
-    except Exception, e:
+    except Exception as e:
         LOG.error("openFile: %s,%s" % (pathName, mode) ,e)
         fid = 0
         errorCode = STATUS_ACCESS_DENIED
@@ -256,7 +256,7 @@ def openFile(path,fileName, accessMode, fileAttributes
 
 def queryFsInformation(path, filename, level=0):
 
-    if isinstance(filename,unicode):
+    if isinstance(filename,str):
          encoding = 'utf-16le'
          flags    = smb.SMB.FLAGS2_UNICODE
     else:
@@ -311,7 +311,7 @@ def findFirst2(path, fileName, level, searchAttributes
      #print "FindFirs2 path:%s, filename:%s" % (path, fileName)
      fileName = os.path.normpath(fileName.replace('\\','/'))
      # Let's choose the right encoding depending on the request
-     if isinstance(fileName,unicode):
+     if isinstance(fileName,str):
          encoding = 'utf-16le'
          flags    = smb.SMB.FLAGS2_UNICODE
      else:
@@ -506,7 +506,7 @@ def queryPathInformation(path, filename, level):
     else:
         # NOT FOUND
         return None, STATUS_OBJECT_NAME_NOT_FOUND
-  except Exception, e:
+  except Exception as e:
       LOG.error('queryPathInfo: %s' % e)
       raise
 
@@ -550,7 +550,7 @@ class TRANSCommands:
                     # (beto) If offset == 0 it crashes explorer.exe on windows 7
                     entry['RemarkOffsetLow'] = 20 * len(shares) + len(tailData)
                     respData += entry.getData()
-                    if shares[i].has_key('comment'):
+                    if 'comment' in shares[i]:
                         tailData += shares[i]['comment'] + '\x00'
                     else:
                         tailData += '\x00'
@@ -575,7 +575,7 @@ class TRANSCommands:
             shareInfo['NetworkName'] = request['ShareName'].upper() + '\x00'
             shareInfo['Type']        = int(share['share type'])
             respData = shareInfo.getData()
-            if share.has_key('comment'):
+            if 'comment' in share:
                 shareInfo['RemarkOffsetLow'] = len(respData)
                 respData += share['comment'] + '\x00'
             respParameters['TotalBytesAvailable'] = len(respData)
@@ -602,7 +602,7 @@ class TRANSCommands:
         # Extract the FID
         fid = struct.unpack('<H', transParameters['Setup'][2:])[0]
 
-        if connData['OpenedFiles'].has_key(fid):
+        if fid in connData['OpenedFiles']:
             fileHandle = connData['OpenedFiles'][fid]['FileHandle']
             if fileHandle != PIPE_FILE_DESCRIPTOR:
                 os.write(fileHandle,data)
@@ -630,7 +630,7 @@ class TRANS2Commands:
         respData = ''
         errorCode = STATUS_SUCCESS
         setPathInfoParameters = smb.SMBSetPathInformation_Parameters(flags = recvPacket['Flags2'], data = parameters)
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
             path     = connData['ConnectedShares'][recvPacket['Tid']]['path']
             fileName = decodeSMBString(recvPacket['Flags2'], setPathInfoParameters['FileName'])
             fileName = os.path.normpath(fileName.replace('\\','/'))
@@ -683,8 +683,8 @@ class TRANS2Commands:
         errorCode = STATUS_SUCCESS
         setFileInfoParameters = smb.SMBSetFileInformation_Parameters(parameters)
 
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
-            if connData['OpenedFiles'].has_key(setFileInfoParameters['FID']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
+            if setFileInfoParameters['FID'] in connData['OpenedFiles']:
                 fileName = connData['OpenedFiles'][setFileInfoParameters['FID']]['FileName']
                 informationLevel = setFileInfoParameters['InformationLevel']
                 if informationLevel == smb.SMB_SET_FILE_DISPOSITION_INFO:
@@ -739,8 +739,8 @@ class TRANS2Commands:
 
         queryFileInfoParameters = smb.SMBQueryFileInformation_Parameters(parameters)
 
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
-            if connData['OpenedFiles'].has_key(queryFileInfoParameters['FID']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
+            if queryFileInfoParameters['FID'] in connData['OpenedFiles']:
                 fileName = connData['OpenedFiles'][queryFileInfoParameters['FID']]['FileName']
 
                 infoRecord, errorCode = queryFileInformation('', fileName, queryFileInfoParameters['InformationLevel'])
@@ -768,11 +768,11 @@ class TRANS2Commands:
 
         queryPathInfoParameters = smb.SMBQueryPathInformation_Parameters(flags = recvPacket['Flags2'], data = parameters)
 
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
             path = connData['ConnectedShares'][recvPacket['Tid']]['path']
             try:
                infoRecord, errorCode = queryPathInformation(path, decodeSMBString(recvPacket['Flags2'], queryPathInfoParameters['FileName']), queryPathInfoParameters['InformationLevel'])
-            except Exception, e:
+            except Exception as e:
                smbServer.log("queryPathInformation: %s" % e,logging.ERROR)
 
             if infoRecord is not None:
@@ -790,7 +790,7 @@ class TRANS2Commands:
         connData = smbServer.getConnectionData(connId)
         errorCode = 0
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
             data = queryFsInformation(connData['ConnectedShares'][recvPacket['Tid']]['path'], '', struct.unpack('<H',parameters)[0])
 
         smbServer.setConnectionData(connId, connData)
@@ -808,8 +808,8 @@ class TRANS2Commands:
         findNext2Parameters = smb.SMBFindNext2_Parameters(flags = recvPacket['Flags2'], data = parameters)
 
         sid = findNext2Parameters['SID']
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
-            if connData['SIDs'].has_key(sid):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
+            if sid in connData['SIDs']:
                 searchResult = connData['SIDs'][sid]
                 respParameters = smb.SMBFindNext2Response_Parameters()
                 endOfSearch = 1
@@ -854,7 +854,7 @@ class TRANS2Commands:
         respData = ''
         findFirst2Parameters = smb.SMBFindFirst2_Parameters( recvPacket['Flags2'], data = parameters)
 
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
             path = connData['ConnectedShares'][recvPacket['Tid']]['path']
 
             searchResult, searchCount, errorCode = findFirst2(path, 
@@ -878,7 +878,7 @@ class TRANS2Commands:
                     if len(connData['SIDs']) == 0:
                        sid = 1
                     else:
-                       sid = connData['SIDs'].keys()[-1] + 1
+                       sid = list(connData['SIDs'].keys())[-1] + 1
                     # Store the remaining search results in the ConnData SID
                     connData['SIDs'][sid] = searchResult[i[0]:]
                     respParameters['LastNameOffset'] = totalData
@@ -945,7 +945,7 @@ class SMBCommands:
             else:
                 command = struct.unpack('<H', transParameters['Setup'][:2])[0]
             
-            if transCommands.has_key(command):
+            if command in transCommands:
                # Call the TRANS subcommand
                setup = ''
                parameters = ''
@@ -957,7 +957,7 @@ class SMBCommands:
                                 transData['Trans_Parameters'], 
                                 transData['Trans_Data'],
                                 transParameters['MaxDataCount'])
-               except Exception, e:
+               except Exception as e:
                    #print 'Transaction: %s' % e,e
                    smbServer.log('Transaction: (%r,%s)' % (command, e), logging.ERROR)
                    errorCode = STATUS_ACCESS_DENIED
@@ -1082,7 +1082,7 @@ class SMBCommands:
 
             # Call the handler for this TRANSACTION
             command = NTTransParameters['Function']
-            if transCommands.has_key(command):
+            if command in transCommands:
                # Call the NT TRANS subcommand
                setup = ''
                parameters = ''
@@ -1094,7 +1094,7 @@ class SMBCommands:
                                 NTTransData['NT_Trans_Parameters'], 
                                 NTTransData['NT_Trans_Data'],
                                 NTTransParameters['MaxDataCount'])
-               except Exception, e:
+               except Exception as e:
                    smbServer.log('NTTransaction: (0x%x,%s)' % (command, e), logging.ERROR)
                    errorCode = STATUS_ACCESS_DENIED
                    #raise
@@ -1221,7 +1221,7 @@ class SMBCommands:
 
             # Call the handler for this TRANSACTION
             command = struct.unpack('<H', trans2Parameters['Setup'])[0]
-            if transCommands.has_key(command):
+            if command in transCommands:
                # Call the TRANS2 subcommand
                try:
                    setup, parameters, data, errorCode = transCommands[command](connId,
@@ -1230,7 +1230,7 @@ class SMBCommands:
                                 trans2Data['Trans_Parameters'], 
                                 trans2Data['Trans_Data'],
                                 trans2Parameters['MaxDataCount'])
-               except Exception, e:
+               except Exception as e:
                    smbServer.log('Transaction2: (0x%x,%s)' % (command, e), logging.ERROR)
                    #import traceback
                    #traceback.print_exc()
@@ -1346,7 +1346,7 @@ class SMBCommands:
 
         comClose =  smb.SMBClose_Parameters(SMBCommand['Parameters'])
 
-        if connData['OpenedFiles'].has_key(comClose['FID']):
+        if comClose['FID'] in connData['OpenedFiles']:
              errorCode = STATUS_SUCCESS
              fileHandle = connData['OpenedFiles'][comClose['FID']]['FileHandle']
              try:
@@ -1354,7 +1354,7 @@ class SMBCommands:
                      connData['OpenedFiles'][comClose['FID']]['Socket'].close()
                  elif fileHandle != VOID_FILE_DESCRIPTOR:
                      os.close(fileHandle)
-             except Exception, e:
+             except Exception as e:
                  smbServer.log("comClose %s" % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
              else:
@@ -1362,7 +1362,7 @@ class SMBCommands:
                  if connData['OpenedFiles'][comClose['FID']]['DeleteOnClose'] is True:
                      try:
                          os.remove(connData['OpenedFiles'][comClose['FID']]['FileName'])
-                     except Exception, e:
+                     except Exception as e:
                          smbServer.log("comClose %s" % e, logging.ERROR)
                          errorCode = STATUS_ACCESS_DENIED
                  del(connData['OpenedFiles'][comClose['FID']])
@@ -1390,7 +1390,7 @@ class SMBCommands:
         comWriteParameters =  smb.SMBWrite_Parameters(SMBCommand['Parameters'])
         comWriteData = smb.SMBWrite_Data(SMBCommand['Data'])
 
-        if connData['OpenedFiles'].has_key(comWriteParameters['Fid']):
+        if comWriteParameters['Fid'] in connData['OpenedFiles']:
              fileHandle = connData['OpenedFiles'][comWriteParameters['Fid']]['FileHandle']
              errorCode = STATUS_SUCCESS
              try:
@@ -1404,7 +1404,7 @@ class SMBCommands:
                      sock = connData['OpenedFiles'][comWriteParameters['Fid']]['Socket']
                      sock.send(comWriteData['Data'])
                  respParameters['Count']    = comWriteParameters['Count']
-             except Exception, e:
+             except Exception as e:
                  smbServer.log('smbComWrite: %s' % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -1431,12 +1431,12 @@ class SMBCommands:
 
         comFlush =  smb.SMBFlush_Parameters(SMBCommand['Parameters'])
 
-        if connData['OpenedFiles'].has_key(comFlush['FID']):
+        if comFlush['FID'] in connData['OpenedFiles']:
              errorCode = STATUS_SUCCESS
              fileHandle = connData['OpenedFiles'][comFlush['FID']]['FileHandle']
              try:
                  os.fsync(fileHandle)
-             except Exception, e:
+             except Exception as e:
                  smbServer.log("comFlush %s" % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -1464,7 +1464,7 @@ class SMBCommands:
         comCreateDirectoryData=  smb.SMBCreateDirectory_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])
 
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
              errorCode = STATUS_SUCCESS
              path = connData['ConnectedShares'][recvPacket['Tid']]['path']
              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comCreateDirectoryData['DirectoryName']).replace('\\','/'))
@@ -1481,7 +1481,7 @@ class SMBCommands:
              else:
                  try:
                      os.mkdir(pathName)
-                 except Exception, e:
+                 except Exception as e:
                      smbServer.log("smbComCreateDirectory: %s" % e, logging.ERROR)
                      errorCode = STATUS_ACCESS_DENIED
         else:
@@ -1508,7 +1508,7 @@ class SMBCommands:
 
         comRenameData      =  smb.SMBRename_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
              errorCode = STATUS_SUCCESS
              path = connData['ConnectedShares'][recvPacket['Tid']]['path']
              oldFileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comRenameData['OldFileName']).replace('\\','/'))
@@ -1530,7 +1530,7 @@ class SMBCommands:
              else:
                  try:
                      os.rename(oldPathName,newPathName)
-                 except OSError, e:
+                 except OSError as e:
                      smbServer.log("smbComRename: %s" % e, logging.ERROR)
                      errorCode = STATUS_ACCESS_DENIED
         else:
@@ -1558,7 +1558,7 @@ class SMBCommands:
         comDeleteData         =  smb.SMBDelete_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])
 
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
              errorCode = STATUS_SUCCESS
              path = connData['ConnectedShares'][recvPacket['Tid']]['path']
              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comDeleteData['FileName']).replace('\\','/'))
@@ -1574,7 +1574,7 @@ class SMBCommands:
              else:
                  try:
                      os.remove(pathName)
-                 except OSError, e:
+                 except OSError as e:
                      smbServer.log("smbComDelete: %s" % e, logging.ERROR)
                      errorCode = STATUS_ACCESS_DENIED
         else:
@@ -1602,7 +1602,7 @@ class SMBCommands:
         comDeleteDirectoryData=  smb.SMBDeleteDirectory_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])
 
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
              errorCode = STATUS_SUCCESS
              path = connData['ConnectedShares'][recvPacket['Tid']]['path']
              fileName = os.path.normpath(decodeSMBString(recvPacket['Flags2'],comDeleteDirectoryData['DirectoryName']).replace('\\','/'))
@@ -1618,7 +1618,7 @@ class SMBCommands:
              else:
                  try:
                      os.rmdir(pathName)
-                 except OSError, e:
+                 except OSError as e:
                      smbServer.log("smbComDeleteDirectory: %s" % e,logging.ERROR)
                      if e.errno == errno.ENOTEMPTY:
                          errorCode = STATUS_DIRECTORY_NOT_EMPTY
@@ -1657,13 +1657,13 @@ class SMBCommands:
         writeAndXData.fromString(SMBCommand['Data'])
         
 
-        if connData['OpenedFiles'].has_key(writeAndX['Fid']):
+        if writeAndX['Fid'] in connData['OpenedFiles']:
              fileHandle = connData['OpenedFiles'][writeAndX['Fid']]['FileHandle']
              errorCode = STATUS_SUCCESS
              try:
                  if fileHandle != PIPE_FILE_DESCRIPTOR:
                      offset = writeAndX['Offset']
-                     if writeAndX.fields.has_key('HighOffset'):
+                     if 'HighOffset' in writeAndX.fields:
                          offset += (writeAndX['HighOffset'] << 32)
                      # If we're trying to write past the file end we just skip the write call (Vista does this)
                      if os.lseek(fileHandle, 0, 2) >= offset:
@@ -1675,7 +1675,7 @@ class SMBCommands:
 
                  respParameters['Count']    = writeAndX['DataLength']
                  respParameters['Available']= 0xff
-             except Exception, e:
+             except Exception as e:
                  smbServer.log('smbComWriteAndx: %s' % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -1701,7 +1701,7 @@ class SMBCommands:
 
         comReadParameters =  smb.SMBRead_Parameters(SMBCommand['Parameters'])
 
-        if connData['OpenedFiles'].has_key(comReadParameters['Fid']):
+        if comReadParameters['Fid'] in connData['OpenedFiles']:
              fileHandle = connData['OpenedFiles'][comReadParameters['Fid']]['FileHandle']
              errorCode = STATUS_SUCCESS
              try:
@@ -1715,7 +1715,7 @@ class SMBCommands:
                  respParameters['Count']    = len(content)
                  respData['DataLength']     = len(content)
                  respData['Data']           = content
-             except Exception, e:
+             except Exception as e:
                  smbServer.log('smbComRead: %s ' % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -1744,13 +1744,13 @@ class SMBCommands:
         else:
             readAndX =  smb.SMBReadAndX_Parameters(SMBCommand['Parameters'])
 
-        if connData['OpenedFiles'].has_key(readAndX['Fid']):
+        if readAndX['Fid'] in connData['OpenedFiles']:
              fileHandle = connData['OpenedFiles'][readAndX['Fid']]['FileHandle']
              errorCode = 0
              try:
                  if fileHandle != PIPE_FILE_DESCRIPTOR:
                      offset = readAndX['Offset']
-                     if readAndX.fields.has_key('HighOffset'):
+                     if 'HighOffset' in readAndX.fields:
                          offset += (readAndX['HighOffset'] << 32)
                      os.lseek(fileHandle,offset,0)
                      content = os.read(fileHandle,readAndX['MaxCount'])
@@ -1762,7 +1762,7 @@ class SMBCommands:
                  respParameters['DataOffset']   = 59
                  respParameters['DataCount_Hi'] = 0
                  respData = content
-             except Exception, e:
+             except Exception as e:
                  smbServer.log('smbComReadAndX: %s ' % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -1789,7 +1789,7 @@ class SMBCommands:
         queryInformation= smb.SMBQueryInformation_Data(flags = recvPacket['Flags2'], data = SMBCommand['Data'])
 
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
             fileSize, lastWriteTime, fileAttributes = queryFsInformation(
                 connData['ConnectedShares'][recvPacket['Tid']]['path'], 
                 decodeSMBString(recvPacket['Flags2'],queryInformation['FileName']))
@@ -1819,7 +1819,7 @@ class SMBCommands:
         respData       = ''
 
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
             totalUnits, freeUnits = queryDiskInformation(
                         connData['ConnectedShares'][recvPacket['Tid']]['path'])
 
@@ -1871,7 +1871,7 @@ class SMBCommands:
         respParameters = ''
         respData = ''
 
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
             smbServer.log("Disconnecting Share(%d:%s)" % (recvPacket['Tid'],connData['ConnectedShares'][recvPacket['Tid']]['shareName']))
             del(connData['ConnectedShares'][recvPacket['Tid']])
             errorCode = STATUS_SUCCESS
@@ -1919,7 +1919,7 @@ class SMBCommands:
 
         queryInformation2 = smb.SMBQueryInformation2_Parameters(SMBCommand['Parameters'])
         errorCode = 0xFF
-        if connData['OpenedFiles'].has_key(queryInformation2['Fid']):
+        if queryInformation2['Fid'] in connData['OpenedFiles']:
              errorCode = STATUS_SUCCESS
              pathName = connData['OpenedFiles'][queryInformation2['Fid']]['FileName']
              try:
@@ -1938,7 +1938,7 @@ class SMBCommands:
                  if os.path.isfile(pathName):
                      attribs = smb.SMB_FILE_ATTRIBUTE_NORMAL
                  respParameters['FileAttributes'] = attribs
-             except Exception, e:
+             except Exception as e:
                  smbServer.log('smbComQueryInformation2 %s' % e,logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
 
@@ -1969,14 +1969,14 @@ class SMBCommands:
         #    respParameters['VolumeGUID'] = '\x00'
 
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
              # If we have a rootFid, the path is relative to that fid
              errorCode = STATUS_SUCCESS
              if ntCreateAndXParameters['RootFid'] > 0:
                  path = connData['OpenedFiles'][ntCreateAndXParameters['RootFid']]['FileName']
                  LOG.debug("RootFid present %s!" % path)
              else:
-                 if connData['ConnectedShares'][recvPacket['Tid']].has_key('path'):
+                 if 'path' in connData['ConnectedShares'][recvPacket['Tid']]:
                      path = connData['ConnectedShares'][recvPacket['Tid']]['path']
                  else:
                      path = 'NONE'
@@ -2012,7 +2012,7 @@ class SMBCommands:
                  else:
                      mode |= os.O_CREAT
              elif createDisposition & smb.FILE_OPEN == smb.FILE_OPEN:
-                 if os.path.exists(pathName) is not True and smbServer.getRegisteredNamedPipes().has_key(unicode(pathName)) is not True:
+                 if os.path.exists(pathName) is not True and (str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:
                      errorCode = STATUS_NO_SUCH_FILE
 
              if errorCode == STATUS_SUCCESS:
@@ -2034,7 +2034,7 @@ class SMBCommands:
                              # Let's create the directory
                              os.mkdir(pathName)
                              mode = os.O_RDONLY
-                         except Exception, e:
+                         except Exception as e:
                              smbServer.log("NTCreateAndX: %s,%s,%s" % (pathName,mode,e),logging.ERROR)
                              errorCode = STATUS_ACCESS_DENIED
                  if createOptions & smb.FILE_NON_DIRECTORY_FILE == smb.FILE_NON_DIRECTORY_FILE:
@@ -2054,13 +2054,13 @@ class SMBCommands:
                          else:
                             if sys.platform == 'win32':
                                mode |= os.O_BINARY
-                            if smbServer.getRegisteredNamedPipes().has_key(unicode(pathName)):
+                            if str(pathName) in smbServer.getRegisteredNamedPipes():
                                 fid = PIPE_FILE_DESCRIPTOR
                                 sock = socket.socket()
-                                sock.connect(smbServer.getRegisteredNamedPipes()[unicode(pathName)])
+                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])
                             else:
                                 fid = os.open(pathName, mode)
-                     except Exception, e:
+                     except Exception as e:
                          smbServer.log("NTCreateAndX: %s,%s,%s" % (pathName,mode,e),logging.ERROR)
                          #print e
                          fid = 0
@@ -2073,7 +2073,7 @@ class SMBCommands:
             if len(connData['OpenedFiles']) == 0:
                fakefid = 1
             else:
-               fakefid = connData['OpenedFiles'].keys()[-1] + 1
+               fakefid = list(connData['OpenedFiles'].keys())[-1] + 1
             respParameters['Fid'] = fakefid
             respParameters['CreateAction'] = createDisposition
             if fid == PIPE_FILE_DESCRIPTOR:
@@ -2139,7 +2139,7 @@ class SMBCommands:
         openAndXData       = smb.SMBOpenAndX_Data( flags = recvPacket['Flags2'], data = SMBCommand['Data'])
 
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['Tid']):
+        if recvPacket['Tid'] in connData['ConnectedShares']:
              path = connData['ConnectedShares'][recvPacket['Tid']]['path']
              openedFile, mode, pathName, errorCode = openFile(path,
                      decodeSMBString(recvPacket['Flags2'],openAndXData['FileName']), 
@@ -2155,7 +2155,7 @@ class SMBCommands:
             if len(connData['OpenedFiles']) == 0:
                fid = 1
             else:
-               fid = connData['OpenedFiles'].keys()[-1] + 1
+               fid = list(connData['OpenedFiles'].keys())[-1] + 1
             respParameters['Fid'] = fid
             if mode & os.O_CREAT:
                 # File did not exist and was created
@@ -2228,7 +2228,7 @@ class SMBCommands:
             if len(connData['ConnectedShares']) == 0:
                tid = 1
             else:
-               tid = connData['ConnectedShares'].keys()[-1] + 1
+               tid = list(connData['ConnectedShares'].keys())[-1] + 1
             connData['ConnectedShares'][tid] = share
             connData['ConnectedShares'][tid]['shareName'] = path
             resp['Tid'] = tid
@@ -2292,7 +2292,7 @@ class SMBCommands:
                    mechType = blob['MechTypes'][0]
                    if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:
                        # Nope, do we know it?
-                       if MechTypes.has_key(mechType):
+                       if mechType in MechTypes:
                            mechStr = MechTypes[mechType]
                        else:
                            mechStr = hexlify(mechType)
@@ -2402,7 +2402,7 @@ class SMBCommands:
                 if len(smbServer.getCredentials()) > 0:
                     identity = authenticateMessage['user_name'].decode('utf-16le')
                     # Do we have this user's credentials?
-                    if smbServer.getCredentials().has_key(identity):
+                    if identity in smbServer.getCredentials():
                         # Process data:
                         # Let's parse some data and keep it to ourselves in case it is asked
                         uid, lmhash, nthash = smbServer.getCredentials()[identity]
@@ -2525,7 +2525,7 @@ class SMBCommands:
                     _dialects_parameters = smb.SMBNTLMDialect_Parameters()
                     _dialects_data= smb.SMBNTLMDialect_Data()
                     _dialects_data['Payload'] = ''
-                    if connData.has_key('EncryptionKey'):
+                    if 'EncryptionKey' in connData:
                         _dialects_data['Challenge'] = connData['EncryptionKey']
                         _dialects_parameters['ChallengeLength'] = len(str(_dialects_data))
                     else:
@@ -2558,7 +2558,7 @@ class SMBCommands:
            connData['_dialects_data']       = _dialects_data
            connData['_dialects_parameters'] = _dialects_parameters
 
-        except Exception, e:
+        except Exception as e:
            # No NTLM throw an error
            smbServer.log('smbComNegotiate: %s' % e, logging.ERROR)
            respSMBCommand['Data'] = struct.pack('<H',0xffff) 
@@ -2665,7 +2665,7 @@ class SMB2Commands:
                mechType = blob['MechTypes'][0]
                if mechType != TypesMech['NTLMSSP - Microsoft NTLM Security Support Provider']:
                    # Nope, do we know it?
-                   if MechTypes.has_key(mechType):
+                   if mechType in MechTypes:
                        mechStr = MechTypes[mechType]
                    else:
                        mechStr = hexlify(mechType)
@@ -2773,7 +2773,7 @@ class SMB2Commands:
                 isGuest = False
                 identity = authenticateMessage['user_name'].decode('utf-16le')
                 # Do we have this user's credentials?
-                if smbServer.getCredentials().has_key(identity):
+                if identity in smbServer.getCredentials():
                     # Process data:
                     # Let's parse some data and keep it to ourselves in case it is asked
                     uid, lmhash, nthash = smbServer.getCredentials()[identity]
@@ -2874,7 +2874,7 @@ class SMB2Commands:
             if len(connData['ConnectedShares']) == 0:
                tid = 1
             else:
-               tid = connData['ConnectedShares'].keys()[-1] + 1
+               tid = list(connData['ConnectedShares'].keys())[-1] + 1
             connData['ConnectedShares'][tid] = share
             connData['ConnectedShares'][tid]['shareName'] = path
             respPacket['TreeID']    = tid
@@ -2914,10 +2914,10 @@ class SMB2Commands:
 
         respSMBCommand['Buffer'] = '\x00'
         # Get the Tid associated
-        if connData['ConnectedShares'].has_key(recvPacket['TreeID']):
+        if recvPacket['TreeID'] in connData['ConnectedShares']:
              # If we have a rootFid, the path is relative to that fid
              errorCode = STATUS_SUCCESS
-             if connData['ConnectedShares'][recvPacket['TreeID']].has_key('path'):
+             if 'path' in connData['ConnectedShares'][recvPacket['TreeID']]:
                  path = connData['ConnectedShares'][recvPacket['TreeID']]['path']
              else:
                  path = 'NONE'
@@ -2953,7 +2953,7 @@ class SMB2Commands:
                  else:
                      mode |= os.O_CREAT
              elif createDisposition & smb2.FILE_OPEN == smb2.FILE_OPEN:
-                 if os.path.exists(pathName) is not True and smbServer.getRegisteredNamedPipes().has_key(unicode(pathName)) is not True:
+                 if os.path.exists(pathName) is not True and (str(pathName) in smbServer.getRegisteredNamedPipes()) is not True:
                      errorCode = STATUS_NO_SUCH_FILE
 
              if errorCode == STATUS_SUCCESS:
@@ -2975,7 +2975,7 @@ class SMB2Commands:
                              # Let's create the directory
                              os.mkdir(pathName)
                              mode = os.O_RDONLY
-                         except Exception, e:
+                         except Exception as e:
                              smbServer.log("SMB2_CREATE: %s,%s,%s" % (pathName,mode,e),logging.ERROR)
                              errorCode = STATUS_ACCESS_DENIED
                  if createOptions & smb2.FILE_NON_DIRECTORY_FILE == smb2.FILE_NON_DIRECTORY_FILE:
@@ -2995,13 +2995,13 @@ class SMB2Commands:
                          else:
                             if sys.platform == 'win32':
                                mode |= os.O_BINARY
-                            if smbServer.getRegisteredNamedPipes().has_key(unicode(pathName)):
+                            if str(pathName) in smbServer.getRegisteredNamedPipes():
                                 fid = PIPE_FILE_DESCRIPTOR
                                 sock = socket.socket()
-                                sock.connect(smbServer.getRegisteredNamedPipes()[unicode(pathName)])
+                                sock.connect(smbServer.getRegisteredNamedPipes()[str(pathName)])
                             else:
                                 fid = os.open(pathName, mode)
-                     except Exception, e:
+                     except Exception as e:
                          smbServer.log("SMB2_CREATE: %s,%s,%s" % (pathName,mode,e),logging.ERROR)
                          #print e
                          fid = 0
@@ -3072,14 +3072,14 @@ class SMB2Commands:
 
         if str(closeRequest['FileID']) == '\xff'*16:
             # Let's take the data from the lastRequest
-            if  connData['LastRequest'].has_key('SMB2_CREATE'):
+            if  'SMB2_CREATE' in connData['LastRequest']:
                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']
             else:
                 fileID = str(closeRequest['FileID'])
         else:
             fileID = str(closeRequest['FileID'])
 
-        if connData['OpenedFiles'].has_key(fileID):
+        if fileID in connData['OpenedFiles']:
              errorCode = STATUS_SUCCESS
              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']
              pathName = connData['OpenedFiles'][fileID]['FileName']
@@ -3090,7 +3090,7 @@ class SMB2Commands:
                  elif fileHandle != VOID_FILE_DESCRIPTOR:
                      os.close(fileHandle)
                      infoRecord, errorCode = queryFileInformation(os.path.dirname(pathName), os.path.basename(pathName), smb2.SMB2_FILE_NETWORK_OPEN_INFO)
-             except Exception, e:
+             except Exception as e:
                  smbServer.log("SMB2_CLOSE %s" % e, logging.ERROR)
                  errorCode = STATUS_INVALID_HANDLE
              else:
@@ -3101,7 +3101,7 @@ class SMB2Commands:
                              shutil.rmtree(connData['OpenedFiles'][fileID]['FileName'])
                          else:
                              os.remove(connData['OpenedFiles'][fileID]['FileName'])
-                     except Exception, e:
+                     except Exception as e:
                          smbServer.log("SMB2_CLOSE %s" % e, logging.ERROR)
                          errorCode = STATUS_ACCESS_DENIED
     
@@ -3137,15 +3137,15 @@ class SMB2Commands:
 
         if str(queryInfo['FileID']) == '\xff'*16:
             # Let's take the data from the lastRequest
-            if  connData['LastRequest'].has_key('SMB2_CREATE'):
+            if  'SMB2_CREATE' in connData['LastRequest']:
                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']
             else:
                 fileID = str(queryInfo['FileID'])
         else:
             fileID = str(queryInfo['FileID'])
 
-        if connData['ConnectedShares'].has_key(recvPacket['TreeID']):
-            if connData['OpenedFiles'].has_key(fileID):
+        if recvPacket['TreeID'] in connData['ConnectedShares']:
+            if fileID in connData['OpenedFiles']:
                 fileName = connData['OpenedFiles'][fileID]['FileName']
 
                 if queryInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:
@@ -3188,16 +3188,16 @@ class SMB2Commands:
 
         if str(setInfo['FileID']) == '\xff'*16:
             # Let's take the data from the lastRequest
-            if  connData['LastRequest'].has_key('SMB2_CREATE'):
+            if  'SMB2_CREATE' in connData['LastRequest']:
                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']
             else:
                 fileID = str(setInfo['FileID'])
         else:
             fileID = str(setInfo['FileID'])
 
-        if connData['ConnectedShares'].has_key(recvPacket['TreeID']):
+        if recvPacket['TreeID'] in connData['ConnectedShares']:
             path     = connData['ConnectedShares'][recvPacket['TreeID']]['path']
-            if connData['OpenedFiles'].has_key(fileID):
+            if fileID in connData['OpenedFiles']:
                 pathName = connData['OpenedFiles'][fileID]['FileName']
 
                 if setInfo['InfoType'] == smb2.SMB2_0_INFO_FILE:
@@ -3237,7 +3237,7 @@ class SMB2Commands:
                         try:
                              os.rename(pathName,newPathName)
                              connData['OpenedFiles'][fileID]['FileName'] = newPathName
-                        except Exception, e:
+                        except Exception as e:
                              smbServer.log("smb2SetInfo: %s" % e, logging.ERROR)
                              errorCode = STATUS_ACCESS_DENIED
                     else:
@@ -3278,14 +3278,14 @@ class SMB2Commands:
 
         if str(writeRequest['FileID']) == '\xff'*16:
             # Let's take the data from the lastRequest
-            if  connData['LastRequest'].has_key('SMB2_CREATE'):
+            if  'SMB2_CREATE' in connData['LastRequest']:
                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']
             else:
                 fileID = str(writeRequest['FileID'])
         else:
             fileID = str(writeRequest['FileID'])
 
-        if connData['OpenedFiles'].has_key(fileID):
+        if fileID in connData['OpenedFiles']:
              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']
              errorCode = STATUS_SUCCESS
              try:
@@ -3301,7 +3301,7 @@ class SMB2Commands:
 
                  respSMBCommand['Count']    = writeRequest['Length']
                  respSMBCommand['Remaining']= 0xff
-             except Exception, e:
+             except Exception as e:
                  smbServer.log('SMB2_WRITE: %s' % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -3321,14 +3321,14 @@ class SMB2Commands:
 
         if str(readRequest['FileID']) == '\xff'*16:
             # Let's take the data from the lastRequest
-            if  connData['LastRequest'].has_key('SMB2_CREATE'):
+            if  'SMB2_CREATE' in connData['LastRequest']:
                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']
             else:
                 fileID = str(readRequest['FileID'])
         else:
             fileID = str(readRequest['FileID'])
 
-        if connData['OpenedFiles'].has_key(fileID):
+        if fileID in connData['OpenedFiles']:
              fileHandle = connData['OpenedFiles'][fileID]['FileHandle']
              errorCode = 0
              try:
@@ -3344,7 +3344,7 @@ class SMB2Commands:
                  respSMBCommand['DataLength']   = len(content)
                  respSMBCommand['DataRemaining']= 0
                  respSMBCommand['Buffer']       = content
-             except Exception, e:
+             except Exception as e:
                  smbServer.log('SMB2_READ: %s ' % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -3360,12 +3360,12 @@ class SMB2Commands:
         respSMBCommand = smb2.SMB2Flush_Response()
         flushRequest   = smb2.SMB2Flush(recvPacket['Data'])
 
-        if connData['OpenedFiles'].has_key(str(flushRequest['FileID'])):
+        if str(flushRequest['FileID']) in connData['OpenedFiles']:
              fileHandle = connData['OpenedFiles'][str(flushRequest['FileID'])]['FileHandle']
              errorCode = STATUS_SUCCESS
              try:
                  os.fsync(fileHandle)
-             except Exception, e:
+             except Exception as e:
                  smbServer.log("SMB2_FLUSH %s" % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -3384,21 +3384,21 @@ class SMB2Commands:
         respSMBCommand['Buffer'] = '\x00'
 
         # The server MUST locate the tree connection, as specified in section 3.3.5.2.11.
-        if connData['ConnectedShares'].has_key(recvPacket['TreeID']) is False:
+        if (recvPacket['TreeID'] in connData['ConnectedShares']) is False:
             return [smb2.SMB2Error()], None, STATUS_NETWORK_NAME_DELETED
        
         # Next, the server MUST locate the open for the directory to be queried 
         # If no open is found, the server MUST fail the request with STATUS_FILE_CLOSED
         if str(queryDirectoryRequest['FileID']) == '\xff'*16:
             # Let's take the data from the lastRequest
-            if  connData['LastRequest'].has_key('SMB2_CREATE'):
+            if  'SMB2_CREATE' in connData['LastRequest']:
                 fileID = connData['LastRequest']['SMB2_CREATE']['FileID']
             else:
                 fileID = str(queryDirectoryRequest['FileID'])
         else:
             fileID = str(queryDirectoryRequest['FileID'])
 
-        if connData['OpenedFiles'].has_key(fileID) is False:
+        if (fileID in connData['OpenedFiles']) is False:
             return [smb2.SMB2Error()], None, STATUS_FILE_CLOSED
 
         # If the open is not an open to a directory, the request MUST be failed 
@@ -3516,7 +3516,7 @@ class SMB2Commands:
 
         respSMBCommand = smb2.SMB2TreeDisconnect_Response()
 
-        if connData['ConnectedShares'].has_key(recvPacket['TreeID']):
+        if recvPacket['TreeID'] in connData['ConnectedShares']:
             smbServer.log("Disconnecting Share(%d:%s)" % (recvPacket['TreeID'],connData['ConnectedShares'][recvPacket['TreeID']]['shareName']))
             del(connData['ConnectedShares'][recvPacket['TreeID']])
             errorCode = STATUS_SUCCESS
@@ -3554,7 +3554,7 @@ class SMB2Commands:
         ioctlRequest   = smb2.SMB2Ioctl(recvPacket['Data'])
 
         ioctls = smbServer.getIoctls()
-        if ioctls.has_key(ioctlRequest['CtlCode']):
+        if ioctlRequest['CtlCode'] in ioctls:
             outputData, errorCode = ioctls[ioctlRequest['CtlCode']](connId, smbServer, ioctlRequest)
             if errorCode == STATUS_SUCCESS:
                 respSMBCommand['CtlCode']      = ioctlRequest['CtlCode']
@@ -3609,7 +3609,7 @@ class Ioctls:
         
         ioctlResponse = ''
 
-        if connData['OpenedFiles'].has_key(str(ioctlRequest['FileID'])):
+        if str(ioctlRequest['FileID']) in connData['OpenedFiles']:
              fileHandle = connData['OpenedFiles'][str(ioctlRequest['FileID'])]['FileHandle']
              errorCode = STATUS_SUCCESS
              try:
@@ -3619,7 +3619,7 @@ class Ioctls:
                      sock = connData['OpenedFiles'][str(ioctlRequest['FileID'])]['Socket']
                      sock.sendall(ioctlRequest['Buffer'])
                      ioctlResponse = sock.recv(ioctlRequest['MaxOutputResponse'])
-             except Exception, e:
+             except Exception as e:
                  smbServer.log('fsctlPipeTransceive: %s ' % e, logging.ERROR)
                  errorCode = STATUS_ACCESS_DENIED
         else:
@@ -3645,7 +3645,7 @@ class Ioctls:
         return validateNegotiateInfoResponse.getData(), errorCode
 
 
-class SMBSERVERHandler(SocketServer.BaseRequestHandler):
+class SMBSERVERHandler(socketserver.BaseRequestHandler):
     def __init__(self, request, client_address, server, select_poll = False):
         self.__SMB = server
         # In case of AF_INET6 the client_address contains 4 items, ignore the last 2
@@ -3655,7 +3655,7 @@ class SMBSERVERHandler(SocketServer.BaseRequestHandler
         self.__timeOut = 60*5
         self.__select_poll = select_poll
         #self.__connId = os.getpid()
-        SocketServer.BaseRequestHandler.__init__(self, request, client_address, server)
+        socketserver.BaseRequestHandler.__init__(self, request, client_address, server)
 
     def handle(self):
         self.__SMB.log("Incoming connection (%s,%d)" % (self.__ip, self.__port))
@@ -3687,7 +3687,7 @@ class SMBSERVERHandler(SocketServer.BaseRequestHandler
                    # a single packet
                    for i in resp:
                        session.send_packet(str(i))
-            except Exception, e:
+            except Exception as e:
                 self.__SMB.log("Handle: %s" % e)
                 #import traceback
                 #traceback.print_exc()
@@ -3697,13 +3697,13 @@ class SMBSERVERHandler(SocketServer.BaseRequestHandler
         # Thread/process is dying, we should tell the main SMB thread to remove all this thread data
         self.__SMB.log("Closing down connection (%s,%d)" % (self.__ip, self.__port))
         self.__SMB.removeConnection(self.__connId)
-        return SocketServer.BaseRequestHandler.finish(self)
+        return socketserver.BaseRequestHandler.finish(self)
 
-class SMBSERVER(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
+class SMBSERVER(socketserver.ThreadingMixIn, socketserver.TCPServer):
 #class SMBSERVER(SocketServer.ForkingMixIn, SocketServer.TCPServer):
     def __init__(self, server_address, handler_class=SMBSERVERHandler, config_parser = None):
-        SocketServer.TCPServer.allow_reuse_address = True
-        SocketServer.TCPServer.__init__(self, server_address, handler_class)
+        socketserver.TCPServer.allow_reuse_address = True
+        socketserver.TCPServer.__init__(self, server_address, handler_class)
 
         # Server name and OS to be presented whenever is necessary
         self.__serverName   = ''
@@ -3842,7 +3842,7 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
            del(self.__activeConnections[name])
         except:
            pass
-        self.log("Remaining connections %s" % self.__activeConnections.keys())
+        self.log("Remaining connections %s" % list(self.__activeConnections.keys()))
 
     def addConnection(self, name, ip, port):
         self.__activeConnections[name] = {}
@@ -3874,7 +3874,7 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
     def getConnectionData(self, connId, checkStatus = True):
         conn = self.__activeConnections[connId]
         if checkStatus is True:
-            if conn.has_key('Authenticated') is not True:
+            if ('Authenticated' in conn) is not True:
                 # Can't keep going further
                 raise Exception("User not Authenticated!")
         return conn
@@ -3883,17 +3883,17 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
         return self.__registeredNamedPipes
 
     def registerNamedPipe(self, pipeName, address):
-        self.__registeredNamedPipes[unicode(pipeName)] = address
+        self.__registeredNamedPipes[str(pipeName)] = address
         return True
 
     def unregisterNamedPipe(self, pipeName):
-        if self.__registeredNamedPipes.has_key(pipeName):
-            del(self.__registeredNamedPipes[unicode(pipeName)])
+        if pipeName in self.__registeredNamedPipes:
+            del(self.__registeredNamedPipes[str(pipeName)])
             return True
         return False
 
     def unregisterTransaction(self, transCommand):
-        if self.__smbTransCommands.has_key(transCommand):
+        if transCommand in self.__smbTransCommands:
            del(self.__smbTransCommands[transCommand])
 
     def hookTransaction(self, transCommand, callback):
@@ -3928,7 +3928,7 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
         # respData: the data response of the transaction
         # errorCode: the NT error code 
 
-        if self.__smbTransCommands.has_key(transCommand):
+        if transCommand in self.__smbTransCommands:
            originalCommand = self.__smbTransCommands[transCommand]
         else:
            originalCommand = None 
@@ -3937,13 +3937,13 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
         return originalCommand
 
     def unregisterTransaction2(self, transCommand):
-        if self.__smbTrans2Commands.has_key(transCommand):
+        if transCommand in self.__smbTrans2Commands:
            del(self.__smbTrans2Commands[transCommand])
 
     def hookTransaction2(self, transCommand, callback):
         # Here we should add to __smbTrans2Commands
         # Same description as Transaction
-        if self.__smbTrans2Commands.has_key(transCommand):
+        if transCommand in self.__smbTrans2Commands:
            originalCommand = self.__smbTrans2Commands[transCommand]
         else:
            originalCommand = None 
@@ -3952,13 +3952,13 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
         return originalCommand
 
     def unregisterNTTransaction(self, transCommand):
-        if self.__smbNTTransCommands.has_key(transCommand):
+        if transCommand in self.__smbNTTransCommands:
            del(self.__smbNTTransCommands[transCommand])
 
     def hookNTTransaction(self, transCommand, callback):
         # Here we should add to __smbNTTransCommands
         # Same description as Transaction
-        if self.__smbNTTransCommands.has_key(transCommand):
+        if transCommand in self.__smbNTTransCommands:
            originalCommand = self.__smbNTTransCommands[transCommand]
         else:
            originalCommand = None 
@@ -3967,7 +3967,7 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
         return originalCommand
 
     def unregisterSmbCommand(self, smbCommand):
-        if self.__smbCommands.has_key(smbCommand):
+        if smbCommand in self.__smbCommands:
            del(self.__smbCommands[smbCommand])
 
     def hookSmbCommand(self, smbCommand, callback):
@@ -4006,7 +4006,7 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
         # transCommands: a list of transaction subcommands already registered
         #
 
-        if self.__smbCommands.has_key(smbCommand):
+        if smbCommand in self.__smbCommands:
            originalCommand = self.__smbCommands[smbCommand]
         else:
            originalCommand = None 
@@ -4015,11 +4015,11 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
         return originalCommand
   
     def unregisterSmb2Command(self, smb2Command):
-        if self.__smb2Commands.has_key(smb2Command):
+        if smb2Command in self.__smb2Commands:
            del(self.__smb2Commands[smb2Command])
 
     def hookSmb2Command(self, smb2Command, callback):
-        if self.__smb2Commands.has_key(smb2Command):
+        if smb2Command in self.__smb2Commands:
            originalCommand = self.__smb2Commands[smb2Command]
         else:
            originalCommand = None 
@@ -4158,13 +4158,13 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
                                       packet,
                                       self.__smbTransCommands)
                     else:
-                        if self.__smbCommands.has_key(packet['Command']):
+                        if packet['Command'] in self.__smbCommands:
                            if self.__SMB2Support is True:
                                if packet['Command'] == smb.SMB.SMB_COM_NEGOTIATE:
                                    try:
                                        respCommands, respPackets, errorCode = self.__smb2Commands[smb2.SMB2_NEGOTIATE](connId, self, packet, True)
                                        isSMB2 = True
-                                   except Exception, e:
+                                   except Exception as e:
                                        self.log('SMB2_NEGOTIATE: %s' % e, logging.ERROR)
                                        # If something went wrong, let's fallback to SMB1
                                        respCommands, respPackets, errorCode = self.__smbCommands[packet['Command']](
@@ -4204,7 +4204,7 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
                 else:
                     done = False
                     while not done:
-                        if self.__smb2Commands.has_key(packet['Command']):
+                        if packet['Command'] in self.__smb2Commands:
                            if self.__SMB2Support is True:
                                respCommands, respPackets, errorCode = self.__smb2Commands[packet['Command']](
                                        connId,
@@ -4223,7 +4223,7 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
                         else:
                             done = True
 
-        except Exception, e:
+        except Exception as e:
             #import traceback
             #traceback.print_exc()
             # Something wen't wrong, defaulting to Bad user ID
@@ -4330,7 +4330,7 @@ smb.SMB.TRANS_TRANSACT_NMPIPE          :self.__smbTran
         if self.__serverConfig is None:
             if configFile is None:
                 configFile = 'smb.conf'
-            self.__serverConfig = ConfigParser.ConfigParser()
+            self.__serverConfig = configparser.ConfigParser()
             self.__serverConfig.read(configFile)
 
         self.__serverName   = self.__serverConfig.get('global','server_name')
@@ -4454,7 +4454,7 @@ class SRVSServer(DCERPCServer):
 
     def processConfigFile(self, configFile=None):
        if configFile is not None:
-           self.__serverConfig = ConfigParser.ConfigParser()
+           self.__serverConfig = configparser.ConfigParser()
            self.__serverConfig.read(configFile)
        sections = self.__serverConfig.sections()
        # Let's check the log file
@@ -4477,7 +4477,7 @@ class SRVSServer(DCERPCServer):
 
        s = request['NetName'][:-1].upper()
        answer = NetrShareGetInfoResponse()
-       if self._shares.has_key(s):
+       if s in self._shares:
            share  = self._shares[s]
 
            answer['InfoStruct']['tag'] = 1
@@ -4543,7 +4543,7 @@ class SimpleSMBServer:
             self.__smbConfig = None
         else:
             # Here we write a mini config for the server
-            self.__smbConfig = ConfigParser.ConfigParser()
+            self.__smbConfig = configparser.ConfigParser()
             self.__smbConfig.add_section('global')
             self.__smbConfig.set('global','server_name',''.join([random.choice(string.letters) for _ in range(8)]))
             self.__smbConfig.set('global','server_os',''.join([random.choice(string.letters) for _ in range(8)])
--- impacket/spnego.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/spnego.py
@@ -32,7 +32,7 @@ MechTypes = {
 '\x2b\x06\x01\x04\x01\x82\x37\x02\x02\x1e': 'NEGOEX - SPNEGO Extended Negotiation Security Mechanism'
 }
 
-TypesMech = dict((v,k) for k, v in MechTypes.iteritems())
+TypesMech = dict((v,k) for k, v in MechTypes.items())
 
 def asn1encode(data = ''):
         #res = asn1.SEQUENCE(str).encode()
@@ -76,7 +76,7 @@ def asn1decode(data = ''):
             data = data[pad:]
             ans = data[:len2]
         # 1 byte length, string <= 0x7F
-	else:
+        else:
             pad = 0
             ans = data[:len1]
         return ans, len(ans)+pad+1
@@ -131,8 +131,8 @@ class GSSAPI:
         #pass
         
     def dump(self):
-        for i in self.fields.keys():
-            print "%s: {%r}" % (i,self[i])
+        for i in list(self.fields.keys()):
+            print("%s: {%r}" % (i,self[i]))
 
     def getData(self):
         ans = pack('B',ASN1_AID)
@@ -246,12 +246,12 @@ class SPNEGO_NegTokenResp:
         self['ResponseToken'] = decode_data
 
     def dump(self):
-        for i in self.fields.keys():
-            print "%s: {%r}" % (i,self[i])
+        for i in list(self.fields.keys()):
+            print("%s: {%r}" % (i,self[i]))
         
     def getData(self):
         ans = pack('B',SPNEGO_NegTokenResp.SPNEGO_NEG_TOKEN_RESP)
-        if self.fields.has_key('NegResult') and self.fields.has_key('SupportedMech'):
+        if 'NegResult' in self.fields and 'SupportedMech' in self.fields:
             # Server resp
             ans += asn1encode(
                pack('B', ASN1_SEQUENCE) +
@@ -267,7 +267,7 @@ class SPNEGO_NegTokenResp:
                pack('B',ASN1_RESPONSE_TOKEN ) +
                asn1encode(
                pack('B', ASN1_OCTET_STRING) + asn1encode(self['ResponseToken']))))
-        elif self.fields.has_key('NegResult'):
+        elif 'NegResult' in self.fields:
             # Server resp
             ans += asn1encode(
                pack('B', ASN1_SEQUENCE) + 
@@ -304,7 +304,7 @@ class SPNEGO_NegTokenInit(GSSAPI):
         payload = payload[1:]
         decode_data, total_bytes = asn1decode(payload)
         # Now we should have a SEQUENCE Tag
-	next_byte = unpack('B', decode_data[:1])[0]
+        next_byte = unpack('B', decode_data[:1])[0]
         if next_byte != ASN1_SEQUENCE:
             raise Exception('SEQUENCE tag not found %x' % next_byte)
         decode_data = decode_data[1:]
@@ -354,7 +354,7 @@ class SPNEGO_NegTokenInit(GSSAPI):
 
         mechToken = ''
         # Do we have tokens to send?
-        if self.fields.has_key('MechToken'):
+        if 'MechToken' in self.fields:
             mechToken = pack('B', ASN1_MECH_TOKEN) + asn1encode(
                 pack('B', ASN1_OCTET_STRING) + asn1encode(
                     self['MechToken']))
--- impacket/tds.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/tds.py
@@ -44,7 +44,7 @@ except:
 # The rest it processed through the standard impacket logging mech.
 class DummyPrint:        
     def logMessage(self,message):
-        print message
+        print(message)
 
 # MC-SQLR Constants and Structures
 SQLR_PORT           = 1434
@@ -521,7 +521,7 @@ class MSSQL:
     
     def encryptPassword(self, password ):
 
-        return ''.join(map(lambda x: chr(((ord(x) & 0x0f) << 4) + ((ord(x) & 0xf0) >> 4) ^ 0xa5) , password))
+        return ''.join([chr(((ord(x) & 0x0f) << 4) + ((ord(x) & 0xf0) >> 4) ^ 0xa5) for x in password])
 
     def connect(self):
         af, socktype, proto, canonname, sa = socket.getaddrinfo(self.server, self.port, 0, socket.SOCK_STREAM)[0]
@@ -767,7 +767,7 @@ class MSSQL:
                 if TGS is None:
                     try:
                         tgt, cipher, oldSessionKey, sessionKey = getKerberosTGT(userName, password, domain, lmhash, nthash, aesKey, kdcHost)
-                    except KerberosError, e:
+                    except KerberosError as e:
                         if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
                             # We might face this if the target does not support AES
                             # So, if that's the case we'll force using RC4 by converting
@@ -802,7 +802,7 @@ class MSSQL:
                 serverName = Principal('MSSQLSvc/%s.%s:%d' % (self.server.split('.')[0], domain, self.port), type=constants.PrincipalNameType.NT_SRV_INST.value)
                 try:
                     tgs, cipher, oldSessionKey, sessionKey = getKerberosTGS(serverName, domain, kdcHost, tgt, cipher, sessionKey)
-                except KerberosError, e:
+                except KerberosError as e:
                     if e.getErrorCode() == constants.ErrorCodes.KDC_ERR_ETYPE_NOSUPP.value:
                         # We might face this if the target does not support AES
                         # So, if that's the case we'll force using RC4 by converting
@@ -886,7 +886,7 @@ class MSSQL:
 
         self.replies = self.parseReply(tds['Data'])
 
-        if self.replies.has_key(TDS_LOGINACK_TOKEN):
+        if TDS_LOGINACK_TOKEN in self.replies:
             return True
         else:
             return False
@@ -974,7 +974,7 @@ class MSSQL:
 
         self.replies = self.parseReply(tds['Data'])
 
-        if self.replies.has_key(TDS_LOGINACK_TOKEN):
+        if TDS_LOGINACK_TOKEN in self.replies:
             return True
         else:
             return False
@@ -1040,7 +1040,7 @@ class MSSQL:
                 self.__rowsPrinter.logMessage(col['Format'] % row[col['Name']] + self.COL_SEPARATOR)            
 
     def printReplies(self):
-        for keys in self.replies.keys():
+        for keys in list(self.replies.keys()):
             for i, key in enumerate(self.replies[keys]):
                 if key['TokenType'] == TDS_ERROR_TOKEN:
                     error =  "ERROR(%s): Line %d: %s" % (key['ServerName'].decode('utf-16le'), key['LineNumber'], key['MsgText'].decode('utf-16le'))                                      
@@ -1512,7 +1512,7 @@ class MSSQL:
                 LOG.error("Unknown Token %x" % tokenID)
                 return replies
 
-            if replies.has_key(tokenID) is not True:
+            if (tokenID in replies) is not True:
                 replies[tokenID] = list()
 
             replies[tokenID].append(token)
--- impacket/uuid.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/uuid.py
@@ -19,7 +19,7 @@ from struct import pack, unpack
 
 def generate():
     # UHm... crappy Python has an maximum integer of 2**31-1.
-    top = (1L<<31)-1
+    top = (1<<31)-1
     return pack("IIII", randrange(top), randrange(top), randrange(top), randrange(top))
 
 def bin_to_string(uuid):
@@ -29,7 +29,7 @@ def bin_to_string(uuid):
 
 def string_to_bin(uuid):
     matches = re.match('([\dA-Fa-f]{8})-([\dA-Fa-f]{4})-([\dA-Fa-f]{4})-([\dA-Fa-f]{4})-([\dA-Fa-f]{4})([\dA-Fa-f]{8})', uuid)
-    (uuid1, uuid2, uuid3, uuid4, uuid5, uuid6) = map(lambda x: long(x, 16), matches.groups())
+    (uuid1, uuid2, uuid3, uuid4, uuid5, uuid6) = [int(x, 16) for x in matches.groups()]
     uuid = pack('<LHH', uuid1, uuid2, uuid3)
     uuid += pack('>HHL', uuid4, uuid5, uuid6)
     return uuid
--- impacket/winregistry.py.orig	2022-05-21 20:29:42 UTC
+++ impacket/winregistry.py
@@ -204,7 +204,7 @@ class Registry:
             return None
         else:
             block = REG_HBINBLOCK(data)
-            if StructMappings.has_key(block['Data'][:2]):
+            if block['Data'][:2] in StructMappings:
                 return StructMappings[block['Data'][:2]](block['Data'])
             else:
                 LOG.debug("Unknown type 0x%s" % block['Data'][:2])
@@ -242,7 +242,7 @@ class Registry:
             block.fromString(data)
             blockLen = len(block)
 
-            if StructMappings.has_key(block['Data'][:2]):
+            if block['Data'][:2] in StructMappings:
                 block = StructMappings[block['Data'][:2]](block['Data'])
 
             res.append(block)
@@ -318,7 +318,7 @@ class Registry:
     def __walkSubNodes(self, rec):
         nk = self.__getBlock(rec['OffsetNk'])
         if isinstance(nk, REG_NK):
-            print "%s%s" % (self.indent, nk['KeyName'])
+            print("%s%s" % (self.indent, nk['KeyName']))
             self.indent += '  '
             if nk['OffsetSubKeyLf'] < 0:
                 self.indent = self.indent[:-2]
@@ -381,29 +381,29 @@ class Registry:
     def printValue(self, valueType, valueData):
         if valueType == REG_SZ or valueType == REG_EXPAND_SZ:
             if type(valueData) is int:
-                print 'NULL'
+                print('NULL')
             else:
-                print "%s" % (valueData.decode('utf-16le'))
+                print("%s" % (valueData.decode('utf-16le')))
         elif valueType == REG_BINARY:
-            print ''
+            print('')
             hexdump(valueData, self.indent)
         elif valueType == REG_DWORD:
-            print "%d" % valueData
+            print("%d" % valueData)
         elif valueType == REG_QWORD:
-            print "%d" % (unpack('<Q',valueData)[0])
+            print("%d" % (unpack('<Q',valueData)[0]))
         elif valueType == REG_NONE:
             try:
                 if len(valueData) > 1:
-                    print ''
+                    print('')
                     hexdump(valueData, self.indent)
                 else:
-                    print " NULL"
+                    print(" NULL")
             except:
-                print " NULL"
+                print(" NULL")
         elif valueType == REG_MULTISZ:
-            print "%s" % (valueData.decode('utf-16le'))
+            print("%s" % (valueData.decode('utf-16le')))
         else:
-            print "Unknown Type 0x%x!" % valueType
+            print("Unknown Type 0x%x!" % valueType)
             hexdump(valueData)
 
     def enumKey(self, parentKey):
@@ -490,16 +490,16 @@ def hexdump(data, indent = ''):
     strLen = len(x)
     i = 0
     while i < strLen:
-        print indent,
-        print "%04x  " % i,
+        print(indent, end=' ')
+        print("%04x  " % i, end=' ')
         for j in range(16):
             if i+j < strLen:
-                print "%02X" % ord(x[i+j]),
+                print("%02X" % ord(x[i+j]), end=' ')
             else:
-                print "  ",
+                print("  ", end=' ')
             if j%16 == 7:
-                print "",
-        print " ",
-        print ''.join(pretty_print(x) for x in x[i:i+16] )
+                print("", end=' ')
+        print(" ", end=' ')
+        print(''.join(pretty_print(x) for x in x[i:i+16] ))
         i += 16
 
