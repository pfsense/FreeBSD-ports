<?php
/*
 * mdns-bridge.inc
 *
 * part of pfSense (https://www.pfsense.org)
 * Copyright (c) 2024-2025 Denny Page
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


require_once("config.inc");
require_once("util.inc");
require_once("service-utils.inc");

define('LOG_PREFIX_PKG_MDNSBRIDGE', 'mDNS Bridge');

const MDNS_BRIDGE_SVC_NAME = 'mdns-bridge';
const MDNS_BRIDGE_CMD = '/usr/local/bin/mdns-bridge';
const MDNS_BRIDGE_RC_FILE = '/usr/local/etc/rc.d/mdns-bridge.sh';
const MDNS_BRIDGE_CONF_FILE = '/usr/local/etc/mdns-bridge.conf';
const MDNS_BRIDGE_PID_FILE = '/var/run/mdns-bridge.pid';


// Is mDNS Bridge enabled?
function mdns_bridge_enabled() {
	return (config_get_path('installedpackages/mdns-bridge/enable', false));
}

// Get the CARP VHID in use by mDNS Bridge
function mdns_bridge_get_carp_vhid() {
	$carp_vhid = config_get_path('installedpackages/mdns-bridge/carp_vhid', 'none');
	if ($carp_vhid != 'none') {
		return $carp_vhid;
	}
	return null;
}

// Get a CARP VHID list for use in mdns_bridge.php
function mdns_bridge_get_carp_list() {
	$list = array('none' => 'none');
	foreach (get_configured_vip_list('all', VIP_CARP) as $vid => $vaddr) {
		$vip = get_configured_vip($vid);
		$list[$vid] = sprintf("VHID %s on %s (%s)", $vip['vhid'], convert_friendly_interface_to_friendly_descr($vip['interface']), $vaddr);
	}
	return ($list);
}

// Write the config and rc files
function mdns_bridge_write_files() {
	// Get the current configuration
	$current_config = config_get_path('installedpackages/mdns-bridge', []);

	// Get the real interface names
	$interfaces = array();
	foreach (array_filter(explode(',', array_get_path($current_config, 'active_interfaces', ''))) as $interface) {
		$interface_name = get_real_interface($interface);
		if (!isset($interface_name)) {
			continue;
		}
		$interfaces[$interface] = $interface_name;
	}

	// Global section
	$file_array = array();
	$file_array[] = '# This file is generated by the pfSense mDNS Bridge package.';
	$file_array[] = '# Do not edit this file, it will be overwritten automatically.';

	$file_array[] = '[global]';
	$file_array[] = 'interfaces = ' . implode(', ', $interfaces);

	$ip_protocols = array_get_path($current_config, 'global_ip_protocols');
	switch ($ip_protocols) {
		case 'ipv4':
			$file_array['global_ip_protocols'] = 'disable-ipv6 = yes';
			break;
		case 'ipv6':
			$file_array['global_ip_protocols'] = 'disable-ipv4 = yes';
			break;
	}

	$filter_type = array_get_path($current_config, 'global_filter_type');
	$filter_list = array_get_path($current_config, 'global_filter_list');
	switch ($filter_type) {
		case 'allow':
			$file_array[] = 'allow-inbound-filters = ' . $filter_list;
			break;
		case 'deny':
			$file_array[] = 'deny-inbound-filters = ' . $filter_list;
			break;
		default:
			$disable_packet_filtering = array_get_path($current_config, 'disable_packet_filtering');
			if ($disable_packet_filtering)
			{
				$file_array['disable-packet-filtering'] = 'disable-packet-filtering = yes';
			}
	}


	// Interface sections
	foreach ($interfaces as $interface => $real_interface) {
		$file_array[] = '';
		$file_array[] = "[{$real_interface}]";

		if (!$file_array['global_ip_protocols']) {
			$ip_protocols = array_get_path($current_config, "interfaces/{$interface}/ip_protocols");
			switch ($ip_protocols) {
				case 'ipv4':
					$file_array[] = 'disable-ipv6 = yes';
					break;
				case 'ipv6':
					$file_array[] = 'disable-ipv4 = yes';
					break;
			}
		}

		$filter_type = array_get_path($current_config, "interfaces/{$interface}/inbound_filter_type");
		$filter_list = array_get_path($current_config, "interfaces/{$interface}/inbound_filter_list");
		switch ($filter_type) {
			case 'allow':
				$file_array[] = 'allow-inbound-filters = ' . $filter_list;
				unset($file_array['disable-packet-filtering']);
				break;
			case 'deny':
				$file_array[] = 'deny-inbound-filters = ' . $filter_list;
				unset($file_array['disable-packet-filtering']);
				break;
		}

		$filter_type = array_get_path($current_config, "interfaces/{$interface}/outbound_filter_type");
		$filter_list = array_get_path($current_config, "interfaces/{$interface}/outbound_filter_list");
		switch ($filter_type) {
			case 'allow':
				$file_array[] = 'allow-outbound-filters = ' . $filter_list;
				unset($file_array['disable-packet-filtering']);
				break;
			case 'deny':
				$file_array[] = 'deny-outbound-filters = ' . $filter_list;
				unset($file_array['disable-packet-filtering']);
				break;
		}
	}
	$file_array[] = '';

	// Write the config file
	if (!file_put_contents(MDNS_BRIDGE_CONF_FILE, implode("\n", $file_array))) {
		logger(LOG_ERR, localize_text('Could not write file %s', MDNS_BRIDGE_CONF_FILE), LOG_PREFIX_PKG_MDNSBRIDGE);
	}

	// Write the rc file
	$start = MDNS_BRIDGE_CMD;
	if (config_get_path('installedpackages/mdns-bridge/decode_warnings', false)) {
		$start .= ' -w';
	}
	$start .= ' -s -c ' . MDNS_BRIDGE_CONF_FILE . ' -p ' . MDNS_BRIDGE_PID_FILE;
	$stop = '/usr/bin/killall ' . MDNS_BRIDGE_SVC_NAME;
	write_rcfile(array(
		"file" => "mdns-bridge.sh",
		"start" => $start,
		"stop" => $stop
		)
	);
}

function mdns_bridge_sync_config() {
	// Stop the service if it is currently running
	if (is_service_running(MDNS_BRIDGE_SVC_NAME)) {
		logger(LOG_INFO, localize_text("Stopping service"), LOG_PREFIX_PKG_MDNSBRIDGE);
		stop_service(MDNS_BRIDGE_SVC_NAME);
	}

	// If the service is now disabled, remove the config and rc files and return
	if (!mdns_bridge_enabled()) {
		unlink_if_exists(MDNS_BRIDGE_RC_FILE);
		unlink_if_exists(MDNS_BRIDGE_CONF_FILE);
		return;
	}

	// Write the config and rc files
	mdns_bridge_write_files();

	// Take no further action during platform boot
	if (is_platform_booting()) {
		return;
	}

	// Check the CARP VHID if in use
	$carp_vhid = mdns_bridge_get_carp_vhid();
	if ($carp_vhid) {
		$status = get_carp_interface_status($carp_vhid);
		switch ($status) {
			case 'MASTER':
				break;

			case 'BACKUP':
			case 'INIT':
				// If the VHID is still initializing, or in backup, don't start the service.
				logger(LOG_INFO, localize_text("Service not started due to CARP status (%s)", $status), LOG_PREFIX_PKG_MDNSBRIDGE);
				return;
				break;

			default:
				logger(LOG_INFO, localize_text("Could not determine CARP status for VHID %s: status = '%s'", $carp_vhid, $status), LOG_PREFIX_PKG_MDNSBRIDGE);
		}

	}

	// Start the service
	logger(LOG_INFO, localize_text("Starting service"), LOG_PREFIX_PKG_MDNSBRIDGE);
	start_service(MDNS_BRIDGE_SVC_NAME);
}

// Handle CARP notifications
function mdns_bridge_plugin_carp($pluginparams) {
	// If mDNS Bridge is not enabled, or a CARP VHID is not in use, return
	if (!mdns_bridge_enabled()) {
		return null;
	}
	$carp_vhid = mdns_bridge_get_carp_vhid();
	if (!$carp_vhid) {
		return null;
	}

	// Get my VIP
	$vip = get_configured_vip($carp_vhid);
	if (!$vip) {
		logger(LOG_ERR, localize_text("Cannot find configured VHID (%s). Check configuration.", $carp_vhid), LOG_PREFIX_PKG_MDNSBRIDGE);
		return null;
	}

	// Is the notice for my VIP?
	$my_id = $vip['vhid'] . '@' . get_real_interface($vip['interface']);
	if (trim($pluginparams['interface']) != $my_id) {
		return null;
	}

	// Start or stop the service as appropriate
	if ($pluginparams['event'] == "rc.carpmaster") {
		logger(LOG_INFO, localize_text('Starting service on CARP VHID status change'), LOG_PREFIX_PKG_MDNSBRIDGE);
		start_service(MDNS_BRIDGE_SVC_NAME);
	} elseif ($pluginparams['event'] == "rc.carpbackup") {
		if (is_service_running(MDNS_BRIDGE_SVC_NAME)) {
			logger(LOG_INFO, localize_text('Stopping service on CARP VHID status change'), LOG_PREFIX_PKG_MDNSBRIDGE);
			stop_service(MDNS_BRIDGE_SVC_NAME);
		}
	}
}

// Clean up on deinstall
function mdns_bridge_deinstall_command() {
	if (is_service_running(MDNS_BRIDGE_SVC_NAME)) {
		logger(LOG_INFO, localize_text("Stopping service"), LOG_PREFIX_PKG_MDNSBRIDGE);
		stop_service(MDNS_BRIDGE_SVC_NAME);
	}

	unlink_if_exists(MDNS_BRIDGE_RC_FILE);
	unlink_if_exists(MDNS_BRIDGE_CONF_FILE);
}
