diff -ur ../src_old/Makefile ./Makefile
--- ../src_old/Makefile	2009-12-14 11:10:51.000000000 +0000
+++ ./Makefile	2009-12-14 11:10:54.000000000 +0000
@@ -1,12 +1,12 @@
 
 #BINDIR=../bin
 BINDIR=/usr/local/bin
-ETCDIR=/etc
-MANDIR=/usr/share/man
+ETCDIR=/usr/local/etc
+MANDIR=/usr/local/man
 
 
 # CFLAGS=-g
-CFLAGS=-O
+CFLAGS+=-O2 -Wall -Wextra -fno-builtin-log
 
 default : build.h igmpproxy
 
@@ -21,8 +21,11 @@
 	cp ../doc/igmpproxy.conf.5 ${MANDIR}/man5
 	if [ ! -e ${ETCDIR}/igmpproxy.conf ]; then cp igmpproxy.conf ${ETCDIR}; fi
 
-igmpproxy : igmpproxy.o config.o confread.o request.o udpsock.o mcgroup.o rttable.o \
-			igmp.o ifvc.o callout.o kern.o syslog.o lib.o mroute-api.o
+SRC = igmpproxy.c config.c confread.c request.c mcgroup.c rttable.c \
+			igmp.c ifvc.c callout.c kern.c syslog.c lib.c mroute-api.c
+OBJS = ${SRC:.c=.o}
+igmpproxy: build.h ${OBJS}
+	cc ${CFLAGS} ${OBJS} -o igmpproxy
 
 build.h	:  
 	echo '#define BUILD "' `date +%y%m%d` '"' >build.h
Only in .: Makefile.orig
diff -ur ../src_old/config.c ./config.c
--- ../src_old/config.c	2009-12-14 11:10:51.000000000 +0000
+++ ./config.c	2009-12-14 11:10:54.000000000 +0000
@@ -177,7 +177,7 @@
     }
 
     // Loop through all VIFs...
-    for ( Ix = 0; Dp = getIfByIx( Ix ); Ix++ ) {
+    for ( Ix = 0; (Dp = getIfByIx( Ix )); Ix++ ) {
         if ( Dp->InAdr.s_addr && ! (Dp->Flags & IFF_LOOPBACK) ) {
 
             // Now try to find a matching config...
@@ -241,7 +241,8 @@
     tmpPtr->allowednets = NULL;
 
     // Make a copy of the token to store the IF name
-    tmpPtr->name = (char *)malloc( sizeof(char) * strlen(token) );
+    //One more byte since strlen does not include the terminating NULL char.
+    tmpPtr->name = (char *)malloc( (sizeof(char) * strlen(token)) + 1 );
     if(tmpPtr->name == NULL) {
         log(LOG_ERR, 0, "Out of memory.");
     }
@@ -255,7 +256,7 @@
     while(token != NULL) {
         if(strcmp("altnet", token)==0) {
             // Altnet...
-            struct in_addr  networkAddr;
+            //struct in_addr  networkAddr;
 
             token = nextConfigToken();
             IF_DEBUG log(LOG_DEBUG, 0, "Config: IF: Got altnet token %s.",token);
@@ -347,7 +348,7 @@
         mask <<= (32 - bitcnt);
     }
 
-    if(addr == -1 || addr == 0) {
+    if(addr == (uint32) -1 || addr == 0) {
         log(LOG_WARNING, 0, "Unable to parse address token '%s'.", addrstr);
         return NULL;
     }
Only in .: config.c.orig
diff -ur ../src_old/defs.h ./defs.h
--- ../src_old/defs.h	2009-12-14 11:10:51.000000000 +0000
+++ ./defs.h	2009-12-14 11:10:54.000000000 +0000
@@ -40,10 +40,18 @@
 #include <stdlib.h>
 #include <syslog.h>
 #include <signal.h>
-
 #include <sys/socket.h>
+
+#ifdef __FreeBSD__
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#else
 #include <sys/un.h>
 #include <sys/time.h>
+#endif
 
 #include <net/if.h>
 
@@ -52,7 +60,15 @@
     #include <linux/in.h>
     #include <linux/mroute.h>
 #else
+#ifdef __FreeBSD__
+    #include <alias.h>
+    #include <net/route.h>
     #include <netinet/in.h>
+    #include <netinet/ip_mroute.h>
+    #include <netinet/igmp.h>
+#endif
+    #include <netinet/in.h>
+    #include <netinet/in_systm.h>
     #include <netinet/ip.h>
     #include <netinet/igmp.h>
     #include <arpa/inet.h>
@@ -60,7 +76,11 @@
 
 
 // The default path for the config file...
+#ifdef __FreeBSD__
+#define     IGMPPROXY_CONFIG_FILEPATH     "/usr/local/etc/igmpproxy.conf"
+#else
 #define     IGMPPROXY_CONFIG_FILEPATH     "/etc/igmpproxy.conf"
+#endif
 #define     ENABLE_DEBUG    1
 
 /*
@@ -69,12 +89,46 @@
 #define MAX_IP_PACKET_LEN	576
 #define MIN_IP_HEADER_LEN	20
 #define MAX_IP_HEADER_LEN	60
+#define HAVE_SA_LEN		1
+#define IP_HEADER_RAOPT_LEN	24
 
 #define MAX_MC_VIFS    32     // !!! check this const in the specific includes
 
+#ifndef IGMP_MEMBERSHIP_QUERY
+#define IGMP_MEMBERSHIP_QUERY IGMP_HOST_MEMBERSHIP_QUERY
+#endif
+
+#define IGMP_V3_MEMBERSHIP_QUERY 0x111 /* it's fake but we have to differentiate between V2 and V3 queries */
+#define IGMP_V3_QUERY_HDRLEN   4
+
+#ifndef IGMP_V1_MEMBERSHIP_REPORT
+#define IGMP_V1_MEMBERSHIP_REPORT IGMP_v1_HOST_MEMBERSHIP_REPORT
+#endif
+#ifndef IGMP_V2_MEMBERSHIP_REPORT
+#define IGMP_V2_MEMBERSHIP_REPORT IGMP_v2_HOST_MEMBERSHIP_REPORT
+#endif
+#ifndef IGMP_V3_MEMBERSHIP_REPORT
+#define IGMP_V3_MEMBERSHIP_REPORT IGMP_v3_HOST_MEMBERSHIP_REPORT
+#endif
+#ifndef IGMP_V2_LEAVE_GROUP
+#define IGMP_V2_LEAVE_GROUP IGMP_HOST_LEAVE_MESSAGE
+#endif
+
+
+#ifndef INADDR_ALLRTRS_GROUP
+/* address for multicast mtrace msg */
+#define INADDR_ALLRTRS_GROUP    (u_int32_t)0xe0000002   /* 224.0.0.2 */
+#endif
+#define INADDR_ALLRTRS_GROUP_V3     (u_int32_t)0xe0000016   /* 224.0.0.22 */
+#define INADDR_V3_GENQRY_GROUP      (u_int32_t)0x00000000   /* 0.0.0.0 */
+
 // Useful macros..          
+#ifndef MIN
 #define MIN( a, b ) ((a) < (b) ? (a) : (b))
+#endif
+#ifndef MAX
 #define MAX( a, b ) ((a) < (b) ? (b) : (a))
+#endif
 #define VCMC( Vc )  (sizeof( Vc ) / sizeof( (Vc)[ 0 ] ))
 #define VCEP( Vc )  (&(Vc)[ VCMC( Vc ) ])
 
@@ -126,7 +180,12 @@
 
 #define	    IF_DEBUG	if(Log2Stderr & LOG_DEBUG)
 
-void log( int Serverity, int Errno, const char *FmtSt, ... );
+#ifdef DEVEL_LOGGING
+#define log(Severity, Errno, Fmt, args...)     _log((Severity), (Errno), __FUNCTION__, __LINE__, (Fmt), ##args)
+void _log( int Serverity, int Errno, const char *func, int line, const char *FmtSt, ...);
+#else
+void log( int Serverity, int Errno, const char *FmtSt, ...);
+#endif
 
 /* ifvc.c
  */
@@ -196,6 +255,7 @@
 struct IfDesc *getIfByName( const char *IfName );
 struct IfDesc *getIfByIx( unsigned Ix );
 struct IfDesc *getIfByAddress( uint32 Ix );
+int isAdressValidForIf( struct IfDesc* intrface, uint32 ipaddr );
 
 /* mroute-api.c
  */
@@ -226,6 +286,9 @@
 */
 extern uint32 allhosts_group;
 extern uint32 allrouters_group;
+extern uint32 allrouters_group_v3;
+extern uint32 v3_genqry_allsystems;
+extern uint32 v3_genqry_group;
 void initIgmp(void);
 void acceptIgmp(int);
 void sendIgmp (uint32, uint32, int, int, uint32,int);
@@ -235,7 +298,7 @@
 char   *fmtInAdr( char *St, struct in_addr InAdr );
 char   *inetFmt(uint32 addr, char *s);
 char   *inetFmts(uint32 addr, uint32 mask, char *s);
-int     inetCksum(u_short *addr, u_int len);
+int     inetChksum(u_short *addr, u_int len);
 
 /* kern.c
  */
@@ -255,7 +318,7 @@
 
 /* mcgroup.c
  */
-int joinMcGroup( int UdpSock, struct IfDesc *IfDp, uint32 mcastaddr );
+int joinMcGroup( int UdpSock, struct IfDesc *IfDp, uint32 mcastaddr);
 int leaveMcGroup( int UdpSock, struct IfDesc *IfDp, uint32 mcastaddr );
 
 
@@ -264,14 +327,14 @@
 void initRouteTable();
 void clearAllRoutes();
 int insertRoute(uint32 group, int ifx);
-int activateRoute(uint32 group, uint32 originAddr);
+int activateRoute(uint32 group, uint32 originAddr, int downIf);
 void ageActiveRoutes();
 void setRouteLastMemberMode(uint32 group);
 int lastMemberGroupAge(uint32 group);
 
 /* request.c
  */
-void acceptGroupReport(uint32 src, uint32 group, uint8 type);
+void acceptGroupReport(uint32 src, uint32 group);
 void acceptLeaveMessage(uint32 src, uint32 group);
 void sendGeneralMembershipQuery();
 
Only in .: defs.h.orig
diff -ur ../src_old/ifvc.c ./ifvc.c
--- ../src_old/ifvc.c	2009-12-14 11:10:51.000000000 +0000
+++ ./ifvc.c	2009-12-14 11:10:54.000000000 +0000
@@ -32,7 +32,11 @@
 */
 
 #include "defs.h"
+#ifdef __FreeBSD__
+#include <ifaddrs.h>
+#else
 #include <linux/sockios.h>
+#endif
 
 struct IfDesc IfDescVc[ MAX_IF ], *IfDescEp = IfDescVc;
 
@@ -42,76 +46,44 @@
 **          
 */
 void buildIfVc() {
-    struct ifreq IfVc[ sizeof( IfDescVc ) / sizeof( IfDescVc[ 0 ] )  ];
-    struct ifreq *IfEp;
+    struct ifaddrs *ifap, *ifa;
+    struct IfDesc *ifp;
+    struct SubnetList *net;
 
-    int Sock;
-
-    if ( (Sock = socket( AF_INET, SOCK_DGRAM, 0 )) < 0 )
-        log( LOG_ERR, errno, "RAW socket open" );
-
-    /* get If vector
-     */
-    {
-        struct ifconf IoCtlReq;
-
-        IoCtlReq.ifc_buf = (void *)IfVc;
-        IoCtlReq.ifc_len = sizeof( IfVc );
-
-        if ( ioctl( Sock, SIOCGIFCONF, &IoCtlReq ) < 0 )
-            log( LOG_ERR, errno, "ioctl SIOCGIFCONF" );
-
-        IfEp = (void *)((char *)IfVc + IoCtlReq.ifc_len);
-    }
+    if (getifaddrs(&ifap) < 0)
+       log( LOG_ERR, errno, "getifaddrs" );
 
     /* loop over interfaces and copy interface info to IfDescVc
      */
     {
-        struct ifreq  *IfPt;
-        struct IfDesc *IfDp;
-
         // Temp keepers of interface params...
         uint32 addr, subnet, mask;
 
-        for ( IfPt = IfVc; IfPt < IfEp; IfPt++ ) {
-            struct ifreq IfReq;
+        for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
             char FmtBu[ 32 ];
 
-            strncpy( IfDescEp->Name, IfPt->ifr_name, sizeof( IfDescEp->Name ) );
-
-            // Currently don't set any allowed nets...
-            //IfDescEp->allowednets = NULL;
-
-            // Set the index to -1 by default.
-            IfDescEp->index = -1;
+           if (IfDescEp >= &IfDescVc[ MAX_IF ]) {
+               log(LOG_WARNING, 0, "Too many interfaces, skipping %d", ifa->ifa_name);
+                continue;
+            }
 
-            /* don't retrieve more info for non-IP interfaces
+            /* ignore non-IP interfaces
              */
-            if ( IfPt->ifr_addr.sa_family != AF_INET ) {
-                IfDescEp->InAdr.s_addr = 0;  /* mark as non-IP interface */
-                IfDescEp++;
+            if ( ifa->ifa_addr->sa_family != AF_INET )
                 continue;
-            }
 
-            // Get the interface adress...
-            IfDescEp->InAdr = ((struct sockaddr_in *)&IfPt->ifr_addr)->sin_addr;
-            addr = IfDescEp->InAdr.s_addr;
-
-            memcpy( IfReq.ifr_name, IfDescEp->Name, sizeof( IfReq.ifr_name ) );
-
-            // Get the subnet mask...
-            if (ioctl(Sock, SIOCGIFNETMASK, &IfReq ) < 0)
-                log(LOG_ERR, errno, "ioctl SIOCGIFNETMASK for %s", IfReq.ifr_name);
-            mask = ((struct sockaddr_in *)&IfReq.ifr_addr)->sin_addr.s_addr;
-            subnet = addr & mask;
+           if ((ifp = getIfByName(ifa->ifa_name)) == NULL) {
 
-            // Get the physical index of the Interface
-            if (ioctl(Sock, SIOCGIFINDEX, &IfReq ) < 0)
-                log(LOG_ERR, errno, "ioctl SIOCGIFINDEX for %s", IfReq.ifr_name);
+               strlcpy( IfDescEp->Name, ifa->ifa_name, sizeof( IfDescEp->Name ) );
+
+               log(LOG_DEBUG, 0, "Adding Physical Index value of IF '%s' is %d",
+                   IfDescEp->Name, if_nametoindex(IfDescEp->Name));
             
-            log(LOG_DEBUG, 0, "Physical Index value of IF '%s' is %d",
-                IfDescEp->Name, IfReq.ifr_ifindex);
+               // Set the index to -1 by default.
+               IfDescEp->index = -1;
 
+               // Get the interface adress...
+               IfDescEp->InAdr = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr;
 
             /* get if flags
             **
@@ -122,39 +94,43 @@
             ** grex  0x00C1 -> NoArp, Running, Up
             ** ipipx 0x00C1 -> NoArp, Running, Up
             */
-            if ( ioctl( Sock, SIOCGIFFLAGS, &IfReq ) < 0 )
-                log( LOG_ERR, errno, "ioctl SIOCGIFFLAGS" );
-
-            IfDescEp->Flags = IfReq.ifr_flags;
 
-            // Insert the verified subnet as an allowed net...
-            IfDescEp->allowednets = (struct SubnetList *)malloc(sizeof(struct SubnetList));
-            if(IfDescEp->allowednets == NULL) log(LOG_ERR, 0, "Out of memory !");
-            
-            // Create the network address for the IF..
-            IfDescEp->allowednets->next = NULL;
-            IfDescEp->allowednets->subnet_mask = mask;
-            IfDescEp->allowednets->subnet_addr = subnet;
+               IfDescEp->Flags = ifa->ifa_flags;
 
             // Set the default params for the IF...
             IfDescEp->state         = IF_STATE_DOWNSTREAM;
             IfDescEp->robustness    = DEFAULT_ROBUSTNESS;
             IfDescEp->threshold     = DEFAULT_THRESHOLD;   /* ttl limit */
             IfDescEp->ratelimit     = DEFAULT_RATELIMIT; 
+               IfDescEp->allowednets   = NULL;
+               ifp = IfDescEp++;
+           }
+
+            // Insert the verified subnet as an allowed net...
+            addr = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
+            mask = ((struct sockaddr_in *)ifa->ifa_netmask)->sin_addr.s_addr;
+            subnet = addr & mask;
             
+            net = (struct SubnetList *)malloc(sizeof(struct SubnetList));
+            if(net == NULL) log(LOG_ERR, 0, "Out of memory !");
+            
+            // Create the network address for the IF..
+            net->next = ifp->allowednets;
+            net->subnet_mask = mask;
+            net->subnet_addr = subnet;
+            ifp->allowednets = net;
 
             // Debug log the result...
             IF_DEBUG log( LOG_DEBUG, 0, "buildIfVc: Interface %s Addr: %s, Flags: 0x%04x, Network: %s",
-                 IfDescEp->Name,
-                 fmtInAdr( FmtBu, IfDescEp->InAdr ),
-                 IfDescEp->Flags,
+                 ifp->Name,
+                 fmtInAdr( FmtBu, ifp->InAdr ),
+                 ifp->Flags,
                  inetFmts(subnet,mask, s1));
 
-            IfDescEp++;
-        } 
     }
 
-    close( Sock );
+    }
+    freeifaddrs(ifap);
 }
 
 /*
Only in .: ifvc.c.orig
diff -ur ../src_old/igmp.c ./igmp.c
--- ../src_old/igmp.c	2009-12-14 11:10:51.000000000 +0000
+++ ./igmp.c	2009-12-14 11:11:51.000000000 +0000
@@ -35,11 +35,15 @@
 *            appropriately...
 */
 
+#include <sys/param.h>
+
 #include "defs.h"
  
 // Globals                  
 uint32     allhosts_group;          /* All hosts addr in net order */
-uint32     allrouters_group;          /* All hosts addr in net order */
+uint32     allrouters_group;        /* All hosts addr in net order */
+uint32     allrouters_group_v3;
+uint32     v3_genqry_group;
               
 extern int MRouterFD;
 
@@ -67,13 +71,15 @@
      * - Checksum (let the kernel fill it in)
      */
     ip->ip_v   = IPVERSION;
-    ip->ip_hl  = sizeof(struct ip) >> 2;
+    ip->ip_hl  = (sizeof(struct ip) + 4) >> 2; /* +4 for Router Alert option */
     ip->ip_tos = 0xc0;      /* Internet Control */
     ip->ip_ttl = MAXTTL;    /* applies to unicasts only */
     ip->ip_p   = IPPROTO_IGMP;
 
     allhosts_group   = htonl(INADDR_ALLHOSTS_GROUP);
     allrouters_group = htonl(INADDR_ALLRTRS_GROUP);
+    allrouters_group_v3  = htonl(INADDR_ALLRTRS_GROUP_V3);
+    v3_genqry_group      = htonl(INADDR_V3_GENQRY_GROUP);
 }
 
 /**
@@ -87,6 +93,8 @@
     case IGMP_V1_MEMBERSHIP_REPORT:  return "V1 member report  ";
     case IGMP_V2_MEMBERSHIP_REPORT:  return "V2 member report  ";
     case IGMP_V2_LEAVE_GROUP:        return "Leave message     ";
+    case IGMP_V3_MEMBERSHIP_REPORT:  return "V3 member report  ";
+    case IGMP_V3_MEMBERSHIP_QUERY:   return "V3 membership query ";
     
     default:
         sprintf(unknown, "unk: 0x%02x/0x%02x    ", type, code);
@@ -103,9 +111,12 @@
     register uint32 src, dst, group;
     struct ip *ip;
     struct igmp *igmp;
+    struct igmpv3 *igmp_v3;
+    struct igmp_grouprec* igmp_gr;
+
     int ipdatalen, iphdrlen, igmpdatalen;
 
-    if (recvlen < sizeof(struct ip)) {
+    if (recvlen < (int) sizeof(struct ip)) {
         log(LOG_WARNING, 0,
             "received packet too short (%u bytes) for IP header", recvlen);
         return;
@@ -115,7 +126,7 @@
     src       = ip->ip_src.s_addr;
     dst       = ip->ip_dst.s_addr;
 
-    //IF_DEBUG log(LOG_DEBUG, 0, "Got a IGMP request to process...");
+    IF_DEBUG log(LOG_DEBUG, 0, "Got a IGMP request to process...");
 
     /* 
      * this is most likely a message from the kernel indicating that
@@ -128,6 +139,7 @@
         }
         else {
             struct IfDesc *checkVIF;
+           int downIf = -1;
             
             // Check if the source address matches a valid address on upstream vif.
             checkVIF = getIfByIx( upStreamVif );
@@ -141,23 +153,44 @@
                 return;
             }
             else if(!isAdressValidForIf(checkVIF, src)) {
+               unsigned Ix;
+               struct IfDesc *Dp;
+               for ( Ix = 0; (Dp = getIfByIx( Ix )); Ix++ ) {
+                   if ((Dp->state == IF_STATE_DOWNSTREAM) &&isAdressValidForIf(Dp, src)) {
+                       downIf = Ix;
+                       break;
+                   }
+               }
+               
+               if (downIf == -1) {
                 log(LOG_WARNING, 0, "The source address %s for group %s, is not in any valid net for upstream VIF.",
                     inetFmt(src, s1), inetFmt(dst, s2));
                 return;
+               } else {
+                   log(LOG_NOTICE, 0, "The source address %s for group %s, is valid DOWNSTREAM VIF #%d.",
+                       inetFmt(src, s1), inetFmt(dst, s2), downIf);
+               }
             }
             
             // Activate the route.
-            IF_DEBUG log(LOG_DEBUG, 0, "Route activate request from %s to %s",
-                         inetFmt(src,s1), inetFmt(dst,s2));
-            activateRoute(dst, src);
+            IF_DEBUG log(LOG_DEBUG, 0, "Route activate request from %s to %s, downIf %d",
+                         inetFmt(src,s1), inetFmt(dst,s2), downIf);
+            activateRoute(dst, src, downIf);
             
 
         }
         return;
     }
 
+    log(LOG_DEBUG, 0, "Packet from %s: proto: %d hdrlen: %d iplen: %d or %d", 
+                   inetFmt(src, s1), ip->ip_p, ip->ip_hl << 2, ip->ip_len, ntohs(ip->ip_len));
+
     iphdrlen  = ip->ip_hl << 2;
-    ipdatalen = ntohs(ip->ip_len) - iphdrlen;
+#if __FreeBSD_version >= 900044
+    ipdatalen = ip->ip_len - (ip->ip_hl << 2);
+#else
+    ipdatalen = ip->ip_len;
+#endif
 
     if (iphdrlen + ipdatalen != recvlen) {
         log(LOG_WARNING, 0,
@@ -167,7 +200,14 @@
     }
 
     igmp        = (struct igmp *)(recv_buf + iphdrlen);
-    group       = igmp->igmp_group.s_addr;
+    igmp_v3     = (struct igmpv3 *)(recv_buf + iphdrlen);
+
+    if (igmp->igmp_type == IGMP_V3_MEMBERSHIP_REPORT){
+      igmp_gr     = (struct igmp_grouprec*)((char*)igmp_v3+8); /*  Start of group record */
+      group       = igmp_gr->ig_group.s_addr;
+    }else
+      group       = igmp->igmp_group.s_addr;
+
     igmpdatalen = ipdatalen - IGMP_MINLEN;
     if (igmpdatalen < 0) {
         log(LOG_WARNING, 0,
@@ -176,27 +216,32 @@
         return;
     }
 
-    log(LOG_NOTICE, 0, "RECV %s from %-15s to %s",
+    log(LOG_NOTICE, 0, "RECV %s from %-15s to %s (ip_hl %d, data %d)",
         igmpPacketKind(igmp->igmp_type, igmp->igmp_code),
-        inetFmt(src, s1), inetFmt(dst, s2) );
+        inetFmt(src, s1), inetFmt(dst, s2), iphdrlen, ipdatalen);
 
-    switch (igmp->igmp_type) {
+   switch (igmp->igmp_type) {
     case IGMP_V1_MEMBERSHIP_REPORT:
     case IGMP_V2_MEMBERSHIP_REPORT:
-        acceptGroupReport(src, group, igmp->igmp_type);
+        acceptGroupReport(src, group);
+        return;
+    case IGMP_V3_MEMBERSHIP_REPORT:
+        if ( ((u_char*)igmp_v3)[8] == (u_char)4 ){       /* Change To Exclude Mode - join */
+          acceptGroupReport(src, group);
+        }else if ( ((u_char*)igmp_v3)[8] == (u_char)3 )  /* Change To Include Mode - leave */
+          acceptLeaveMessage(src, group);
+        else
+          log(LOG_WARNING, 0, "unknown Mode in V3 report (%u)", (u_char*)igmp_v3+8);
         return;
     
     case IGMP_V2_LEAVE_GROUP:
         acceptLeaveMessage(src, group);
         return;
     
-        /*
     case IGMP_MEMBERSHIP_QUERY:
-        //accept_membership_query(src, dst, group, igmp->igmp_code);
+        log(LOG_INFO, 0, "ignoring membership query");
         return;
 
-    */
-
     default:
         log(LOG_INFO, 0,
             "ignoring unknown IGMP message type %x from %s to %s",
@@ -214,27 +259,70 @@
 void buildIgmp(uint32 src, uint32 dst, int type, int code, uint32 group, int datalen) {
     struct ip *ip;
     struct igmp *igmp;
+    struct igmpv3 *igmp_v3;
+    struct igmp_report *igmp_rep;
     extern int curttl;
 
     ip                      = (struct ip *)send_buf;
     ip->ip_src.s_addr       = src;
     ip->ip_dst.s_addr       = dst;
-    ip->ip_len              = MIN_IP_HEADER_LEN + IGMP_MINLEN + datalen;
+    ip->ip_len              = IP_HEADER_RAOPT_LEN + IGMP_MINLEN + datalen;
+#ifdef RAW_OUTPUT_IS_RAW
     ip->ip_len              = htons(ip->ip_len);
-
+#endif
     if (IN_MULTICAST(ntohl(dst))) {
         ip->ip_ttl = curttl;
     } else {
         ip->ip_ttl = MAXTTL;
     }
 
-    igmp                    = (struct igmp *)(send_buf + MIN_IP_HEADER_LEN);
-    igmp->igmp_type         = type;
-    igmp->igmp_code         = code;
-    igmp->igmp_group.s_addr = group;
-    igmp->igmp_cksum        = 0;
-    igmp->igmp_cksum        = inetChksum((u_short *)igmp,
-                                         IGMP_MINLEN + datalen);
+    // Add Router Alert option
+    ((char*)send_buf+MIN_IP_HEADER_LEN)[0] = IPOPT_RA;
+    ((char*)send_buf+MIN_IP_HEADER_LEN)[1] = 0x04;
+    ((char*)send_buf+MIN_IP_HEADER_LEN)[2] = 0x00;
+    ((char*)send_buf+MIN_IP_HEADER_LEN)[3] = 0x00;
+
+    if (type == IGMP_V3_MEMBERSHIP_REPORT){
+      ip->ip_dst.s_addr       = allrouters_group_v3;
+      ip->ip_len              = IP_HEADER_RAOPT_LEN + IGMP_MINLEN + IGMP_GRPREC_HDRLEN + datalen;
+      igmp_rep                    = (struct igmp_report *)(send_buf + IP_HEADER_RAOPT_LEN);
+      igmp_rep->ir_type         = type;
+      igmp_rep->ir_rsv1         = 0;
+      igmp_rep->ir_cksum        = 0;
+      igmp_rep->ir_rsv2         = 0;
+      igmp_rep->ir_numgrps      = 0x0100;
+
+#if __FreeBSD_version < 800000
+      igmp_rep->ir_groups[0].ig_type         = (u_char)4;  /* Change To Exclude Mode */
+      igmp_rep->ir_groups[0].ig_datalen      = (u_char)0;  /* length of auxiliary data */
+      igmp_rep->ir_groups[0].ig_numsrc       = (u_short)0; /* number of sources */
+      igmp_rep->ir_groups[0].ig_group.s_addr = group;      /*  group address being reported */
+#endif
+
+      igmp_rep->ir_cksum        = inetChksum((u_short *)igmp_rep,
+                                           IGMP_MINLEN + IGMP_GRPREC_HDRLEN + datalen);
+    }else if (type == IGMP_V3_MEMBERSHIP_QUERY){
+      ip->ip_dst.s_addr          = allhosts_group;
+      ip->ip_len                 = IP_HEADER_RAOPT_LEN + IGMP_MINLEN + IGMP_V3_QUERY_HDRLEN + datalen;
+      igmp_v3                    = (struct igmpv3 *)(send_buf + IP_HEADER_RAOPT_LEN);
+      igmp_v3->igmp_type         = IGMP_MEMBERSHIP_QUERY;
+      igmp_v3->igmp_code         = code;
+      igmp_v3->igmp_cksum        = 0;
+      igmp_v3->igmp_group.s_addr = group;
+      igmp_v3->igmp_misc         = 0x2; /* S-flag=0 - Do not suppress router side processing */  
+                                        /* QRV   =2 - Querier's Robustness Variable */ 
+      igmp_v3->igmp_cksum        = inetChksum((u_short *)igmp_v3,
+                                           IGMP_MINLEN + IGMP_V3_QUERY_HDRLEN + datalen);
+
+    }else{
+      igmp                    = (struct igmp *)(send_buf + IP_HEADER_RAOPT_LEN);
+      igmp->igmp_type         = type;
+      igmp->igmp_code         = code;
+      igmp->igmp_group.s_addr = group;
+      igmp->igmp_cksum        = 0;
+      igmp->igmp_cksum        = inetChksum((u_short *)igmp,
+                                           IGMP_MINLEN + datalen);
+    }
 }
 
 /* 
@@ -244,9 +332,11 @@
  */
 void sendIgmp(uint32 src, uint32 dst, int type, int code, uint32 group, int datalen) {
     struct sockaddr_in sdst;
+    struct igmp_report *igmp_rep;
     int setloop = 0, setigmpsource = 0;
 
-    buildIgmp(src, dst, type, code, group, datalen);
+    if (type != IGMP_V2_LEAVE_GROUP) /* for leave buld later */
+      buildIgmp(src, dst, type, code, group, datalen);
 
     if (IN_MULTICAST(ntohl(dst))) {
         k_set_if(src);
@@ -262,16 +352,83 @@
 #ifdef HAVE_SA_LEN
     sdst.sin_len = sizeof(sdst);
 #endif
-    sdst.sin_addr.s_addr = dst;
-    if (sendto(MRouterFD, send_buf,
-               MIN_IP_HEADER_LEN + IGMP_MINLEN + datalen, 0,
-               (struct sockaddr *)&sdst, sizeof(sdst)) < 0) {
-        if (errno == ENETDOWN)
+    if ( type == IGMP_V3_MEMBERSHIP_REPORT ){
+        sdst.sin_addr.s_addr = allrouters_group_v3;
+        if (sendto(MRouterFD, send_buf,
+                   IP_HEADER_RAOPT_LEN + IGMP_MINLEN + IGMP_GRPREC_HDRLEN + datalen, 0,
+                  (struct sockaddr *)&sdst, sizeof(sdst)) < 0) {
+            if (errno == ENETDOWN)
+                log(LOG_ERR, errno, "Sender VIF was down.");
+            else
+                log(LOG_INFO, errno,
+                    "sendto to %s on %s",
+                    inetFmt(allrouters_group_v3, s1), inetFmt(src, s2));
+        }
+        else{
+	    IF_DEBUG log(LOG_DEBUG, 0, "SENT %s from %-15s to %s",
+                igmpPacketKind(type, code), src == INADDR_ANY ? "INADDR_ANY" :
+                inetFmt(src, s1), inetFmt(allrouters_group_v3, s2));
+        }
+    }else if ( type == IGMP_V3_MEMBERSHIP_QUERY ){
+        sdst.sin_addr.s_addr = allhosts_group;
+        if (sendto(MRouterFD, send_buf,
+                   IP_HEADER_RAOPT_LEN + IGMP_MINLEN + IGMP_V3_QUERY_HDRLEN + datalen, 0,
+                  (struct sockaddr *)&sdst, sizeof(sdst)) < 0) {
+            if (errno == ENETDOWN)
+                log(LOG_ERR, errno, "Sender VIF was down.");
+            else
+                log(LOG_INFO, errno,
+                    "sendto to %s on %s",
+                    inetFmt(allhosts_group, s1), inetFmt(src, s2));
+        }
+        else{
+	    IF_DEBUG log(LOG_DEBUG, 0, "SENT %s from %-15s to %s",
+                igmpPacketKind(type, code), src == INADDR_ANY ? "INADDR_ANY" :
+                inetFmt(src, s1), inetFmt(allhosts_group, s2));
+       }
+    }else if (type == IGMP_V2_LEAVE_GROUP){
+        /* we have to send V3 leave as well */
+        buildIgmp(src, allrouters_group_v3, IGMP_V3_MEMBERSHIP_REPORT, code, group, datalen);
+        sdst.sin_addr.s_addr = allrouters_group_v3;
+        igmp_rep                       = (struct igmp_report *)(send_buf + IP_HEADER_RAOPT_LEN);
+#if __FreeBSD_version < 750000
+        igmp_rep->ir_groups[0].ig_type = (u_char)3;                 /* Change To Include Mode - leave */
+#endif
+        igmp_rep->ir_cksum        = inetChksum((u_short *)igmp_rep, /* recalculate checksum */
+                                               IGMP_MINLEN + IGMP_GRPREC_HDRLEN + datalen);
+
+        if (sendto(MRouterFD, send_buf,
+                   IP_HEADER_RAOPT_LEN + IGMP_MINLEN + IGMP_GRPREC_HDRLEN + datalen, 0,
+                   (struct sockaddr *)&sdst, sizeof(sdst)) < 0) {
+          if (errno == ENETDOWN)
             log(LOG_ERR, errno, "Sender VIF was down.");
-        else
+          else
             log(LOG_INFO, errno,
                 "sendto to %s on %s",
-                inetFmt(dst, s1), inetFmt(src, s2));
+                inetFmt(allrouters_group_v3, s1), inetFmt(src, s2));
+        }
+        else{
+	  IF_DEBUG log(LOG_DEBUG, 0, "SENT %s from %-15s to %s",
+              "V3 report with leave", src == INADDR_ANY ? "INADDR_ANY" :
+              inetFmt(src, s1), inetFmt(allrouters_group_v3, s2));
+        }
+    }else{
+        sdst.sin_addr.s_addr = dst;
+        if (sendto(MRouterFD, send_buf,
+                   IP_HEADER_RAOPT_LEN + IGMP_MINLEN + datalen, 0,
+                   (struct sockaddr *)&sdst, sizeof(sdst)) < 0) {
+            if (errno == ENETDOWN)
+                log(LOG_ERR, errno, "Sender VIF was down.");
+            else
+                log(LOG_INFO, errno,
+                    "sendto to %s on %s",
+                    inetFmt(dst, s1), inetFmt(src, s2));
+        }
+        else{
+	    IF_DEBUG log(LOG_DEBUG, 0, "SENT %s from %-15s to %s",
+                igmpPacketKind(type, code), src == INADDR_ANY ? "INADDR_ANY" :
+                inetFmt(src, s1), inetFmt(dst, s2));
+        }
     }
 
     if(setigmpsource) {
@@ -282,8 +439,5 @@
         k_set_if(INADDR_ANY);
     }
 
-    IF_DEBUG log(LOG_DEBUG, 0, "SENT %s from %-15s to %s",
-        igmpPacketKind(type, code), src == INADDR_ANY ? "INADDR_ANY" :
-        inetFmt(src, s1), inetFmt(dst, s2));
 }
 
Only in .: igmp.c.orig
diff -ur ../src_old/igmpproxy.c ./igmpproxy.c
--- ../src_old/igmpproxy.c	2009-12-14 11:10:51.000000000 +0000
+++ ./igmpproxy.c	2009-12-14 11:10:54.000000000 +0000
@@ -80,7 +80,7 @@
 *   on commandline. The number of commandline arguments, and a
 *   pointer to the arguments are recieved on the line...
 */    
-int main( int ArgCn, const char *ArgVc[] ) {
+int main( int ArgCn, char *ArgVc[] ) {
 
     int debugMode = 0;
 
@@ -155,18 +155,9 @@
         if ( ! debugMode ) {
     
             IF_DEBUG log( LOG_DEBUG, 0, "Starting daemon mode.");
-    
-            // Only daemon goes past this line...
-            if (fork()) exit(0);
-    
-            // Detach deamon from terminal
-            if ( close( 0 ) < 0 || close( 1 ) < 0 || close( 2 ) < 0 
-                 || open( "/dev/null", 0 ) != 0 || dup2( 0, 1 ) < 0 || dup2( 0, 2 ) < 0
-                 || setpgrp() < 0
-               ) {
+           if (daemon(1, 0) != 0)
                 log( LOG_ERR, errno, "failed to detach deamon" );
             }
-        }
         
         // Go to the main loop.
         igmpProxyRun();
@@ -218,7 +209,7 @@
         int     vifcount = 0;
         upStreamVif = -1;
 
-        for ( Ix = 0; Dp = getIfByIx( Ix ); Ix++ ) {
+        for ( Ix = 0; (Dp = getIfByIx( Ix )); Ix++ ) {
 
             if ( Dp->InAdr.s_addr && ! (Dp->Flags & IFF_LOOPBACK) ) {
                 if(Dp->state == IF_STATE_UPSTREAM) {
@@ -237,7 +228,7 @@
 
         // If there is only one VIF, or no defined upstream VIF, we send an error.
         if(vifcount < 2 || upStreamVif < 0) {
-            log(LOG_ERR, 0, "There must be at least 2 Vif's where one is upstream.");
+            log(LOG_ERR, 0, "There must be at least 2 Vif's where one is upstream. (vifcount %d, upStreamVif %d)", vifcount, upStreamVif);
         }
     }  
     
@@ -275,7 +266,7 @@
     register int recvlen;
     int     MaxFD, Rt, secs;
     fd_set  ReadFDS;
-    int     dummy = 0;
+    socklen_t  dummy = 0;
     struct  timeval  curtime, lasttime, difftime, tv; 
     // The timeout is a pointer in order to set it to NULL if nessecary.
     struct  timeval  *timeout = &tv;
@@ -324,12 +315,12 @@
             continue;
         }
         else if( Rt > 0 ) {
-
             // Read IGMP request, and handle it...
             if( FD_ISSET( MRouterFD, &ReadFDS ) ) {
     
                 recvlen = recvfrom(MRouterFD, recv_buf, RECV_BUF_SIZE,
                                    0, NULL, &dummy);
+
                 if (recvlen < 0) {
                     if (errno != EINTR) log(LOG_ERR, errno, "recvfrom");
                     continue;
Only in .: igmpproxy.c.orig
diff -ur ../src_old/igmpproxy.conf ./igmpproxy.conf
--- ../src_old/igmpproxy.conf	2009-12-14 11:10:51.000000000 +0000
+++ ./igmpproxy.conf	2009-12-14 11:10:54.000000000 +0000
@@ -25,22 +25,22 @@
 
 
 ##------------------------------------------------------
-## Configuration for eth0 (Upstream Interface)
+## Configuration for em0 (Upstream Interface)
 ##------------------------------------------------------
-phyint eth0 upstream  ratelimit 0  threshold 1
+phyint em0 upstream  ratelimit 0  threshold 1
         altnet 10.0.0.0/8 
         altnet 192.168.0.0/24
 
 
 ##------------------------------------------------------
-## Configuration for eth1 (Downstream Interface)
+## Configuration for em1 (Downstream Interface)
 ##------------------------------------------------------
-phyint eth1 downstream  ratelimit 0  threshold 1
+phyint em1 downstream  ratelimit 0  threshold 1
 
 
 ##------------------------------------------------------
-## Configuration for eth2 (Disabled Interface)
+## Configuration for xl0 (Disabled Interface)
 ##------------------------------------------------------
-phyint eth2 disabled
+phyint xl0 disabled
 
 
Only in .: igmpproxy.conf.orig
diff -ur ../src_old/mcgroup.c ./mcgroup.c
--- ../src_old/mcgroup.c	2009-12-14 11:10:51.000000000 +0000
+++ ./mcgroup.c	2009-12-14 11:10:54.000000000 +0000
@@ -44,16 +44,15 @@
 static int joinleave( int Cmd, int UdpSock, struct IfDesc *IfDp, uint32 mcastaddr ) {
     struct ip_mreq CtlReq;
     const char *CmdSt = Cmd == 'j' ? "join" : "leave";
-    
+
     CtlReq.imr_multiaddr.s_addr = mcastaddr;
     CtlReq.imr_interface.s_addr = IfDp->InAdr.s_addr;
     
     {
-        char FmtBu[ 32 ];
         log( LOG_NOTICE, 0, "%sMcGroup: %s on %s", CmdSt, 
             inetFmt( mcastaddr, s1 ), IfDp ? IfDp->Name : "<any>" );
     }
-    
+#if __FreeBSD_version < 800000
     if( setsockopt( UdpSock, IPPROTO_IP, 
           Cmd == 'j' ? IP_ADD_MEMBERSHIP : IP_DROP_MEMBERSHIP, 
           (void *)&CtlReq, sizeof( CtlReq ) ) ) 
@@ -61,6 +60,23 @@
         log( LOG_WARNING, errno, "MRT_%s_MEMBERSHIP failed", Cmd == 'j' ? "ADD" : "DROP" );
         return 1;
     }
+#else
+    if( setsockopt( UdpSock, IPPROTO_IP,
+          Cmd == 'j' ? IP_ADD_SOURCE_MEMBERSHIP : IP_DROP_SOURCE_MEMBERSHIP,
+          (void *)&CtlReq, sizeof( CtlReq ) ) )
+    {
+        log( LOG_WARNING, errno, "MRT_%s_MEMBERSHIP failed", Cmd == 'j' ? "ADD" : "DROP" );
+        return 1;
+    }
+#endif
+    /* setsockopt() causes IGMP_V2_MEMBERSHIPT_REPORT sent out of Upstream interface */
+    /* Send IGMP packet on upstream interface */
+    if( Cmd == 'j' ){
+        sendIgmp(IfDp->InAdr.s_addr, mcastaddr, IGMP_V3_MEMBERSHIP_REPORT, 0, mcastaddr, 0);
+    }
+    else
+        sendIgmp(IfDp->InAdr.s_addr, mcastaddr, IGMP_V2_LEAVE_GROUP, 0, mcastaddr, 0);
+        /* V3 leave will be sent inside sendIgmp() */
     
     return 0;
 }
Only in .: mcgroup.c.orig
diff -ur ../src_old/mroute-api.c ./mroute-api.c
--- ../src_old/mroute-api.c	2009-12-14 11:10:51.000000000 +0000
+++ ./mroute-api.c	2009-12-14 11:10:54.000000000 +0000
@@ -37,7 +37,9 @@
 */
 
 
+#ifndef __FreeBSD__
 #define USE_LINUX_IN_H
+#endif
 #include "defs.h"
 
 // MAX_MC_VIFS from mclab.h must have same value as MAXVIFS from mroute.h
@@ -47,7 +49,7 @@
      
 // need an IGMP socket as interface for the mrouted API
 // - receives the IGMP messages
-int         MRouterFD;        /* socket for all network I/O  */
+int         MRouterFD = -1;        /* socket for all network I/O  */
 char        *recv_buf;           /* input packet buffer         */
 char        *send_buf;           /* output packet buffer        */
 
@@ -177,13 +179,15 @@
         log( LOG_NOTICE, 0, "Adding MFC: %s -> %s, InpVIf: %d", 
              fmtInAdr( FmtBuO, CtlReq.mfcc_origin ), 
              fmtInAdr( FmtBuM, CtlReq.mfcc_mcastgrp ),
-             CtlReq.mfcc_parent == ALL_VIFS ? -1 : CtlReq.mfcc_parent
+             CtlReq.mfcc_parent
            );
     }
 
     if ( setsockopt( MRouterFD, IPPROTO_IP, MRT_ADD_MFC,
                      (void *)&CtlReq, sizeof( CtlReq ) ) )
         log( LOG_WARNING, errno, "MRT_ADD_MFC" );
+
+    return 0;
 }
 
 /*
@@ -210,13 +214,15 @@
         log( LOG_NOTICE, 0, "Removing MFC: %s -> %s, InpVIf: %d", 
              fmtInAdr( FmtBuO, CtlReq.mfcc_origin ), 
              fmtInAdr( FmtBuM, CtlReq.mfcc_mcastgrp ),
-             CtlReq.mfcc_parent == ALL_VIFS ? -1 : CtlReq.mfcc_parent
+             CtlReq.mfcc_parent
            );
     }
 
     if ( setsockopt( MRouterFD, IPPROTO_IP, MRT_DEL_MFC,
                      (void *)&CtlReq, sizeof( CtlReq ) ) )
         log( LOG_WARNING, errno, "MRT_DEL_MFC" );
+
+    return 0;
 }
 
 /*
Only in .: mroute-api.c.orig
diff -ur ../src_old/request.c ./request.c
--- ../src_old/request.c	2009-12-14 11:10:51.000000000 +0000
+++ ./request.c	2009-12-14 11:10:54.000000000 +0000
@@ -53,7 +53,7 @@
 *   Handles incoming membership reports, and
 *   appends them to the routing table.
 */
-void acceptGroupReport(uint32 src, uint32 group, uint8 type) {
+void acceptGroupReport(uint32 src, uint32 group) {
     struct IfDesc  *sourceVif;
 
     // Sanitycheck the group adress...
@@ -88,10 +88,11 @@
 
     } else {
         // Log the state of the interface the report was recieved on.
-        log(LOG_INFO, 0, "Mebership report was recieved on %s. Ignoring.",
+        log(LOG_INFO, 0, "Membership report was received on %s. Ignoring.",
             sourceVif->state==IF_STATE_UPSTREAM?"the upstream interface":"a disabled interface");
     }
 
+//    log(LOG_DEBUG, 0, "Eliminate compiler warning for field type = %u", type);
 }
 
 /**
@@ -136,7 +137,7 @@
 
     } else {
         // just ignore the leave request...
-        IF_DEBUG log(LOG_DEBUG, 0, "The found if for %s was not downstream. Ignoring leave request.");
+        IF_DEBUG log(LOG_DEBUG, 0, "The found if for %s was not downstream. Ignoring leave request.",  inetFmt(src, s1));
     }
 }
 
@@ -169,6 +170,16 @@
         inetFmt(gvDesc->vifAddr,s1), inetFmt(gvDesc->group,s2),
         conf->lastMemberQueryInterval);
 
+    // Send a group specific V3 membership query...
+    sendIgmp(gvDesc->vifAddr, allhosts_group, 
+             IGMP_V3_MEMBERSHIP_QUERY,
+             conf->lastMemberQueryInterval * IGMP_TIMER_SCALE, 
+             gvDesc->group, 0);
+
+    IF_DEBUG log(LOG_DEBUG, 0, "Sent membership query from %s to %s. Delay: %d",
+        inetFmt(gvDesc->vifAddr,s1), inetFmt(allhosts_group,s2),
+        conf->lastMemberQueryInterval);
+
     // Set timeout for next round...
     timer_setTimer(conf->lastMemberQueryInterval, sendGroupSpecificMemberQuery, gvDesc);
 
@@ -184,7 +195,7 @@
     int             Ix;
 
     // Loop through all downstream vifs...
-    for ( Ix = 0; Dp = getIfByIx( Ix ); Ix++ ) {
+    for ( Ix = 0; (Dp = getIfByIx( Ix )); Ix++ ) {
         if ( Dp->InAdr.s_addr && ! (Dp->Flags & IFF_LOOPBACK) ) {
             if(Dp->state == IF_STATE_DOWNSTREAM) {
                 // Send the membership query...
@@ -192,9 +203,18 @@
                          IGMP_MEMBERSHIP_QUERY,
                          conf->queryResponseInterval * IGMP_TIMER_SCALE, 0, 0);
                 
-                IF_DEBUG log(LOG_DEBUG, 0, "Sent membership query from %s to %s. Delay: %d",
+                IF_DEBUG log(LOG_DEBUG, 0, "Sent V2 membership query from %s to %s. Delay: %d",
                     inetFmt(Dp->InAdr.s_addr,s1), inetFmt(allhosts_group,s2),
                     conf->queryResponseInterval);
+
+                sendIgmp(Dp->InAdr.s_addr, allhosts_group, 
+                         IGMP_V3_MEMBERSHIP_QUERY,
+                         conf->queryResponseInterval * IGMP_TIMER_SCALE, v3_genqry_group, 0);
+                
+                IF_DEBUG log(LOG_DEBUG, 0, "Sent V3 membership query from %s to %s. Delay: %d",
+                    inetFmt(Dp->InAdr.s_addr,s1), inetFmt(allhosts_group,s2),
+                    conf->queryResponseInterval);
+
             }
         }
     }
Only in .: request.c.orig
diff -ur ../src_old/rttable.c ./rttable.c
--- ../src_old/rttable.c	2009-12-14 11:10:51.000000000 +0000
+++ ./rttable.c	2009-12-14 11:10:54.000000000 +0000
@@ -38,15 +38,22 @@
 */
 
 #include "defs.h"
+#include <sys/queue.h>
     
 /**
 *   Routing table structure definition. Double linked list...
 */
+struct Origin {
+    TAILQ_ENTRY(Origin) next;
+    uint32             originAddr;
+    int                        flood;
+    uint32             pktcnt;
+};
+
 struct RouteTable {
     struct RouteTable   *nextroute;     // Pointer to the next group in line.
     struct RouteTable   *prevroute;     // Pointer to the previous group in line.
     uint32              group;          // The group to route
-    uint32              originAddr;     // The origin adress (only set on activated routes)
     uint32              vifBits;        // Bits representing recieving VIFs.
 
     // Keeps the upstream membership state...
@@ -56,6 +63,7 @@
     uint32              ageVifBits;     // Bits representing aging VIFs.
     int                 ageValue;       // Downcounter for death.          
     int                 ageActivity;    // Records any acitivity that notes there are still listeners.
+    TAILQ_HEAD(originhead, Origin) originList; // The origin adresses (non-empty on activated routes)
 };
 
                  
@@ -65,19 +73,17 @@
 // Prototypes
 void logRouteTable(char *header);
 int  internAgeRoute(struct RouteTable*  croute);
-
-// Socket for sending join or leave requests.
-int mcGroupSock = 0;
+int internUpdateKernelRoute(struct RouteTable *route, int activate, struct Origin *o);
 
 
 /**
 *   Function for retrieving the Multicast Group socket.
 */
 int getMcGroupSock() {
-    if( ! mcGroupSock ) {
-        mcGroupSock = openUdpSocket( INADDR_ANY, 0 );;
+    if (MRouterFD < 0) {
+           log(LOG_ERR, errno, "no MRouterFD.");
     }
-    return mcGroupSock;
+    return MRouterFD;
 }
  
 /**
@@ -91,13 +97,12 @@
     routing_table = NULL;
 
     // Join the all routers group on downstream vifs...
-    for ( Ix = 0; Dp = getIfByIx( Ix ); Ix++ ) {
+    for ( Ix = 0; (Dp = getIfByIx( Ix )); Ix++ ) {
         // If this is a downstream vif, we should join the All routers group...
         if( Dp->InAdr.s_addr && ! (Dp->Flags & IFF_LOOPBACK) && Dp->state == IF_STATE_DOWNSTREAM) {
             IF_DEBUG log(LOG_DEBUG, 0, "Joining all-routers group %s on vif %s",
                          inetFmt(allrouters_group,s1),inetFmt(Dp->InAdr.s_addr,s2));
-            
-            //k_join(allrouters_group, Dp->InAdr.s_addr);
+
             joinMcGroup( getMcGroupSock(), Dp, allrouters_group );
         }
     }
@@ -160,6 +165,7 @@
 */
 void clearAllRoutes() {
     struct RouteTable   *croute, *remainroute;
+    struct Origin *o;
 
     // Loop through all routes...
     for(croute = routing_table; croute; croute = remainroute) {
@@ -171,7 +177,7 @@
                      inetFmt(croute->group, s1));
 
         // Uninstall current route
-        if(!internUpdateKernelRoute(croute, 0)) {
+        if(!internUpdateKernelRoute(croute, 0, NULL)) {
             log(LOG_WARNING, 0, "The removal from Kernel failed.");
         }
 
@@ -179,6 +185,10 @@
         sendJoinLeaveUpstream(croute, 0);
 
         // Clear memory, and set pointer to next route...
+        while ((o = TAILQ_FIRST(&croute->originList))) {
+            TAILQ_REMOVE(&croute->originList, o, next);
+            free(o);
+        }
         free(croute);
     }
     routing_table = NULL;
@@ -212,7 +222,6 @@
     
     struct Config *conf = getCommonConfig();
     struct RouteTable*  croute;
-    int result = 1;
 
     // Sanitycheck the group adress...
     if( ! IN_MULTICAST( ntohl(group) )) {
@@ -241,7 +250,8 @@
         newroute = (struct RouteTable*)malloc(sizeof(struct RouteTable));
         // Insert the route desc and clear all pointers...
         newroute->group      = group;
-        newroute->originAddr = 0;
+        TAILQ_INIT(&newroute->originList);
+
         newroute->nextroute  = NULL;
         newroute->prevroute  = NULL;
 
@@ -312,6 +322,9 @@
         log(LOG_INFO, 0, "Inserted route table entry for %s on VIF #%d",
             inetFmt(croute->group, s1),ifx);
 
+        // Send Join request upstream
+        sendJoinLeaveUpstream(croute, 1);
+
     } else if(ifx >= 0) {
 
         // The route exists already, so just update it.
@@ -325,20 +338,25 @@
             inetFmt(croute->group, s1), ifx);
 
         // If the route is active, it must be reloaded into the Kernel..
-        if(croute->originAddr != 0) {
+        if(!TAILQ_EMPTY(&croute->originList)) {
 
             // Update route in kernel...
-            if(!internUpdateKernelRoute(croute, 1)) {
+            if(!internUpdateKernelRoute(croute, 1, NULL)) {
                 log(LOG_WARNING, 0, "The insertion into Kernel failed.");
                 return 0;
             }
         }
-    }
-
-    // Send join message upstream, if the route has no joined flag...
-    if(croute->upstrState != ROUTESTATE_JOINED) {
-        // Send Join request upstream
-        sendJoinLeaveUpstream(croute, 1);
+        struct IfDesc*      upstrIf;
+    
+        // Get the upstream VIF...
+        upstrIf = getIfByIx( upStreamVif );
+        if(upstrIf == NULL) {
+            log(LOG_ERR, 0 ,"FATAL: Unable to get Upstream IF.");
+        }else{
+            // Send join message upstream
+            sendIgmp(upstrIf->InAdr.s_addr, allrouters_group_v3, IGMP_V3_MEMBERSHIP_REPORT, 0, group, 0);
+            sendIgmp(upstrIf->InAdr.s_addr, group, IGMP_V2_MEMBERSHIP_REPORT, 0, group, 0);
+        }
     }
 
     IF_DEBUG logRouteTable("Insert Route");
@@ -351,7 +369,7 @@
 *   activated, it's reinstalled in the kernel. If
 *   the route is activated, no originAddr is needed.
 */
-int activateRoute(uint32 group, uint32 originAddr) {
+int activateRoute(uint32 group, uint32 originAddr, int downIf) {
     struct RouteTable*  croute;
     int result = 0;
 
@@ -369,21 +387,42 @@
     }
 
     if(croute != NULL) {
+       struct Origin *o = NULL;
+       int found = 0;
+
         // If the origin address is set, update the route data.
         if(originAddr > 0) {
-            if(croute->originAddr > 0 && croute->originAddr!=originAddr) {
-                log(LOG_WARNING, 0, "The origin for route %s changed from %s to %s",
+
+           TAILQ_FOREACH(o, &croute->originList, next) {
+               log(LOG_INFO, 0, "Origin for route %s have %s, new %s",
                     inetFmt(croute->group, s1),
-                    inetFmt(croute->originAddr, s2),
+                   inetFmt(o->originAddr, s2),
                     inetFmt(originAddr, s3));
+               if (o->originAddr==originAddr) {
+                   found++;
+                   break;
             }
-            croute->originAddr = originAddr;
-        }
-
-        // Only update kernel table if there are listeners !
-        if(croute->vifBits > 0) {
-            result = internUpdateKernelRoute(croute, 1);
         }
+           if (!found) {
+               log(LOG_NOTICE, 0, "New origin for route %s is %s, flood %d",
+                   inetFmt(croute->group, s1),
+                   inetFmt(originAddr, s3), downIf);
+               o = malloc(sizeof(*o));
+               o->originAddr = originAddr;
+               o->flood = downIf;
+               o->pktcnt = 0;
+               TAILQ_INSERT_TAIL(&croute->originList, o, next);
+           } else {
+               log(LOG_INFO, 0, "Have origin for route %s at %s, pktcnt %d",
+                   inetFmt(croute->group, s1),
+                   inetFmt(o->originAddr, s3),
+                   o->pktcnt);
+           }
+        }
+
+        // Only update kernel table if there are listeners, but flood upstream!
+        if(croute->vifBits > 0 || downIf >= 0)
+            result = internUpdateKernelRoute(croute, 1, o);
     }
     IF_DEBUG logRouteTable("Activate Route");
 
@@ -443,7 +482,6 @@
 *   route is not found, or not in this state, 0 is returned.
 */
 int lastMemberGroupAge(uint32 group) {
-    struct Config       *conf = getCommonConfig();
     struct RouteTable   *croute;
 
     croute = findRoute(group);
@@ -463,6 +501,7 @@
 */
 int removeRoute(struct RouteTable*  croute) {
     struct Config       *conf = getCommonConfig();
+    struct Origin *o;
     int result = 1;
     
     // If croute is null, no routes was found.
@@ -477,7 +516,7 @@
     //BIT_ZERO(croute->vifBits);
 
     // Uninstall current route from kernel
-    if(!internUpdateKernelRoute(croute, 0)) {
+    if(!internUpdateKernelRoute(croute, 0, NULL)) {
         log(LOG_WARNING, 0, "The removal from Kernel failed.");
         result = 0;
     }
@@ -503,7 +542,12 @@
             croute->nextroute->prevroute = croute->prevroute;
         }
     }
+
     // Free the memory, and set the route to NULL...
+    while ((o = TAILQ_FIRST(&croute->originList))) {
+       TAILQ_REMOVE(&croute->originList, o, next);
+       free(o);
+    }
     free(croute);
     croute = NULL;
 
@@ -551,6 +595,36 @@
         }
     }
 
+    {
+       struct Origin *o, *nxt;
+       struct sioc_sg_req sg_req;
+
+       sg_req.grp.s_addr = croute->group;
+       for (o = TAILQ_FIRST(&croute->originList); o; o = nxt) {
+           nxt = TAILQ_NEXT(o, next);
+           sg_req.src.s_addr = o->originAddr;
+           if (ioctl(MRouterFD, SIOCGETSGCNT, (char *)&sg_req) < 0) {
+               log(LOG_WARNING, errno, "%s (%s %s)",
+                   "age_table_entry: SIOCGETSGCNT failing for",
+                   inetFmt(o->originAddr, s1),
+                   inetFmt(croute->group, s2));
+               /* Make sure it gets deleted below */
+               sg_req.pktcnt = o->pktcnt;
+           }
+           log(LOG_DEBUG, 0, "Aging Origin %s Dst %s PktCnt %d -> %d",
+               inetFmt(o->originAddr, s1), inetFmt(croute->group, s2),
+               o->pktcnt, sg_req.pktcnt);
+           if (sg_req.pktcnt == o->pktcnt) {
+               /* no traffic, remove from kernel cache */
+               internUpdateKernelRoute(croute, 0, o);
+               TAILQ_REMOVE(&croute->originList, o, next);
+               free(o);
+           } else {
+               o->pktcnt = sg_req.pktcnt;
+           }
+       }
+    }
+
     // If the aging counter has reached zero, its time for updating...
     if(croute->ageValue == 0) {
         // Check for activity in the aging process,
@@ -560,7 +634,7 @@
                          inetFmt(croute->group,s1));
             
             // Just update the routing settings in kernel...
-            internUpdateKernelRoute(croute, 1);
+            internUpdateKernelRoute(croute, 1, NULL);
     
             // We append the activity counter to the age, and continue...
             croute->ageValue = croute->ageActivity;
@@ -586,28 +660,50 @@
 /**
 *   Updates the Kernel routing table. If activate is 1, the route
 *   is (re-)activated. If activate is false, the route is removed.
+*   if 'origin' is given, only the route with 'origin' will be
+*   updated, otherwise all MFC routes for the group will updated.
 */
-int internUpdateKernelRoute(struct RouteTable *route, int activate) {
+int internUpdateKernelRoute(struct RouteTable *route, int activate, struct Origin *origin) {
     struct   MRouteDesc     mrDesc;
     struct   IfDesc         *Dp;
     unsigned                Ix;
+    struct Origin *o;
     
-    if(route->originAddr>0) {
+    if (TAILQ_EMPTY(&route->originList)) {
+        log(LOG_NOTICE, 0, "Route is not active. No kernel updates done.");
+        return 1;
+    }
+    TAILQ_FOREACH(o, &route->originList, next) {
+       if (origin && origin != o)
+       continue;
 
         // Build route descriptor from table entry...
         // Set the source address and group address...
         mrDesc.McAdr.s_addr     = route->group;
-        mrDesc.OriginAdr.s_addr = route->originAddr;
+        mrDesc.OriginAdr.s_addr = o->originAddr;
     
         // clear output interfaces 
         memset( mrDesc.TtlVc, 0, sizeof( mrDesc.TtlVc ) );
     
-        IF_DEBUG log(LOG_DEBUG, 0, "Vif bits : 0x%08x", route->vifBits);
-
+        IF_DEBUG log(LOG_DEBUG, 0, "Origin %s Vif bits : 0x%08x", inetFmt(o->originAddr, s1), route->vifBits);
         // Set the TTL's for the route descriptor...
-        for ( Ix = 0; Dp = getIfByIx( Ix ); Ix++ ) {
+        for ( Ix = 0; (Dp = getIfByIx( Ix )); Ix++ ) {
+           if (o->flood >= 0) {
+               if(Ix == (unsigned) o->flood) {
+                   IF_DEBUG log(LOG_DEBUG, 0, "Identified Input VIF #%d as DOWNSTREAM.", Dp->index);
+                   mrDesc.InVif = Dp->index;
+               }
+               else if(Dp->state == IF_STATE_UPSTREAM) {
+                   IF_DEBUG log(LOG_DEBUG, 0, "Setting TTL for UPSTREAM Vif %d to %d", Dp->index, Dp->threshold);
+                   mrDesc.TtlVc[ Dp->index ] = Dp->threshold;
+               }
+               else if(BIT_TST(route->vifBits, Dp->index)) {
+                   IF_DEBUG log(LOG_DEBUG, 0, "Setting TTL for DOWNSTREAM Vif %d to %d", Dp->index, Dp->threshold);
+                   mrDesc.TtlVc[ Dp->index ] = Dp->threshold;
+               }
+           } else {
             if(Dp->state == IF_STATE_UPSTREAM) {
-                //IF_DEBUG log(LOG_DEBUG, 0, "Identified VIF #%d as upstream.", Dp->index);
+                   IF_DEBUG log(LOG_DEBUG, 0, "Identified VIF #%d as upstream.", Dp->index);
                 mrDesc.InVif = Dp->index;
             }
             else if(BIT_TST(route->vifBits, Dp->index)) {
@@ -615,6 +711,7 @@
                 mrDesc.TtlVc[ Dp->index ] = Dp->threshold;
             }
         }
+        }
     
         // Do the actual Kernel route update...
         if(activate) {
@@ -625,9 +722,6 @@
             // Delete the route from Kernel...
             delMRoute( &mrDesc );
         }
-
-    } else {
-        log(LOG_NOTICE, 0, "Route is not active. No kernel updates done.");
     }
 
     return 1;
@@ -647,16 +741,17 @@
             log(LOG_DEBUG, 0, "No routes in table...");
         } else {
             do {
-                /*
-                log(LOG_DEBUG, 0, "#%d: Src: %s, Dst: %s, Age:%d, St: %s, Prev: 0x%08x, T: 0x%08x, Next: 0x%08x",
-                    rcount, inetFmt(croute->originAddr, s1), inetFmt(croute->group, s2),
-                    croute->ageValue,(croute->originAddr>0?"A":"I"),
-                    croute->prevroute, croute, croute->nextroute);
-                */
-                log(LOG_DEBUG, 0, "#%d: Src: %s, Dst: %s, Age:%d, St: %s, OutVifs: 0x%08x",
-                    rcount, inetFmt(croute->originAddr, s1), inetFmt(croute->group, s2),
-                    croute->ageValue,(croute->originAddr>0?"A":"I"),
+               log(LOG_DEBUG, 0, "#%d: Dst: %s, Age:%d, St: %s, OutVifs: 0x%08x",
+                   rcount, inetFmt(croute->group, s2),
+                   croute->ageValue,(TAILQ_EMPTY(&croute->originList)?"I":"A"),
                     croute->vifBits);
+               {
+                   struct Origin *o;
+                   TAILQ_FOREACH(o, &croute->originList, next) {
+                       log(LOG_DEBUG, 0, "#%d: Origin: %s floodIf %d pktcnt %d",
+                           rcount, inetFmt(o->originAddr, s1), o->flood, o->pktcnt);
+                   }
+               }
                   
                 croute = croute->nextroute; 
         
Only in .: rttable.c.orig
diff -ur ../src_old/syslog.c ./syslog.c
--- ../src_old/syslog.c	2009-12-14 11:10:51.000000000 +0000
+++ ./syslog.c	2009-12-14 11:10:54.000000000 +0000
@@ -53,12 +53,16 @@
 ** is logged to 'stderr'.
 **          
 */
+#ifdef DEVEL_LOGGING
+void _log( int Serverity, int Errno, const char *func, int line, const char *FmtSt, ... )
+#else
 void log( int Serverity, int Errno, const char *FmtSt, ... )
+#endif
 {
   const char ServVc[][ 5 ] = { "EMER", "ALER", "CRIT", "ERRO", 
 			       "Warn", "Note", "Info", "Debu" };
 
-  const char *ServPt = Serverity < 0 || Serverity >= VCMC( ServVc ) ? 
+  const char *ServPt = Serverity < 0 || Serverity >= (int) VCMC( ServVc ) ? 
                        "!unknown serverity!" : ServVc[ Serverity ];
  
   const char *ErrSt = (Errno <= 0) ? NULL : (const char *)strerror( Errno ); 
@@ -69,6 +73,9 @@
 
     va_start( ArgPt, FmtSt );
     Ln  = snprintf( LogLastMsg, sizeof( LogLastMsg ), "%s: ", ServPt );
+#ifdef DEVEL_LOGGING
+    Ln += snprintf( LogLastMsg + Ln, sizeof( LogLastMsg ) - Ln, "%s():%d: ", func, line);
+#endif    
     Ln += vsnprintf( LogLastMsg + Ln, sizeof( LogLastMsg ) - Ln, FmtSt, ArgPt );
     if( ErrSt )
       snprintf( LogLastMsg + Ln, sizeof( LogLastMsg ) - Ln, "; Errno(%d): %s", Errno, ErrSt );
Only in .: syslog.c.orig
