<?php
/*
 * mcast_bridge.inc
 *
 * part of pfSense (https://www.pfsense.org)
 * Copyright (c) 2025 Denny Page
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require_once("config.inc");
require_once("util.inc");
require_once("service-utils.inc");

// Misc constants
const MCAST_BRIDGE_SVC_NAME = 'mcast-bridge';
const MCAST_BRIDGE_CMD = '/usr/local/bin/mcast-bridge';
const MCAST_BRIDGE_RC_FILE = '/usr/local/etc/rc.d/mcast-bridge.sh';
const MCAST_BRIDGE_CONF_FILE = '/usr/local/etc/mcast-bridge.conf';
const MCAST_BRIDGE_PID_FILE = '/var/run/mcast-bridge.pid';

// Configuration tokens
const MCB_CONF_NAME_ENABLE = 'enable';
const MCB_CONF_NAME_CARP_VHID = 'carp_vhid';
const MCB_CONF_NAME_IGMP_QUERIER = 'igmp_querier';
const MCB_CONF_NAME_MLD_QUERIER = 'mld_querier';
const MCB_CONF_NAME_SERVICE = 'service';
const MCB_CONF_NAME_SERVICE_DISABLED = 'disabled';
const MCB_CONF_NAME_SERVICE_PORT = 'port';
const MCB_CONF_NAME_SERVICE_IPV4 = 'ipv4';
const MCB_CONF_NAME_SERVICE_IPV6 = 'ipv6';
const MCB_CONF_NAME_SERVICE_INBOUND = 'inbound';
const MCB_CONF_NAME_SERVICE_OUTBOUND = 'outbound';
const MCB_CONF_NAME_SERVICE_STATIC_INBOUND = 'static_inbound';
const MCB_CONF_NAME_SERVICE_STATIC_OUTBOUND = 'static_outbound';
const MCB_CONF_NAME_SERVICE_DESC = 'desc';

// Configuration paths
const MCB_CONF_PATH = 'installedpackages/mcast-bridge';
const MCB_CONF_PATH_ENABLE = MCB_CONF_PATH . '/' . MCB_CONF_NAME_ENABLE;
const MCB_CONF_PATH_CARP_VHID = MCB_CONF_PATH . '/' . MCB_CONF_NAME_CARP_VHID;
const MCB_CONF_PATH_IGMP_QUERIER = MCB_CONF_PATH . '/' . MCB_CONF_NAME_IGMP_QUERIER;
const MCB_CONF_PATH_MLD_QUERIER = MCB_CONF_PATH . '/' . MCB_CONF_NAME_MLD_QUERIER;
const MCB_CONF_PATH_SERVICE = MCB_CONF_PATH . '/' . MCB_CONF_NAME_SERVICE;


// Is Multicast Bridge enabled?
function mcast_bridge_enabled() {
	if (config_get_path(MCB_CONF_PATH_ENABLE, false)) {
		foreach (config_get_path(MCB_CONF_PATH_SERVICE, []) as $service) {
			if (!isset($service[MCB_CONF_NAME_SERVICE_DISABLED])) {
				return true;
			}
		}
	}
	return (false);
}

// Get the CARP VHID in use by Multicast Bridge
function mcast_bridge_get_carp_vhid() {
	$carp_vhid = config_get_path(MCB_CONF_PATH_CARP_VHID, 'none');
	if ($carp_vhid != 'none') {
		return $carp_vhid;
	}
	return null;
}

// Get a CARP VHID list for use in mcast_bridge.php
function mcast_bridge_get_carp_list() {
	$list = array('none' => 'none');
	foreach (get_configured_vip_list('all', VIP_CARP) as $vid => $vaddr) {
		$vip = get_configured_vip($vid);
		$list[$vid] = sprintf("VHID %s on %s (%s)", $vip['vhid'], convert_friendly_interface_to_friendly_descr($vip['interface']), $vaddr);
	}
	return ($list);
}

// Convert a string list of friendly interfaces to real interfaces
function mcast_bridge_friendly_to_real($friendly_list) {
	$interfaces = array();
	foreach (array_filter(explode(',', $friendly_list)) as $interface) {
		$interface_name = get_real_interface($interface);
		if (!isset($interface_name)) {
			continue;
		}
		$interfaces[$interface] = $interface_name;
	}
	$real_list = implode(', ', $interfaces);
	return ($real_list);
}

// Write the config and rc files
function mcast_bridge_write_files() {
	// Get the current configuration
	$current_config = config_get_path(MCB_CONF_PATH, []);

	// Initialize the config file
	$file_array = array();
	$file_array[] = '# This file is generated by the pfSense Multicast Bridge package.';
	$file_array[] = '# Do not edit this file, it will be overwritten automatically.';
	$file_array[] = '';

	// Add the port sections
	foreach (array_get_path($current_config, MCB_CONF_NAME_SERVICE, []) as $id => $service) {
		if (isset($service[MCB_CONF_NAME_SERVICE_DISABLED])) {
			continue;
		}

		$file_array[] = '[' . $service[MCB_CONF_NAME_SERVICE_PORT] . ']';
		if ($service[MCB_CONF_NAME_SERVICE_IPV4]) {
			$file_array[] = 'ipv4-address = ' . $service[MCB_CONF_NAME_SERVICE_IPV4];
		}
		if ($service[MCB_CONF_NAME_SERVICE_IPV6]) {
			$file_array[] = 'ipv6-address = ' . $service[MCB_CONF_NAME_SERVICE_IPV6];
		}
		$iflist = mcast_bridge_friendly_to_real($service[MCB_CONF_NAME_SERVICE_INBOUND]);
		if ($iflist) {
			$file_array[] = 'inbound-interfaces = ' . $iflist;
		}
		$iflist = mcast_bridge_friendly_to_real($service[MCB_CONF_NAME_SERVICE_OUTBOUND]);
		if ($iflist) {
			$file_array[] = 'outbound-interfaces = ' . $iflist;
		}
		$iflist = mcast_bridge_friendly_to_real($service[MCB_CONF_NAME_SERVICE_STATIC_INBOUND]);
		if ($iflist) {
			$file_array[] = 'static-inbound-interfaces = ' . $iflist;
		}
		$iflist = mcast_bridge_friendly_to_real($service[MCB_CONF_NAME_SERVICE_STATIC_OUTBOUND]);
		if ($iflist) {
			$file_array[] = 'static-outbound-interfaces = ' . $iflist;
		}
		$file_array[] = '';
	}
	$file_array[] = '';

	// Write the config file
	if (!file_put_contents(MCAST_BRIDGE_CONF_FILE, implode("\n", $file_array))) {
		log_error('ERROR: Could not write file ' . MCAST_BRIDGE_CONF_FILE);
	}

	// Write the rc file
	$start = MCAST_BRIDGE_CMD;
	if ($current_config[MCB_CONF_NAME_IGMP_QUERIER] != 'quick') {
		$start .= ' -I ' . $current_config[MCB_CONF_NAME_IGMP_QUERIER];
	}
	if ($current_config[MCB_CONF_NAME_MLD_QUERIER] != 'quick') {
		$start .= ' -M ' . $current_config[MCB_CONF_NAME_MLD_QUERIER];
	}
	$start .= ' -s -c ' . MCAST_BRIDGE_CONF_FILE . ' -p ' . MCAST_BRIDGE_PID_FILE;
	$stop = '/usr/bin/killall ' . MCAST_BRIDGE_SVC_NAME;
	write_rcfile(array(
		"file" => "mcast-bridge.sh",
		"start" => $start,
		"stop" => $stop
		)
	);
}

function mcast_bridge_sync_config() {
	// Stop the service if it is currently running
	if (is_service_running(MCAST_BRIDGE_SVC_NAME)) {
		log_error("Stopping service Multicast Bridge");
		stop_service(MCAST_BRIDGE_SVC_NAME);
	}

	// If the service is now disabled, remove the config and rc files and return
	if (!mcast_bridge_enabled()) {
		unlink_if_exists(MCAST_BRIDGE_RC_FILE);
		unlink_if_exists(MCAST_BRIDGE_CONF_FILE);
		return;
	}

	// Write the config and rc files
	mcast_bridge_write_files();

	// Take no further action during platform boot
	if (is_platform_booting()) {
		return;
	}

	// Check the CARP VHID if in use
	$carp_vhid = mcast_bridge_get_carp_vhid();
	if ($carp_vhid) {
		$status = get_carp_interface_status($carp_vhid);
		switch ($status) {
			case 'MASTER':
				break;

			case 'BACKUP':
			case 'INIT':
				// If the VHID is still initializing, or in backup, don't start the service.
				log_error("Multicast Bridge service not started due to CARP status ({$status})");
				return;
				break;

			default:
				log_error("Multicast Bridge could not determine CARP status for VHID {$carp_vhid}: status = '{$status}'");
		}

	}

	// Start the service
	log_error("Starting service Multicast Bridge");
	start_service(MCAST_BRIDGE_SVC_NAME);
}

// Handle CARP notifications
function mcast_bridge_plugin_carp($pluginparams) {
	// If Multicast Bridge is not enabled, or a CARP VHID is not in use, return
	if (!mcast_bridge_enabled()) {
		return null;
	}
	$carp_vhid = mcast_bridge_get_carp_vhid();
	if (!$carp_vhid) {
		return null;
	}

	// Get my VIP
	$vip = get_configured_vip($carp_vhid);
	if (!$vip) {
		log_error("Multicast Bridge cannot find configured VHID ({$carp_vhid}). Check configuration.");
		return null;
	}

	// Is the notice for my VIP?
	$my_id = $vip['vhid'] . '@' . get_real_interface($vip['interface']);
	if (trim($pluginparams['interface']) != $my_id) {
		return null;
	}

	// Start or stop the service as appropriate
	if ($pluginparams['event'] == "rc.carpmaster") {
		log_error('Starting service Multicast Bridge on CARP VHID status change');
		start_service(MCAST_BRIDGE_SVC_NAME);
	} elseif ($pluginparams['event'] == "rc.carpbackup") {
		if (is_service_running(MCAST_BRIDGE_SVC_NAME)) {
			log_error('Stopping service Multicast Bridge on CARP VHID status change');
			stop_service(MCAST_BRIDGE_SVC_NAME);
		}
	}
}

// Clean up on deinstall
function mcast_bridge_deinstall_command() {
	if (is_service_running(MCAST_BRIDGE_SVC_NAME)) {
		log_error("Stopping service Multicast Bridge");
		stop_service(MCAST_BRIDGE_SVC_NAME);
	}

	unlink_if_exists(MCAST_BRIDGE_RC_FILE);
	unlink_if_exists(MCAST_BRIDGE_CONF_FILE);
}
