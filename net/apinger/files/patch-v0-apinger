diff -ur src_old/apinger.c src/apinger.c
--- src_old/apinger.c	2010-08-10 20:41:31.000000000 +0000
+++ src/apinger.c	2010-08-10 20:42:25.000000000 +0000
@@ -271,23 +271,15 @@
 time_t tm;
 	
 	tm=time(NULL);
-	fprintf(f,"%s",ctime(&tm));
-	if (on)
-		fprintf(f,"ALARM went off: %s\n",a->name);
-	else
-		fprintf(f,"alarm canceled: %s\n",a->name);
-	fprintf(f,"Target: %s\n",t->name);
-	fprintf(f,"Description: %s\n",t->description);
-	fprintf(f,"Probes sent: %i\n",t->last_sent+1);
-	fprintf(f,"Replies received: %i\n",t->received);
-	fprintf(f,"Last reply received: #%i %s",t->last_received,
-			ctime(&t->last_received_tv.tv_sec));
+	fprintf(f,"%s|%s|%i|%i|%u|",t->name, t->description, t->last_sent+1,
+		t->received, t->last_received_tv.tv_sec);
 	if (AVG_DELAY_KNOWN(t)){
-		fprintf(f,"Recent avg. delay: %4.3fms\n",AVG_DELAY(t));
+		fprintf(f,"%4.3fms|",AVG_DELAY(t));
 	}
 	if (AVG_LOSS_KNOWN(t)){
-		fprintf(f,"Recent avg. packet loss: %5.1f%%\n",AVG_LOSS(t));
+		fprintf(f,"%5.1f%%",AVG_LOSS(t));
 	}
+	fprintf(f, "\n");
 }
 
 void make_reports(struct target *t,struct alarm_cfg *a,int on,char* thisid,char* lastid){
@@ -646,7 +638,7 @@
 struct target *t,*pt,*nt;
 struct target_cfg *tc;
 struct active_alarm_list *al,*nal;
-union addr addr;
+union addr addr, srcaddr;
 int r;
 int l;
 
@@ -666,6 +658,8 @@
 				nal=al->next;
 				free(al);
 			}
+			if (t->socket)
+				close(t->socket);
 			free(t->queue);
 			free(t->rbuf);
 			free(t->name);
@@ -684,11 +678,6 @@
 			memset(&addr,0,sizeof(addr));
 			r=inet_pton(AF_INET,tc->name,&addr.addr4.sin_addr);
 			if (r){
-				if (icmp_sock<0){
-					logit("Sorry, IPv4 is not available\n");
-					logit("Ignoring target %s\n",tc->name);
-					continue;
-				}
 				addr.addr.sa_family=AF_INET;
 			}else{
 #ifdef HAVE_IPV6
@@ -708,12 +697,23 @@
 				addr.addr.sa_family=AF_INET6;
 #endif
 			}
+			memset(&srcaddr,0,sizeof(srcaddr));
+			debug("Converting srcip %s", tc->srcip);
+			r=inet_pton(AF_INET,tc->srcip,&srcaddr.addr4.sin_addr);
+			if (r){
+				srcaddr.addr.sa_family=AF_INET;
+			} else {
+				logit("Bad srcip address %s for target %s\n", tc->srcip, tc->name);
+				continue; 
+			}
 			t=NEW(struct target,1);
 			memset(t,0,sizeof(struct target));
 			t->name=strdup(tc->name);
 			t->description=strdup(tc->description);
 			t->addr=addr;
+			t->ifaddr=srcaddr;
 			t->next=targets;
+			make_icmp_socket(t);
 			targets=t;
 		}
 		t->config=tc;
@@ -733,6 +733,7 @@
 		assert(t->rbuf!=NULL);
 		memset(t->rbuf,0,l);
 	}
+
 	if (targets==NULL){
 		logit("No usable targets found, exiting");
 		exit(1);
@@ -753,6 +754,8 @@
 			nal=al->next;
 			free(al);
 		}
+		if (t->socket)
+			close(t->socket);
 		free(t->queue);
 		free(t->rbuf);
 		free(t->name);
@@ -798,25 +801,21 @@
 		return;
 	}
 	tm=time(NULL);
-	fprintf(f,"%s\n",ctime(&tm));
 	for(t=targets;t;t=t->next){
-		fprintf(f,"Target: %s\n",t->name);
-		fprintf(f,"Description: %s\n",t->description);
-		fprintf(f,"Last reply received: #%i %s",t->last_received,
-			ctime(&t->last_received_tv.tv_sec));
-		fprintf(f,"Average delay: %0.3fms\n",AVG_DELAY(t));
+		fprintf(f,"%s|%s|%s|%i|%i|%u|",t->name, t->config->srcip, t->description, t->last_sent+1,
+                	t->received, t->last_received_tv.tv_sec);
+		fprintf(f,"%0.3fms|", AVG_DELAY(t));
 		if (AVG_LOSS_KNOWN(t)){
-			fprintf(f,"Average packet loss: %0.1f%%\n",AVG_LOSS(t));
+			fprintf(f,"%0.1f%%",AVG_LOSS(t));
 		}
-		fprintf(f,"Active alarms:");
+		fprintf(f, "|");
 		if (t->active_alarms){
 			for(al=t->active_alarms;al;al=al->next){
 				a=al->alarm;
-				fprintf(f," \"%s\"",a->name);
+				fprintf(f,"%s",a->name);
 			}
-			fprintf(f,"\n");
 		}
-		else fprintf(f," None\n");
+		else fprintf(f,"none");
 
 		buf1=NEW(char,t->config->avg_loss_delay_samples+1);
 		buf2=NEW(char,t->config->avg_loss_samples+1);
@@ -850,11 +849,9 @@
 			}
 		}
 		buf2[i]=0;
-		fprintf(f,"Received packets buffer: %s %s\n",buf2,buf1);
 		if (t->recently_lost!=really_lost){
-			fprintf(f,"   lost packet count mismatch (%i!=%i)!\n",t->recently_lost,really_lost);
-			logit("%s: Lost packet count mismatch (%i!=%i)!",t->name,t->recently_lost,really_lost);
-			logit("%s: Received packets buffer: %s %s\n",t->name,buf2,buf1);
+			logit("Target \"%s\": Lost packet count mismatch (%i(recently_lost) != %i(really_lost))!",t->name,t->recently_lost,really_lost);
+			logit("Target \"%s\": Received packets buffer: %s %s\n",t->name,buf2,buf1);
 			err=1;
 		}
 		free(buf1);
@@ -866,55 +863,10 @@
 	if (err) abort();
 }
 
-#ifdef FORKED_RECEIVER
-int receiver_pipe=0;
-
-void pipe_reply(struct timeval time_recv,int icmp_seq,struct trace_info *ti){
-struct piped_info pi;
-
-	pi.recv_timestamp=time_recv;
-	pi.icmp_seq=icmp_seq;
-	pi.ti=*ti;
-	write(receiver_pipe,&pi,sizeof(pi));
-}
-
-void receiver_loop(void){
-struct pollfd pfd[2];
-int npfd=0;
-int i;
-
-	signal(SIGTERM,SIG_DFL);
-	signal(SIGINT,SIG_DFL);
-	signal(SIGHUP,SIG_DFL);
-	signal(SIGUSR1,SIG_DFL);
-	signal(SIGPIPE,SIG_DFL);
-	
-	if (icmp_sock){
-		pfd[npfd].events=POLLIN|POLLERR|POLLHUP|POLLNVAL;
-		pfd[npfd].revents=0;
-		pfd[npfd++].fd=icmp_sock;
-	}
-	if (icmp6_sock){
-		pfd[npfd].events=POLLIN|POLLERR|POLLHUP|POLLNVAL;
-		pfd[npfd++].fd=icmp6_sock;
-		pfd[npfd].revents=0;
-	}
-	while(1){
-		poll(pfd,npfd,-1);
-		for(i=0;i<npfd;i++){
-			if (!pfd[i].revents&POLLIN) continue;
-			if (pfd[i].fd==icmp_sock) recv_icmp();
-			else if (pfd[i].fd==icmp6_sock) recv_icmp6();
-			pfd[i].revents=0;
-		}
-	};
-}
-#endif
-
 void main_loop(void){
 struct target *t;
 struct timeval cur_time,next_status={0,0},tv,next_report={0,0},next_rrd_update={0,0};
-struct pollfd pfd[2];
+struct pollfd pfd[1024];
 int timeout;
 int npfd=0;
 int i;
@@ -923,46 +875,10 @@
 struct alarm_list *al,*nal;
 struct active_alarm_list *aal;
 struct alarm_cfg *a;
-#ifdef FORKED_RECEIVER
-int recv_pipe[2];
-int pid,r;
-struct piped_info pi;
-#endif
 
 	configure_targets();
-#ifdef FORKED_RECEIVER
-	r=pipe(recv_pipe);
-	if (r){
-		myperror("pipe");
-		exit(1);
-	}
-	pid=fork();
-	if (pid==-1){
-		myperror("pipe");
-		exit(1);
-	}
-	else if (pid==0){
-		close(recv_pipe[0]);
-		receiver_pipe=recv_pipe[1];
-		receiver_loop();
-		exit(0);
-	}
-	close(recv_pipe[1]);
-	pfd[npfd].events=POLLIN|POLLERR|POLLHUP|POLLNVAL;
-	pfd[npfd].revents=0;
-	pfd[npfd++].fd=recv_pipe[0];
-#else
-	if (icmp_sock){
-		pfd[npfd].events=POLLIN|POLLERR|POLLHUP|POLLNVAL;
-		pfd[npfd].revents=0;
-		pfd[npfd++].fd=icmp_sock;
-	}
-	if (icmp6_sock){
-		pfd[npfd].events=POLLIN|POLLERR|POLLHUP|POLLNVAL;
-		pfd[npfd++].fd=icmp6_sock;
-		pfd[npfd].revents=0;
-	}
-#endif
+	memset(&pfd, '\0', sizeof pfd);
+
 	if (config->status_interval){
 		gettimeofday(&cur_time,NULL);
 		tv.tv_sec=config->status_interval/1000;
@@ -970,10 +886,16 @@
 		timeradd(&cur_time,&tv,&next_status);
 	}
 	while(!interrupted_by){
+		npfd = 0;
 		gettimeofday(&cur_time,NULL);
 		if ( !timercmp(&next_probe,&cur_time,>) )
 			timerclear(&next_probe);
 		for(t=targets;t;t=t->next){
+			if (t->socket){
+				pfd[npfd].events=POLLIN|POLLERR|POLLHUP|POLLNVAL;
+				pfd[npfd].revents=0;
+				pfd[npfd++].fd=t->socket;
+			}
 			for(al=t->config->alarms;al;al=nal){
 				a=al->alarm;
 				nal=al->next;
@@ -1049,16 +971,12 @@
 		poll(pfd,npfd,timeout);
 		for(i=0;i<npfd;i++){
 			if (!pfd[i].revents&POLLIN) continue;
-#ifdef FORKED_RECEIVER
-			if (pfd[i].fd==recv_pipe[0]){
-				r=read(recv_pipe[0],&pi,sizeof(pi));
-				if (r==sizeof(pi))
-					analyze_reply(pi.recv_timestamp,pi.icmp_seq,&pi.ti);
-			}
-#else
-			if (pfd[i].fd==icmp_sock) recv_icmp();
-			else if (pfd[i].fd==icmp6_sock) recv_icmp6();
-#endif
+			for(t=targets;t;t=t->next){
+				if (t->socket == pfd[i].fd) {
+					recv_icmp(t);
+					break;
+				}
+			}
 			pfd[i].revents=0;
 		}
 		if (status_request){
@@ -1074,9 +992,6 @@
 			reload_config();
 		}
 	}
-#ifdef FORKED_RECEIVER
-	kill(pid,SIGTERM);
-#endif
 	while(delayed_reports!=NULL) make_delayed_reports();
 	free_targets();
 	if (macros_buf!=NULL) free(macros_buf);
diff -ur src_old/apinger.h src/apinger.h
--- src_old/apinger.h	2010-08-10 20:41:31.000000000 +0000
+++ src/apinger.h	2010-08-10 20:41:37.000000000 +0000
@@ -47,6 +47,8 @@
 #endif
 #include "conf.h"
 
+#include <ifaddrs.h>
+
 union addr {
 	struct sockaddr addr;
 	struct sockaddr_in addr4;
@@ -67,10 +69,11 @@
 	char *description;	/* description */
 	
 	union addr addr;	/* target address */
-	
+
 	char *queue;		/*
 				contains info about recently sent packets
 				"1" means it was received */
+	int socket;
 	int last_sent;		/* sequence number of the last ping sent */
 	int last_received;	/* sequence number of the last ping received */
 	struct timeval last_received_tv; /* timestamp of the last ping received */
@@ -90,6 +93,7 @@
 	struct target_cfg *config;
 	
 	struct target *next;
+	union addr ifaddr;	/* iface address */
 };
 
 #define AVG_DELAY_KNOWN(t) (t->upsent >= t->config->avg_delay_samples)
@@ -123,8 +127,8 @@
 
 extern struct timeval next_probe;
 
-int make_icmp_socket(void);
-void recv_icmp(void);
+int make_icmp_socket(struct target *t);
+void recv_icmp(struct target *t);
 void send_icmp_probe(struct target *t,int seq);
 
 int make_icmp6_socket(void);
diff -ur src_old/cfgparser1.c src/cfgparser1.c
--- src_old/cfgparser1.c	2010-08-10 20:41:31.000000000 +0000
+++ src/cfgparser1.c	2010-08-10 20:41:37.000000000 +0000
@@ -1,56 +1,73 @@
-/* A Bison parser, made from /home/users/jacek/CVS/bnet/src/pinger/src/cfgparser1.y
-   by GNU bison 1.35.  */
 
-#define YYBISON 1  /* Identify Bison output.  */
+/* A Bison parser, made by GNU Bison 2.4.1.  */
 
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
 #define YYLSP_NEEDED 1
 
-# define	TIME	257
-# define	INTEGER	258
-# define	STRING	259
-# define	DEBUG	260
-# define	USER	261
-# define	GROUP	262
-# define	PID_FILE	263
-# define	MAILER	264
-# define	TIMESTAMP_FORMAT	265
-# define	RRD	266
-# define	STATUS	267
-# define	ALARM	268
-# define	TARGET	269
-# define	OVERRIDE	270
-# define	DEFAULT	271
-# define	MAILTO	272
-# define	MAILFROM	273
-# define	MAILENVFROM	274
-# define	MAILSUBJECT	275
-# define	COMMAND	276
-# define	PIPE	277
-# define	COMBINE	278
-# define	REPEAT	279
-# define	DOWN	280
-# define	LOSS	281
-# define	DELAY	282
-# define	TIME_	283
-# define	PERCENT_LOW	284
-# define	PERCENT_HIGH	285
-# define	DELAY_LOW	286
-# define	DELAY_HIGH	287
-# define	DESCRIPTION	288
-# define	ALARMS	289
-# define	INTERVAL	290
-# define	AVG_DELAY_SAMPLES	291
-# define	AVG_LOSS_SAMPLES	292
-# define	AVG_LOSS_DELAY_SAMPLES	293
-# define	FILE_	294
-# define	ERROR	295
-# define	ON	296
-# define	OFF	297
-# define	YES	298
-# define	NO	299
-# define	TRUE	300
-# define	FALSE	301
 
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
 #line 22 "cfgparser1.y"
 
 
@@ -77,407 +94,321 @@
 
 
 
+
+/* Line 189 of yacc.c  */
+#line 100 "cfgparser1.tab.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     TIME = 258,
+     INTEGER = 259,
+     STRING = 260,
+     DEBUG = 261,
+     USER = 262,
+     GROUP = 263,
+     PID_FILE = 264,
+     MAILER = 265,
+     TIMESTAMP_FORMAT = 266,
+     RRD = 267,
+     STATUS = 268,
+     ALARM = 269,
+     TARGET = 270,
+     OVERRIDE = 271,
+     DEFAULT = 272,
+     MAILTO = 273,
+     MAILFROM = 274,
+     MAILENVFROM = 275,
+     MAILSUBJECT = 276,
+     COMMAND = 277,
+     PIPE = 278,
+     COMBINE = 279,
+     REPEAT = 280,
+     DOWN = 281,
+     LOSS = 282,
+     DELAY = 283,
+     TIME_ = 284,
+     PERCENT_LOW = 285,
+     PERCENT_HIGH = 286,
+     DELAY_LOW = 287,
+     DELAY_HIGH = 288,
+     DESCRIPTION = 289,
+     SRCIP = 290,
+     ALARMS = 291,
+     INTERVAL = 292,
+     AVG_DELAY_SAMPLES = 293,
+     AVG_LOSS_SAMPLES = 294,
+     AVG_LOSS_DELAY_SAMPLES = 295,
+     FILE_ = 296,
+     ERROR = 297,
+     ON = 298,
+     OFF = 299,
+     YES = 300,
+     NO = 301,
+     TRUE = 302,
+     FALSE = 303
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
 #line 51 "cfgparser1.y"
-#ifndef YYSTYPE
-typedef union {
+
 	int i;
 	char *s;
 	struct alarm_cfg *a;
 	struct target_cfg *t;
 	struct config *c;
 	struct alarm_list *al;
-} yystype;
-# define YYSTYPE yystype
+
+
+
+/* Line 214 of yacc.c  */
+#line 195 "cfgparser1.tab.c"
+} YYSTYPE;
 # define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
 #endif
 
-#ifndef YYLTYPE
-typedef struct yyltype
+#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
+typedef struct YYLTYPE
 {
   int first_line;
   int first_column;
-
   int last_line;
   int last_column;
-} yyltype;
-
-# define YYLTYPE yyltype
+} YYLTYPE;
+# define yyltype YYLTYPE /* obsolescent; will be withdrawn */
+# define YYLTYPE_IS_DECLARED 1
 # define YYLTYPE_IS_TRIVIAL 1
 #endif
 
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
 
+/* Copy the second part of user declarations.  */
 
 
-#define	YYFINAL		146
-#define	YYFLAG		-32768
-#define	YYNTBASE	53
-
-/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
-#define YYTRANSLATE(x) ((unsigned)(x) <= 301 ? yytranslate[x] : 71)
-
-/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
-static const char yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-      51,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,    50,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,    52,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,    48,     2,    49,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     3,     4,     5,
-       6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
-      36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
-      46,    47
-};
-
-#if YYDEBUG
-static const short yyprhs[] =
-{
-       0,     0,     1,     4,     7,    10,    13,    16,    19,    24,
-      28,    30,    32,    36,    38,    39,    40,    41,    42,    49,
-      57,    65,    73,    75,    79,    81,    84,    87,    91,    93,
-      96,    99,   103,   105,   108,   112,   113,   116,   119,   122,
-     125,   128,   132,   136,   139,   143,   147,   150,   154,   157,
-     164,   171,   172,   175,   178,   182,   185,   188,   191,   194,
-     197,   201,   205,   207,   211,   212,   215,   218,   221,   225,
-     227,   229,   231,   233,   235,   237,   239,   241
-};
-static const short yyrhs[] =
-{
-      -1,     6,    69,     0,     7,    68,     0,     8,    68,     0,
-      10,    68,     0,    11,    68,     0,     9,    68,     0,    13,
-      48,    67,    49,     0,    12,    36,     3,     0,    58,     0,
-      64,     0,    53,    70,    53,     0,     1,     0,     0,     0,
-       0,     0,    14,    56,    17,    48,    59,    49,     0,    14,
-      54,    26,    68,    48,    62,    49,     0,    14,    54,    27,
-      68,    48,    60,    49,     0,    14,    54,    28,    68,    48,
-      61,    49,     0,    63,     0,    59,    70,    59,     0,    63,
-       0,    30,     4,     0,    31,     4,     0,    60,    70,    60,
-       0,    63,     0,    32,     3,     0,    33,     3,     0,    61,
-      70,    61,     0,    63,     0,    29,     3,     0,    62,    70,
-      62,     0,     0,    18,    68,     0,    19,    68,     0,    20,
-      68,     0,    21,    68,     0,    22,    68,     0,    22,    42,
-      68,     0,    22,    43,    68,     0,    23,    68,     0,    23,
-      42,    68,     0,    23,    43,    68,     0,    24,     3,     0,
-      25,     3,     4,     0,    25,     3,     0,    15,    57,    17,
-      48,    65,    49,     0,    15,    55,    68,    48,    65,    49,
-       0,     0,    34,    68,     0,    35,    66,     0,    35,    16,
-      66,     0,    36,     4,     0,    36,     3,     0,    37,     4,
-       0,    38,     4,     0,    39,     4,     0,    12,    40,     5,
-       0,    65,    70,    65,     0,    68,     0,    66,    50,    68,
-       0,     0,    40,    68,     0,    36,     4,     0,    36,     3,
-       0,    67,    70,    67,     0,     5,     0,    42,     0,    43,
-       0,    44,     0,    45,     0,    46,     0,    47,     0,    51,
-       0,    52,     0
-};
+/* Line 264 of yacc.c  */
+#line 220 "cfgparser1.tab.c"
 
+#ifdef short
+# undef short
 #endif
 
-#if YYDEBUG
-/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
-static const short yyrline[] =
-{
-       0,   122,   123,   124,   125,   126,   127,   128,   129,   130,
-     131,   132,   133,   134,   142,   145,   148,   154,   160,   161,
-     166,   171,   178,   179,   182,   183,   185,   187,   190,   191,
-     193,   195,   198,   199,   201,   204,   205,   207,   209,   211,
-     213,   218,   220,   222,   227,   229,   231,   233,   235,   240,
-     241,   248,   249,   251,   253,   255,   257,   259,   261,   263,
-     265,   267,   270,   272,   276,   277,   279,   281,   283,   287,
-     290,   291,   292,   293,   294,   295,   298,   299
-};
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
 #endif
 
-
-#if (YYDEBUG) || defined YYERROR_VERBOSE
-
-/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
-static const char *const yytname[] =
-{
-  "$", "error", "$undefined.", "TIME", "INTEGER", "STRING", "DEBUG", "USER", 
-  "GROUP", "PID_FILE", "MAILER", "TIMESTAMP_FORMAT", "RRD", "STATUS", 
-  "ALARM", "TARGET", "OVERRIDE", "DEFAULT", "MAILTO", "MAILFROM", 
-  "MAILENVFROM", "MAILSUBJECT", "COMMAND", "PIPE", "COMBINE", "REPEAT", 
-  "DOWN", "LOSS", "DELAY", "TIME_", "PERCENT_LOW", "PERCENT_HIGH", 
-  "DELAY_LOW", "DELAY_HIGH", "DESCRIPTION", "ALARMS", "INTERVAL", 
-  "AVG_DELAY_SAMPLES", "AVG_LOSS_SAMPLES", "AVG_LOSS_DELAY_SAMPLES", 
-  "FILE_", "ERROR", "ON", "OFF", "YES", "NO", "TRUE", "FALSE", "'{'", 
-  "'}'", "','", "'\\n'", "';'", "config", "makealarm", "maketarget", 
-  "getdefalarm", "getdeftarget", "alarm", "alarmcommoncfg", 
-  "alarmlosscfg", "alarmdelaycfg", "alarmdowncfg", "alarmcommon", 
-  "target", "targetcfg", "alarmlist", "statuscfg", "string", "boolean", 
-  "separator", 0
-};
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
 #endif
 
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
-static const short yyr1[] =
-{
-       0,    53,    53,    53,    53,    53,    53,    53,    53,    53,
-      53,    53,    53,    53,    54,    55,    56,    57,    58,    58,
-      58,    58,    59,    59,    60,    60,    60,    60,    61,    61,
-      61,    61,    62,    62,    62,    63,    63,    63,    63,    63,
-      63,    63,    63,    63,    63,    63,    63,    63,    63,    64,
-      64,    65,    65,    65,    65,    65,    65,    65,    65,    65,
-      65,    65,    66,    66,    67,    67,    67,    67,    67,    68,
-      69,    69,    69,    69,    69,    69,    70,    70
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
-static const short yyr2[] =
-{
-       0,     0,     2,     2,     2,     2,     2,     2,     4,     3,
-       1,     1,     3,     1,     0,     0,     0,     0,     6,     7,
-       7,     7,     1,     3,     1,     2,     2,     3,     1,     2,
-       2,     3,     1,     2,     3,     0,     2,     2,     2,     2,
-       2,     3,     3,     2,     3,     3,     2,     3,     2,     6,
-       6,     0,     2,     2,     3,     2,     2,     2,     2,     2,
-       3,     3,     1,     3,     0,     2,     2,     2,     3,     1,
-       1,     1,     1,     1,     1,     1,     1,     1
-};
-
-/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
-   doesn't specify something else to do.  Zero means the default is an
-   error. */
-static const short yydefact[] =
-{
-       0,    13,     0,     0,     0,     0,     0,     0,     0,     0,
-      14,    15,     0,    10,    11,    70,    71,    72,    73,    74,
-      75,     2,    69,     3,     4,     7,     5,     6,     0,    64,
-       0,     0,     0,     0,    76,    77,     0,     9,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,    12,    67,    66,
-      65,     8,    64,     0,     0,     0,    35,    51,    51,    68,
-      35,    35,    35,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,    22,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,    32,     0,     0,     0,    24,     0,
-       0,     0,    28,    36,    37,    38,    39,     0,     0,    40,
-       0,     0,    43,    46,    48,    18,    35,     0,    52,     0,
-      53,    62,    56,    55,    57,    58,    59,    50,    51,    49,
-      33,    19,    35,    25,    26,    20,    35,    29,    30,    21,
-      35,    41,    42,    44,    45,    47,    23,    60,    54,     0,
-      61,    34,    27,    31,    63,     0,     0
-};
-
-static const short yydefgoto[] =
-{
-      12,    30,    32,    31,    33,    13,    71,    87,    91,    83,
-      72,    14,    80,   110,    40,   111,    21,   118
-};
-
-static const short yypact[] =
-{
-      75,-32768,    87,    30,    30,    30,    30,    30,    -4,   -11,
-      24,    42,    27,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-  -32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    64,   -16,
-      18,    53,    30,    55,-32768,-32768,    75,-32768,    19,    30,
-     -18,    30,    30,    30,    26,    43,    45,     6,-32768,-32768,
-  -32768,-32768,   -16,    51,    62,    67,   119,    16,    16,     6,
-      99,    83,    -7,    30,    30,    30,    30,     0,     5,   113,
-     122,    60,-32768,    95,    30,    14,   166,   143,   150,   154,
-      97,   104,   159,   108,-32768,   162,   167,   112,-32768,   169,
-     170,   116,-32768,-32768,-32768,-32768,-32768,    30,    30,-32768,
-      30,    30,-32768,-32768,   171,-32768,   119,   172,-32768,    30,
-     124,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    16,-32768,
-  -32768,-32768,    99,-32768,-32768,-32768,    83,-32768,-32768,-32768,
-      -7,-32768,-32768,-32768,-32768,-32768,     6,-32768,   124,    30,
-       6,     6,     6,     6,-32768,   176,-32768
-};
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
 
-static const short yypgoto[] =
-{
-     142,-32768,-32768,-32768,-32768,-32768,    73,    54,    52,    59,
-     -53,-32768,   -52,    74,   132,    -3,-32768,     9
-};
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-#define	YYLAST		184
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
 
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
 
-static const short yytable[] =
-{
-      23,    24,    25,    26,    27,    22,    81,    84,    88,    92,
-      22,    63,    64,    65,    66,    67,    68,    69,    70,    22,
-      38,    36,    48,    49,    39,    89,    90,   145,    73,    45,
-     109,    51,    28,    34,    35,    22,    50,    29,    53,    54,
-      55,   -16,    97,    98,    41,    42,    43,   100,   101,    52,
-      74,    75,    76,    77,    78,    79,    36,    34,    35,   -17,
-      93,    94,    95,    96,    99,   102,   140,    37,    52,    84,
-      44,   108,    46,    88,    56,    -1,     1,    92,    34,    35,
-     106,     2,     3,     4,     5,     6,     7,     8,     9,    10,
-      11,    57,   122,    58,   131,   132,   126,   133,   134,    60,
-     130,    63,    64,    65,    66,    67,    68,    69,    70,   105,
-      61,    34,    35,    85,    86,    62,   103,    63,    64,    65,
-      66,    67,    68,    69,    70,   104,    -1,    -1,    82,    15,
-      16,    17,    18,    19,    20,   107,   144,    63,    64,    65,
-      66,    67,    68,    69,    70,   106,   117,   114,    34,    35,
-     122,   126,   130,   119,   115,    34,    35,   121,   116,    34,
-      35,   125,   120,    34,    35,   129,   123,    34,    35,   112,
-     113,   124,   127,   128,   139,   135,   146,   137,    47,   136,
-     142,   141,   143,   138,    59
-};
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
 
-static const short yycheck[] =
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
 {
-       3,     4,     5,     6,     7,     5,    58,    60,    61,    62,
-       5,    18,    19,    20,    21,    22,    23,    24,    25,     5,
-      36,    12,     3,     4,    40,    32,    33,     0,    12,    32,
-      16,    49,    36,    51,    52,     5,    39,    48,    41,    42,
-      43,    17,    42,    43,    26,    27,    28,    42,    43,    40,
-      34,    35,    36,    37,    38,    39,    47,    51,    52,    17,
-      63,    64,    65,    66,    67,    68,   118,     3,    59,   122,
-      17,    74,    17,   126,    48,     0,     1,   130,    51,    52,
-      71,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    48,    83,    48,    97,    98,    87,   100,   101,    48,
-      91,    18,    19,    20,    21,    22,    23,    24,    25,    49,
-      48,    51,    52,    30,    31,    48,     3,    18,    19,    20,
-      21,    22,    23,    24,    25,     3,    51,    52,    29,    42,
-      43,    44,    45,    46,    47,    40,   139,    18,    19,    20,
-      21,    22,    23,    24,    25,   136,    49,     4,    51,    52,
-     141,   142,   143,    49,     4,    51,    52,    49,     4,    51,
-      52,    49,     3,    51,    52,    49,     4,    51,    52,     3,
-       4,     4,     3,     3,    50,     4,     0,     5,    36,   106,
-     126,   122,   130,   109,    52
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/share/misc/bison.simple"
-
-/* Skeleton output parser for bison,
-
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
-   Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-/* This is the parser code that is written into each bison parser when
-   the %semantic_parser declaration is not specified in the grammar.
-   It was written by Richard Stallman by simplifying the hairy parser
-   used when %semantic_parser is specified.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
+  return yyi;
+}
+#endif
 
-#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
-# if YYSTACK_USE_ALLOCA
-#  define YYSTACK_ALLOC alloca
-# else
-#  ifndef YYSTACK_USE_ALLOCA
-#   if defined (alloca) || defined (_ALLOCA_H)
-#    define YYSTACK_ALLOC alloca
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
 #   else
-#    ifdef __GNUC__
-#     define YYSTACK_ALLOC __builtin_alloca
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
 #    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
 # else
-#  if defined (__STDC__) || defined (__cplusplus)
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
 #  endif
-#  define YYSTACK_ALLOC malloc
-#  define YYSTACK_FREE free
 # endif
-#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \
+	     && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
-  YYSTYPE yyvs;
-# if YYLSP_NEEDED
-  YYLTYPE yyls;
-# endif
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+  YYLTYPE yyls_alloc;
 };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
-# if YYLSP_NEEDED
-#  define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
-      + 2 * YYSTACK_GAP_MAX)
-# else
-#  define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
-      + YYSTACK_GAP_MAX)
-# endif
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
+      + 2 * YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -486,103 +417,414 @@
    elements in the stack, and YYPTR gives the new location of the
    stack.  Advance YYPTR to a properly aligned location for the next
    stack.  */
-# define YYSTACK_RELOCATE(Stack)					\
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
     do									\
       {									\
 	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack, Stack, yysize);				\
-	Stack = &yyptr->Stack;						\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  34
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   186
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  54
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  19
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  79
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  148
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   303
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      52,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,    51,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,    53,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    49,     2,    50,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     4,     7,    10,    13,    16,    19,    22,
+      27,    31,    33,    35,    39,    41,    42,    43,    44,    45,
+      52,    60,    68,    76,    78,    82,    84,    87,    90,    94,
+      96,    99,   102,   106,   108,   111,   115,   116,   119,   122,
+     125,   128,   131,   135,   139,   142,   146,   150,   153,   157,
+     160,   167,   174,   175,   178,   181,   184,   188,   191,   194,
+     197,   200,   203,   207,   211,   213,   217,   218,   221,   224,
+     227,   231,   233,   235,   237,   239,   241,   243,   245,   247
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      55,     0,    -1,    -1,     6,    71,    -1,     7,    70,    -1,
+       8,    70,    -1,    10,    70,    -1,    11,    70,    -1,     9,
+      70,    -1,    13,    49,    69,    50,    -1,    12,    37,     3,
+      -1,    60,    -1,    66,    -1,    55,    72,    55,    -1,     1,
+      -1,    -1,    -1,    -1,    -1,    14,    58,    17,    49,    61,
+      50,    -1,    14,    56,    26,    70,    49,    64,    50,    -1,
+      14,    56,    27,    70,    49,    62,    50,    -1,    14,    56,
+      28,    70,    49,    63,    50,    -1,    65,    -1,    61,    72,
+      61,    -1,    65,    -1,    30,     4,    -1,    31,     4,    -1,
+      62,    72,    62,    -1,    65,    -1,    32,     3,    -1,    33,
+       3,    -1,    63,    72,    63,    -1,    65,    -1,    29,     3,
+      -1,    64,    72,    64,    -1,    -1,    18,    70,    -1,    19,
+      70,    -1,    20,    70,    -1,    21,    70,    -1,    22,    70,
+      -1,    22,    43,    70,    -1,    22,    44,    70,    -1,    23,
+      70,    -1,    23,    43,    70,    -1,    23,    44,    70,    -1,
+      24,     3,    -1,    25,     3,     4,    -1,    25,     3,    -1,
+      15,    59,    17,    49,    67,    50,    -1,    15,    57,    70,
+      49,    67,    50,    -1,    -1,    34,    70,    -1,    35,    70,
+      -1,    36,    68,    -1,    36,    16,    68,    -1,    37,     4,
+      -1,    37,     3,    -1,    38,     4,    -1,    39,     4,    -1,
+      40,     4,    -1,    12,    41,     5,    -1,    67,    72,    67,
+      -1,    70,    -1,    68,    51,    70,    -1,    -1,    41,    70,
+      -1,    37,     4,    -1,    37,     3,    -1,    69,    72,    69,
+      -1,     5,    -1,    43,    -1,    44,    -1,    45,    -1,    46,
+      -1,    47,    -1,    48,    -1,    52,    -1,    53,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   123,   123,   124,   125,   126,   127,   128,   129,   130,
+     131,   132,   133,   134,   135,   143,   146,   149,   155,   161,
+     162,   167,   172,   179,   180,   183,   184,   186,   188,   191,
+     192,   194,   196,   199,   200,   202,   205,   206,   208,   210,
+     212,   214,   219,   221,   223,   228,   230,   232,   234,   236,
+     241,   242,   249,   250,   252,   254,   256,   258,   260,   262,
+     264,   266,   268,   270,   273,   275,   279,   280,   282,   284,
+     286,   290,   293,   294,   295,   296,   297,   298,   301,   302
+};
 #endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "TIME", "INTEGER", "STRING", "DEBUG",
+  "USER", "GROUP", "PID_FILE", "MAILER", "TIMESTAMP_FORMAT", "RRD",
+  "STATUS", "ALARM", "TARGET", "OVERRIDE", "DEFAULT", "MAILTO", "MAILFROM",
+  "MAILENVFROM", "MAILSUBJECT", "COMMAND", "PIPE", "COMBINE", "REPEAT",
+  "DOWN", "LOSS", "DELAY", "TIME_", "PERCENT_LOW", "PERCENT_HIGH",
+  "DELAY_LOW", "DELAY_HIGH", "DESCRIPTION", "SRCIP", "ALARMS", "INTERVAL",
+  "AVG_DELAY_SAMPLES", "AVG_LOSS_SAMPLES", "AVG_LOSS_DELAY_SAMPLES",
+  "FILE_", "ERROR", "ON", "OFF", "YES", "NO", "TRUE", "FALSE", "'{'",
+  "'}'", "','", "'\\n'", "';'", "$accept", "config", "makealarm",
+  "maketarget", "getdefalarm", "getdeftarget", "alarm", "alarmcommoncfg",
+  "alarmlosscfg", "alarmdelaycfg", "alarmdowncfg", "alarmcommon", "target",
+  "targetcfg", "alarmlist", "statuscfg", "string", "boolean", "separator", 0
+};
 #endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   123,
+     125,    44,    10,    59
+};
 # endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    54,    55,    55,    55,    55,    55,    55,    55,    55,
+      55,    55,    55,    55,    55,    56,    57,    58,    59,    60,
+      60,    60,    60,    61,    61,    62,    62,    62,    62,    63,
+      63,    63,    63,    64,    64,    64,    65,    65,    65,    65,
+      65,    65,    65,    65,    65,    65,    65,    65,    65,    65,
+      66,    66,    67,    67,    67,    67,    67,    67,    67,    67,
+      67,    67,    67,    67,    68,    68,    69,    69,    69,    69,
+      69,    70,    71,    71,    71,    71,    71,    71,    72,    72
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     0,     2,     2,     2,     2,     2,     2,     4,
+       3,     1,     1,     3,     1,     0,     0,     0,     0,     6,
+       7,     7,     7,     1,     3,     1,     2,     2,     3,     1,
+       2,     2,     3,     1,     2,     3,     0,     2,     2,     2,
+       2,     2,     3,     3,     2,     3,     3,     2,     3,     2,
+       6,     6,     0,     2,     2,     2,     3,     2,     2,     2,
+       2,     2,     3,     3,     1,     3,     0,     2,     2,     2,
+       3,     1,     1,     1,     1,     1,     1,     1,     1,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,    14,     0,     0,     0,     0,     0,     0,     0,     0,
+      15,    16,     0,    11,    12,    72,    73,    74,    75,    76,
+      77,     3,    71,     4,     5,     8,     6,     7,     0,    66,
+       0,     0,     0,     0,     1,    78,    79,     0,    10,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    13,    69,
+      68,    67,     9,    66,     0,     0,     0,    36,    52,    52,
+      70,    36,    36,    36,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    23,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    33,     0,     0,     0,
+      25,     0,     0,     0,    29,    37,    38,    39,    40,     0,
+       0,    41,     0,     0,    44,    47,    49,    19,    36,     0,
+      53,    54,     0,    55,    64,    58,    57,    59,    60,    61,
+      51,    52,    50,    34,    20,    36,    26,    27,    21,    36,
+      30,    31,    22,    36,    42,    43,    45,    46,    48,    24,
+      62,    56,     0,    63,    35,    28,    32,    65
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,    12,    30,    32,    31,    33,    13,    72,    89,    93,
+      85,    73,    14,    82,   113,    41,   114,    21,   121
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -56
+static const yytype_int16 yypact[] =
+{
+      76,   -56,   -29,     5,     5,     5,     5,     5,   -25,   -16,
+      19,    21,    27,   -56,   -56,   -56,   -56,   -56,   -56,   -56,
+     -56,   -56,   -56,   -56,   -56,   -56,   -56,   -56,    40,   -17,
+      32,    29,     5,    37,   -56,   -56,   -56,    76,   -56,   108,
+       5,   -27,     5,     5,     5,     0,    22,    26,    73,   -56,
+     -56,   -56,   -56,   -17,    44,    46,    52,    85,    80,    80,
+      73,   152,   138,   112,     5,     5,     5,     5,     4,     8,
+      65,   110,   -22,   -56,    81,     5,     5,     6,   139,   123,
+     142,   143,   -18,    -8,   146,     3,   -56,   147,   148,    71,
+     -56,   161,   162,    88,   -56,   -56,   -56,   -56,   -56,     5,
+       5,   -56,     5,     5,   -56,   -56,   163,   -56,    85,   145,
+     -56,   -56,     5,   115,   -56,   -56,   -56,   -56,   -56,   -56,
+     -56,    80,   -56,   -56,   -56,   152,   -56,   -56,   -56,   138,
+     -56,   -56,   -56,   112,   -56,   -56,   -56,   -56,   -56,    73,
+     -56,   115,     5,    73,    73,    73,    73,   -56
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -56,   141,   -56,   -56,   -56,   -56,   -56,    72,    50,    49,
+      58,   -55,   -56,   -54,    74,   131,    -3,   -56,     9
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -19
+static const yytype_int16 yytable[] =
+{
+      23,    24,    25,    26,    27,    83,    86,    90,    94,    22,
+      22,    22,    28,    22,    15,    16,    17,    18,    19,    20,
+      39,    37,   112,    52,    40,    35,    36,    34,   107,    46,
+      35,    36,   120,    29,    35,    36,   -17,    51,   -18,    54,
+      55,    56,   122,    38,    35,    36,    45,    99,   100,    57,
+      53,   102,   103,   124,    47,    35,    36,    37,    42,    43,
+      44,    95,    96,    97,    98,   101,   104,   143,   105,    53,
+      86,    58,   110,   111,    90,    59,    -2,     1,    94,    35,
+      36,   108,     2,     3,     4,     5,     6,     7,     8,     9,
+      10,    11,    74,    61,   125,    62,   134,   135,   129,   136,
+     137,    63,   133,    64,    65,    66,    67,    68,    69,    70,
+      71,    49,    50,   106,    75,    76,    77,    78,    79,    80,
+      81,   128,   109,    35,    36,    35,    36,   117,    -2,    -2,
+      64,    65,    66,    67,    68,    69,    70,    71,   132,   147,
+      35,    36,   115,   116,    91,    92,   118,   119,   108,   123,
+     140,   126,   127,   125,   129,   133,    64,    65,    66,    67,
+      68,    69,    70,    71,   130,   131,   142,   138,    87,    88,
+      64,    65,    66,    67,    68,    69,    70,    71,    48,   145,
+     139,    84,   146,   144,    60,     0,   141
+};
+
+static const yytype_int16 yycheck[] =
+{
+       3,     4,     5,     6,     7,    59,    61,    62,    63,     5,
+       5,     5,    37,     5,    43,    44,    45,    46,    47,    48,
+      37,    12,    16,    50,    41,    52,    53,     0,    50,    32,
+      52,    53,    50,    49,    52,    53,    17,    40,    17,    42,
+      43,    44,    50,     3,    52,    53,    17,    43,    44,    49,
+      41,    43,    44,    50,    17,    52,    53,    48,    26,    27,
+      28,    64,    65,    66,    67,    68,    69,   121,     3,    60,
+     125,    49,    75,    76,   129,    49,     0,     1,   133,    52,
+      53,    72,     6,     7,     8,     9,    10,    11,    12,    13,
+      14,    15,    12,    49,    85,    49,    99,   100,    89,   102,
+     103,    49,    93,    18,    19,    20,    21,    22,    23,    24,
+      25,     3,     4,     3,    34,    35,    36,    37,    38,    39,
+      40,    50,    41,    52,    53,    52,    53,     4,    52,    53,
+      18,    19,    20,    21,    22,    23,    24,    25,    50,   142,
+      52,    53,     3,     4,    32,    33,     4,     4,   139,     3,
+       5,     4,     4,   144,   145,   146,    18,    19,    20,    21,
+      22,    23,    24,    25,     3,     3,    51,     4,    30,    31,
+      18,    19,    20,    21,    22,    23,    24,    25,    37,   129,
+     108,    29,   133,   125,    53,    -1,   112
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     1,     6,     7,     8,     9,    10,    11,    12,    13,
+      14,    15,    55,    60,    66,    43,    44,    45,    46,    47,
+      48,    71,     5,    70,    70,    70,    70,    70,    37,    49,
+      56,    58,    57,    59,     0,    52,    53,    72,     3,    37,
+      41,    69,    26,    27,    28,    17,    70,    17,    55,     3,
+       4,    70,    50,    72,    70,    70,    70,    49,    49,    49,
+      69,    49,    49,    49,    18,    19,    20,    21,    22,    23,
+      24,    25,    61,    65,    12,    34,    35,    36,    37,    38,
+      39,    40,    67,    67,    29,    64,    65,    30,    31,    62,
+      65,    32,    33,    63,    65,    70,    70,    70,    70,    43,
+      44,    70,    43,    44,    70,     3,     3,    50,    72,    41,
+      70,    70,    16,    68,    70,     3,     4,     4,     4,     4,
+      50,    72,    50,     3,    50,    72,     4,     4,    50,    72,
+       3,     3,    50,    72,    70,    70,    70,    70,     4,    61,
+       5,    68,    51,    67,    64,    62,    63,    70
+};
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
+#define YYEMPTY		(-2)
 #define YYEOF		0
+
 #define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
-#define YYERROR		goto yyerrlab1
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
 /* Like YYERROR except do call yyerror.  This remains here temporarily
    to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
+
 #define YYFAIL		goto yyerrlab
+
 #define YYRECOVERING()  (!!yyerrstatus)
+
 #define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
     {								\
       yychar = (Token);						\
       yylval = (Value);						\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");			\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).
-
-   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
-   first token.  By default, to implement support for ranges, extend
-   its range to the last symbol.  */
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
 
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
-   Current.last_line   = Rhs[N].last_line;	\
-   Current.last_column = Rhs[N].last_column;
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
 
-/* YYLEX -- calling `yylex' with the right arguments.  */
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
 
-#if YYPURE
-# if YYLSP_NEEDED
-#  ifdef YYLEX_PARAM
-#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
-#  else
-#   define YYLEX		yylex (&yylval, &yylloc)
-#  endif
-# else /* !YYLSP_NEEDED */
-#  ifdef YYLEX_PARAM
-#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
-#  else
-#   define YYLEX		yylex (&yylval)
-#  endif
-# endif /* !YYLSP_NEEDED */
-#else /* !YYPURE */
-# define YYLEX			yylex ()
-#endif /* !YYPURE */
 
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
 
 /* Enable debugging if requested.  */
 #if YYDEBUG
@@ -596,14 +838,164 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value, Location); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+    YYLTYPE const * const yylocationp;
+#endif
+{
+  if (!yyvaluep)
+    return;
+  YYUSE (yylocationp);
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep, yylocationp)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+    YYLTYPE const * const yylocationp;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  YY_LOCATION_PRINT (yyoutput, *yylocationp);
+  YYFPRINTF (yyoutput, ": ");
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yylsp, yyrule)
+    YYSTYPE *yyvsp;
+    YYLTYPE *yylsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       , &(yylsp[(yyi + 1) - (yynrhs)])		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, yylsp, Rule); \
+} while (YYID (0))
+
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
 
+
 /* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
 # define YYINITDEPTH 200
@@ -613,59 +1005,59 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
+
 
-#ifdef YYERROR_VERBOSE
+
+#if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -674,149 +1066,337 @@
 }
 #  endif
 # endif
-#endif
-
-#line 315 "/usr/share/misc/bison.simple"
 
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
 
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
+  if (! yyres)
+    return yystrlen (yystr);
 
-#ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL
-# else
-#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+  return yystpcpy (yyres, yystr) - yyres;
+}
 # endif
-#else /* !YYPARSE_PARAM */
-# define YYPARSE_PARAM_ARG
-# define YYPARSE_PARAM_DECL
-#endif /* !YYPARSE_PARAM */
-
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-# ifdef YYPARSE_PARAM
-int yyparse (void *);
-# else
-int yyparse (void);
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-#endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
 
-/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
-   variables are global, or local to YYPARSE.  */
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
 
-#define YY_DECL_NON_LSP_VARIABLES			\
-/* The lookahead symbol.  */				\
-int yychar;						\
-							\
-/* The semantic value of the lookahead symbol. */	\
-YYSTYPE yylval;						\
-							\
-/* Number of parse errors so far.  */			\
-int yynerrs;
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
 
-#if YYLSP_NEEDED
-# define YY_DECL_VARIABLES			\
-YY_DECL_NON_LSP_VARIABLES			\
-						\
-/* Location data for the lookahead symbol.  */	\
-YYLTYPE yylloc;
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp)
 #else
-# define YY_DECL_VARIABLES			\
-YY_DECL_NON_LSP_VARIABLES
+static void
+yydestruct (yymsg, yytype, yyvaluep, yylocationp)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+    YYLTYPE *yylocationp;
 #endif
+{
+  YYUSE (yyvaluep);
+  YYUSE (yylocationp);
 
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
-/* If nonreentrant, generate the variables here. */
+  switch (yytype)
+    {
 
-#if !YYPURE
-YY_DECL_VARIABLES
-#endif  /* !YYPURE */
+      default:
+	break;
+    }
+}
 
-int
-yyparse (YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  /* If reentrant, generate the variables here. */
-#if YYPURE
-  YY_DECL_VARIABLES
-#endif  /* !YYPURE */
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
 
-  register int yystate;
-  register int yyn;
-  int yyresult;
-  /* Number of tokens to shift before error messages enabled.  */
-  int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yychar1 = 0;
 
-  /* Three stacks and their tools:
-     `yyss': related to states,
-     `yyvs': related to semantic values,
-     `yyls': related to locations.
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
 
-     Refer to the stacks thru separate pointers, to allow yyoverflow
-     to reallocate them elsewhere.  */
+/* Location data for the lookahead symbol.  */
+YYLTYPE yylloc;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
 
-  /* The state stack. */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
 
-  /* The semantic value stack.  */
-  YYSTYPE yyvsa[YYINITDEPTH];
-  YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
 
-#if YYLSP_NEEDED
-  /* The location stack.  */
-  YYLTYPE yylsa[YYINITDEPTH];
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
-#endif
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
 
-#if YYLSP_NEEDED
-# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
 #else
-# define YYPOPSTACK   (yyvsp--, yyssp--)
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
 #endif
+{
+
 
-  YYSIZE_T yystacksize = YYINITDEPTH;
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+       `yyls': related to locations.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    /* The location stack.  */
+    YYLTYPE yylsa[YYINITDEPTH];
+    YYLTYPE *yyls;
+    YYLTYPE *yylsp;
 
+    /* The locations where the error started and ended.  */
+    YYLTYPE yyerror_range[2];
 
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
-#if YYLSP_NEEDED
   YYLTYPE yyloc;
-#endif
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule. */
-  int yylen;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yyls = yylsa;
+  yystacksize = YYINITDEPTH;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
   yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+  yychar = YYEMPTY; /* Cause a token to be read.  */
 
   /* Initialize stack pointers.
      Waste one element of value and location stack
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
-
   yyssp = yyss;
   yyvsp = yyvs;
-#if YYLSP_NEEDED
   yylsp = yyls;
+
+#if YYLTYPE_IS_TRIVIAL
+  /* Initialize the default location before parsing starts.  */
+  yylloc.first_line   = yylloc.last_line   = 1;
+  yylloc.first_column = yylloc.last_column = 1;
 #endif
+
   goto yysetstate;
 
 /*------------------------------------------------------------.
@@ -824,70 +1404,61 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
   *yyssp = yystate;
 
-  if (yyssp >= yyss + yystacksize - 1)
+  if (yyss + yystacksize - 1 <= yyssp)
     {
       /* Get the current used size of the three stacks, in elements.  */
       YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to reallocate the stack. Use copies of
+	/* Give user a chance to reallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
+	YYLTYPE *yyls1 = yyls;
 
 	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  */
-# if YYLSP_NEEDED
-	YYLTYPE *yyls1 = yyls;
-	/* This used to be a conditional around just the two extra args,
-	   but that might be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 		    &yyls1, yysize * sizeof (*yylsp),
 		    &yystacksize);
+
 	yyls = yyls1;
-# else
-	yyoverflow ("parser stack overflow",
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-		    &yystacksize);
-# endif
 	yyss = yyss1;
 	yyvs = yyvs1;
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	goto yyoverflowlab;
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
       yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
+      if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
-	YYSTACK_RELOCATE (yyss);
-	YYSTACK_RELOCATE (yyvs);
-# if YYLSP_NEEDED
-	YYSTACK_RELOCATE (yyls);
-# endif
-# undef YYSTACK_RELOCATE
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+	YYSTACK_RELOCATE (yyls_alloc, yyls);
+#  undef YYSTACK_RELOCATE
 	if (yyss1 != yyssa)
 	  YYSTACK_FREE (yyss1);
       }
@@ -896,123 +1467,83 @@
 
       yyssp = yyss + yysize - 1;
       yyvsp = yyvs + yysize - 1;
-#if YYLSP_NEEDED
       yylsp = yyls + yysize - 1;
-#endif
 
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
 		  (unsigned long int) yystacksize));
 
-      if (yyssp >= yyss + yystacksize - 1)
+      if (yyss + yystacksize - 1 <= yyssp)
 	YYABORT;
     }
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
-  goto yybackup;
+  if (yystate == YYFINAL)
+    YYACCEPT;
 
+  goto yybackup;
 
 /*-----------.
 | yybackup.  |
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
 
   /* First try to decide what to do without reference to lookahead token.  */
-
   yyn = yypact[yystate];
-  if (yyn == YYFLAG)
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
+  if (yychar <= YYEOF)
     {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
+      yychar = yytoken = YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE (yychar);
-
-#if YYDEBUG
-     /* We have to keep this `#if YYDEBUG', since we use variables
-	which are defined only if `YYDEBUG' is set.  */
-      if (yydebug)
-	{
-	  YYFPRINTF (stderr, "Next token is %d (%s",
-		     yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise
-	     meaning of a token, for further debugging info.  */
-# ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-# endif
-	  YYFPRINTF (stderr, ")\n");
-	}
-#endif
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
-    goto yydefault;
-
-  yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
     {
-      if (yyn == YYFLAG)
+      if (yyn == 0 || yyn == YYTABLE_NINF)
 	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrlab;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
-	      yychar, yytname[yychar1]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-#if YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
 
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+  *++yylsp = yylloc;
   goto yynewstate;
 
 
@@ -1036,313 +1567,452 @@
   /* If YYLEN is nonzero, implement the default value of the action:
      `$$ = $1'.
 
-     Otherwise, the following line sets YYVAL to the semantic value of
-     the lookahead token.  This behavior is undocumented and Bison
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
      users should not rely upon it.  Assigning to YYVAL
      unconditionally makes the parser a bit smaller, and it avoids a
      GCC warning that YYVAL may be used uninitialized.  */
   yyval = yyvsp[1-yylen];
 
-#if YYLSP_NEEDED
-  /* Similarly for the default location.  Let the user run additional
-     commands if for instance locations are ranges.  */
-  yyloc = yylsp[1-yylen];
+  /* Default location.  */
   YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
-#endif
-
-#if YYDEBUG
-  /* We have to keep this `#if YYDEBUG', since we use variables which
-     are defined only if `YYDEBUG' is set.  */
-  if (yydebug)
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
     {
-      int yyi;
-
-      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
-		 yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
-	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
+        case 3:
 
-  switch (yyn) {
-
-case 2:
-#line 123 "cfgparser1.y"
-{ cur_config.debug=yyvsp[0].i; }
-    break;
-case 3:
+/* Line 1455 of yacc.c  */
 #line 124 "cfgparser1.y"
-{ cur_config.user=yyvsp[0].s; }
+    { cur_config.debug=(yyvsp[(2) - (2)].i); ;}
     break;
-case 4:
+
+  case 4:
+
+/* Line 1455 of yacc.c  */
 #line 125 "cfgparser1.y"
-{ cur_config.group=yyvsp[0].s; }
+    { cur_config.user=(yyvsp[(2) - (2)].s); ;}
     break;
-case 5:
+
+  case 5:
+
+/* Line 1455 of yacc.c  */
 #line 126 "cfgparser1.y"
-{ cur_config.mailer=yyvsp[0].s; }
+    { cur_config.group=(yyvsp[(2) - (2)].s); ;}
     break;
-case 6:
+
+  case 6:
+
+/* Line 1455 of yacc.c  */
 #line 127 "cfgparser1.y"
-{ cur_config.timestamp_format=yyvsp[0].s; }
+    { cur_config.mailer=(yyvsp[(2) - (2)].s); ;}
     break;
-case 7:
+
+  case 7:
+
+/* Line 1455 of yacc.c  */
 #line 128 "cfgparser1.y"
-{ cur_config.pid_file=yyvsp[0].s; }
+    { cur_config.timestamp_format=(yyvsp[(2) - (2)].s); ;}
+    break;
+
+  case 8:
+
+/* Line 1455 of yacc.c  */
+#line 129 "cfgparser1.y"
+    { cur_config.pid_file=(yyvsp[(2) - (2)].s); ;}
     break;
-case 9:
-#line 130 "cfgparser1.y"
-{ cur_config.rrd_interval=yyvsp[0].i; }
+
+  case 10:
+
+/* Line 1455 of yacc.c  */
+#line 131 "cfgparser1.y"
+    { cur_config.rrd_interval=(yyvsp[(3) - (3)].i); ;}
     break;
-case 13:
-#line 135 "cfgparser1.y"
-{
+
+  case 14:
+
+/* Line 1455 of yacc.c  */
+#line 136 "cfgparser1.y"
+    {
 			logit("Configuration file syntax error. Line %i, character %i",
-					yyloc.first_line+1,yyloc.first_column+1);
+					(yyloc).first_line+1,(yyloc).first_column+1);
 			YYABORT;
-		}
+		;}
     break;
-case 14:
-#line 142 "cfgparser1.y"
-{ yyval.a=make_alarm(); }
-    break;
-case 15:
-#line 145 "cfgparser1.y"
-{ yyval.t=make_target(); }
-    break;
-case 16:
-#line 148 "cfgparser1.y"
-{ 
-	   		yyval.a=&cur_config.alarm_defaults; 
-			cur_alarm=yyval.a;
-	   	}
-    break;
-case 17:
-#line 154 "cfgparser1.y"
-{ 
-	    		yyval.t=&cur_config.target_defaults; 
-			cur_target=yyval.t;
-		}
+
+  case 15:
+
+/* Line 1455 of yacc.c  */
+#line 143 "cfgparser1.y"
+    { (yyval.a)=make_alarm(); ;}
+    break;
+
+  case 16:
+
+/* Line 1455 of yacc.c  */
+#line 146 "cfgparser1.y"
+    { (yyval.t)=make_target(); ;}
+    break;
+
+  case 17:
+
+/* Line 1455 of yacc.c  */
+#line 149 "cfgparser1.y"
+    { 
+	   		(yyval.a)=&cur_config.alarm_defaults; 
+			cur_alarm=(yyval.a);
+	   	;}
+    break;
+
+  case 18:
+
+/* Line 1455 of yacc.c  */
+#line 155 "cfgparser1.y"
+    { 
+	    		(yyval.t)=&cur_config.target_defaults; 
+			cur_target=(yyval.t);
+		;}
     break;
-case 19:
-#line 162 "cfgparser1.y"
-{ 
-			cur_alarm->name=yyvsp[-3].s;
+
+  case 20:
+
+/* Line 1455 of yacc.c  */
+#line 163 "cfgparser1.y"
+    { 
+			cur_alarm->name=(yyvsp[(4) - (7)].s);
 			add_alarm(AL_DOWN); 
-		}
+		;}
     break;
-case 20:
-#line 167 "cfgparser1.y"
-{ 
-			cur_alarm->name=yyvsp[-3].s;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 168 "cfgparser1.y"
+    { 
+			cur_alarm->name=(yyvsp[(4) - (7)].s);
 			add_alarm(AL_LOSS); 
-		}
+		;}
     break;
-case 21:
-#line 172 "cfgparser1.y"
-{ 
-			cur_alarm->name=yyvsp[-3].s;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 173 "cfgparser1.y"
+    { 
+			cur_alarm->name=(yyvsp[(4) - (7)].s);
 			add_alarm(AL_DELAY); 
-		}
+		;}
     break;
-case 25:
-#line 184 "cfgparser1.y"
-{ cur_alarm->p.lh.low=yyvsp[0].i; }
-    break;
-case 26:
-#line 186 "cfgparser1.y"
-{ cur_alarm->p.lh.high=yyvsp[0].i; }
-    break;
-case 29:
-#line 192 "cfgparser1.y"
-{ cur_alarm->p.lh.low=yyvsp[0].i; }
-    break;
-case 30:
-#line 194 "cfgparser1.y"
-{ cur_alarm->p.lh.high=yyvsp[0].i; }
-    break;
-case 33:
-#line 200 "cfgparser1.y"
-{ cur_alarm->p.val=yyvsp[0].i; }
-    break;
-case 36:
-#line 206 "cfgparser1.y"
-{ cur_alarm->mailto=yyvsp[0].s; }
-    break;
-case 37:
-#line 208 "cfgparser1.y"
-{ cur_alarm->mailfrom=yyvsp[0].s; }
-    break;
-case 38:
-#line 210 "cfgparser1.y"
-{ cur_alarm->mailenvfrom=yyvsp[0].s; }
-    break;
-case 39:
-#line 212 "cfgparser1.y"
-{ cur_alarm->mailsubject=yyvsp[0].s; }
-    break;
-case 40:
-#line 214 "cfgparser1.y"
-{ 
-			if (cur_alarm->command_on==NULL) cur_alarm->command_on=yyvsp[0].s; 
-			if (cur_alarm->command_off==NULL) cur_alarm->command_off=yyvsp[0].s; 
-		}
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 185 "cfgparser1.y"
+    { cur_alarm->p.lh.low=(yyvsp[(2) - (2)].i); ;}
     break;
-case 41:
-#line 219 "cfgparser1.y"
-{ cur_alarm->command_on=yyvsp[0].s; }
-    break;
-case 42:
-#line 221 "cfgparser1.y"
-{ cur_alarm->command_off=yyvsp[0].s; }
-    break;
-case 43:
-#line 223 "cfgparser1.y"
-{ 
-			if (cur_alarm->pipe_on==NULL) cur_alarm->pipe_on=yyvsp[0].s; 
-			if (cur_alarm->pipe_off==NULL) cur_alarm->pipe_off=yyvsp[0].s; 
-		}
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 187 "cfgparser1.y"
+    { cur_alarm->p.lh.high=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 193 "cfgparser1.y"
+    { cur_alarm->p.lh.low=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 31:
+
+/* Line 1455 of yacc.c  */
+#line 195 "cfgparser1.y"
+    { cur_alarm->p.lh.high=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 201 "cfgparser1.y"
+    { cur_alarm->p.val=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 207 "cfgparser1.y"
+    { cur_alarm->mailto=(yyvsp[(2) - (2)].s); ;}
+    break;
+
+  case 38:
+
+/* Line 1455 of yacc.c  */
+#line 209 "cfgparser1.y"
+    { cur_alarm->mailfrom=(yyvsp[(2) - (2)].s); ;}
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 211 "cfgparser1.y"
+    { cur_alarm->mailenvfrom=(yyvsp[(2) - (2)].s); ;}
+    break;
+
+  case 40:
+
+/* Line 1455 of yacc.c  */
+#line 213 "cfgparser1.y"
+    { cur_alarm->mailsubject=(yyvsp[(2) - (2)].s); ;}
+    break;
+
+  case 41:
+
+/* Line 1455 of yacc.c  */
+#line 215 "cfgparser1.y"
+    { 
+			if (cur_alarm->command_on==NULL) cur_alarm->command_on=(yyvsp[(2) - (2)].s); 
+			if (cur_alarm->command_off==NULL) cur_alarm->command_off=(yyvsp[(2) - (2)].s); 
+		;}
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 220 "cfgparser1.y"
+    { cur_alarm->command_on=(yyvsp[(3) - (3)].s); ;}
+    break;
+
+  case 43:
+
+/* Line 1455 of yacc.c  */
+#line 222 "cfgparser1.y"
+    { cur_alarm->command_off=(yyvsp[(3) - (3)].s); ;}
+    break;
+
+  case 44:
+
+/* Line 1455 of yacc.c  */
+#line 224 "cfgparser1.y"
+    { 
+			if (cur_alarm->pipe_on==NULL) cur_alarm->pipe_on=(yyvsp[(2) - (2)].s); 
+			if (cur_alarm->pipe_off==NULL) cur_alarm->pipe_off=(yyvsp[(2) - (2)].s); 
+		;}
+    break;
+
+  case 45:
+
+/* Line 1455 of yacc.c  */
+#line 229 "cfgparser1.y"
+    { cur_alarm->pipe_on=(yyvsp[(3) - (3)].s); ;}
+    break;
+
+  case 46:
+
+/* Line 1455 of yacc.c  */
+#line 231 "cfgparser1.y"
+    { cur_alarm->pipe_off=(yyvsp[(3) - (3)].s); ;}
+    break;
+
+  case 47:
+
+/* Line 1455 of yacc.c  */
+#line 233 "cfgparser1.y"
+    { cur_alarm->combine_interval=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 48:
+
+/* Line 1455 of yacc.c  */
+#line 235 "cfgparser1.y"
+    { cur_alarm->repeat_interval=(yyvsp[(2) - (3)].i); cur_alarm->repeat_max=(yyvsp[(3) - (3)].i); ;}
     break;
-case 44:
-#line 228 "cfgparser1.y"
-{ cur_alarm->pipe_on=yyvsp[0].s; }
-    break;
-case 45:
-#line 230 "cfgparser1.y"
-{ cur_alarm->pipe_off=yyvsp[0].s; }
-    break;
-case 46:
-#line 232 "cfgparser1.y"
-{ cur_alarm->combine_interval=yyvsp[0].i; }
-    break;
-case 47:
-#line 234 "cfgparser1.y"
-{ cur_alarm->repeat_interval=yyvsp[-1].i; cur_alarm->repeat_max=yyvsp[0].i; }
-    break;
-case 48:
-#line 236 "cfgparser1.y"
-{ cur_alarm->combine_interval=yyvsp[0].i; cur_alarm->repeat_max=0;}
-    break;
-case 50:
-#line 242 "cfgparser1.y"
-{ 
-			cur_target->name=yyvsp[-3].s;
+
+  case 49:
+
+/* Line 1455 of yacc.c  */
+#line 237 "cfgparser1.y"
+    { cur_alarm->combine_interval=(yyvsp[(2) - (2)].i); cur_alarm->repeat_max=0;;}
+    break;
+
+  case 51:
+
+/* Line 1455 of yacc.c  */
+#line 243 "cfgparser1.y"
+    { 
+			cur_target->name=(yyvsp[(3) - (6)].s);
 			add_target(); 
-		}
+		;}
+    break;
+
+  case 53:
+
+/* Line 1455 of yacc.c  */
+#line 251 "cfgparser1.y"
+    { cur_target->description=(yyvsp[(2) - (2)].s); ;}
     break;
-case 52:
-#line 250 "cfgparser1.y"
-{ cur_target->description=yyvsp[0].s; }
-    break;
-case 53:
-#line 252 "cfgparser1.y"
-{ cur_target->alarms=yyvsp[0].al; }
-    break;
-case 54:
-#line 254 "cfgparser1.y"
-{ cur_target->alarms_override=1; cur_target->alarms=yyvsp[0].al; }
-    break;
-case 55:
-#line 256 "cfgparser1.y"
-{ cur_target->interval=yyvsp[0].i; }
-    break;
-case 56:
-#line 258 "cfgparser1.y"
-{ cur_target->interval=yyvsp[0].i; }
-    break;
-case 57:
-#line 260 "cfgparser1.y"
-{ cur_target->avg_delay_samples=yyvsp[0].i; }
-    break;
-case 58:
-#line 262 "cfgparser1.y"
-{ cur_target->avg_loss_samples=yyvsp[0].i; }
-    break;
-case 59:
-#line 264 "cfgparser1.y"
-{ cur_target->avg_loss_delay_samples=yyvsp[0].i; }
-    break;
-case 60:
-#line 266 "cfgparser1.y"
-{ cur_target->rrd_filename=yyvsp[0].s; }
-    break;
-case 62:
-#line 271 "cfgparser1.y"
-{ yyval.al=alarm2list(yyvsp[0].s,NULL); }
-    break;
-case 63:
-#line 273 "cfgparser1.y"
-{ yyval.al=alarm2list(yyvsp[0].s,yyvsp[-2].al); }
-    break;
-case 65:
-#line 278 "cfgparser1.y"
-{ cur_config.status_file=yyvsp[0].s; }
-    break;
-case 66:
-#line 280 "cfgparser1.y"
-{ cur_config.status_interval=yyvsp[0].i; }
-    break;
-case 67:
-#line 282 "cfgparser1.y"
-{ cur_config.status_interval=yyvsp[0].i; }
-    break;
-case 69:
-#line 287 "cfgparser1.y"
-{ yyval.s=pool_strdup(&cur_config.pool,yyvsp[0].s); }
+
+  case 54:
+
+/* Line 1455 of yacc.c  */
+#line 253 "cfgparser1.y"
+    { cur_target->srcip = (yyvsp[(2) - (2)].s); ;}
     break;
-case 70:
-#line 290 "cfgparser1.y"
-{ yyval.i=1; }
+
+  case 55:
+
+/* Line 1455 of yacc.c  */
+#line 255 "cfgparser1.y"
+    { cur_target->alarms=(yyvsp[(2) - (2)].al); ;}
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 257 "cfgparser1.y"
+    { cur_target->alarms_override=1; cur_target->alarms=(yyvsp[(3) - (3)].al); ;}
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 259 "cfgparser1.y"
+    { cur_target->interval=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 58:
+
+/* Line 1455 of yacc.c  */
+#line 261 "cfgparser1.y"
+    { cur_target->interval=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 59:
+
+/* Line 1455 of yacc.c  */
+#line 263 "cfgparser1.y"
+    { cur_target->avg_delay_samples=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 60:
+
+/* Line 1455 of yacc.c  */
+#line 265 "cfgparser1.y"
+    { cur_target->avg_loss_samples=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 61:
+
+/* Line 1455 of yacc.c  */
+#line 267 "cfgparser1.y"
+    { cur_target->avg_loss_delay_samples=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 62:
+
+/* Line 1455 of yacc.c  */
+#line 269 "cfgparser1.y"
+    { cur_target->rrd_filename=(yyvsp[(3) - (3)].s); ;}
+    break;
+
+  case 64:
+
+/* Line 1455 of yacc.c  */
+#line 274 "cfgparser1.y"
+    { (yyval.al)=alarm2list((yyvsp[(1) - (1)].s),NULL); ;}
+    break;
+
+  case 65:
+
+/* Line 1455 of yacc.c  */
+#line 276 "cfgparser1.y"
+    { (yyval.al)=alarm2list((yyvsp[(3) - (3)].s),(yyvsp[(1) - (3)].al)); ;}
+    break;
+
+  case 67:
+
+/* Line 1455 of yacc.c  */
+#line 281 "cfgparser1.y"
+    { cur_config.status_file=(yyvsp[(2) - (2)].s); ;}
     break;
-case 71:
-#line 291 "cfgparser1.y"
-{ yyval.i=0; }
+
+  case 68:
+
+/* Line 1455 of yacc.c  */
+#line 283 "cfgparser1.y"
+    { cur_config.status_interval=(yyvsp[(2) - (2)].i); ;}
+    break;
+
+  case 69:
+
+/* Line 1455 of yacc.c  */
+#line 285 "cfgparser1.y"
+    { cur_config.status_interval=(yyvsp[(2) - (2)].i); ;}
     break;
-case 72:
-#line 292 "cfgparser1.y"
-{ yyval.i=1; }
+
+  case 71:
+
+/* Line 1455 of yacc.c  */
+#line 290 "cfgparser1.y"
+    { (yyval.s)=pool_strdup(&cur_config.pool,(yyvsp[(1) - (1)].s)); ;}
     break;
-case 73:
+
+  case 72:
+
+/* Line 1455 of yacc.c  */
 #line 293 "cfgparser1.y"
-{ yyval.i=0; }
+    { (yyval.i)=1; ;}
     break;
-case 74:
+
+  case 73:
+
+/* Line 1455 of yacc.c  */
 #line 294 "cfgparser1.y"
-{ yyval.i=1; }
+    { (yyval.i)=0; ;}
     break;
-case 75:
+
+  case 74:
+
+/* Line 1455 of yacc.c  */
 #line 295 "cfgparser1.y"
-{ yyval.i=0; }
+    { (yyval.i)=1; ;}
     break;
-}
 
-#line 705 "/usr/share/misc/bison.simple"
+  case 75:
 
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#if YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
+/* Line 1455 of yacc.c  */
+#line 296 "cfgparser1.y"
+    { (yyval.i)=0; ;}
+    break;
 
-#if YYDEBUG
-  if (yydebug)
-    {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
+  case 76:
+
+/* Line 1455 of yacc.c  */
+#line 297 "cfgparser1.y"
+    { (yyval.i)=1; ;}
+    break;
+
+  case 77:
+
+/* Line 1455 of yacc.c  */
+#line 298 "cfgparser1.y"
+    { (yyval.i)=0; ;}
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 2006 "cfgparser1.tab.c"
+      default: break;
     }
-#endif
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
-#if YYLSP_NEEDED
   *++yylsp = yyloc;
-#endif
 
   /* Now `shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
@@ -1350,11 +2020,11 @@
 
   yyn = yyr1[yyn];
 
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
-    yystate = yydefgoto[yyn - YYNTBASE];
+    yystate = yydefgoto[yyn - YYNTOKENS];
 
   goto yynewstate;
 
@@ -1367,155 +2037,132 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  char *yymsg;
-	  int yyx, yycount;
-
-	  yycount = 0;
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  for (yyx = yyn < 0 ? -yyn : 0;
-	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
-	    if (yycheck[yyx + yyn] == yyx)
-	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
-	  yysize += yystrlen ("parse error, unexpected ") + 1;
-	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
-
-	      if (yycount < 5)
-		{
-		  yycount = 0;
-		  for (yyx = yyn < 0 ? -yyn : 0;
-		       yyx < (int) (sizeof (yytname) / sizeof (char *));
-		       yyx++)
-		    if (yycheck[yyx + yyn] == yyx)
-		      {
-			const char *yyq = ! yycount ? ", expecting " : " or ";
-			yyp = yystpcpy (yyp, yyq);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yycount++;
-		      }
-		}
-	      yyerror (yymsg);
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
 	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exhausted");
-	}
-      else
-#endif /* defined (YYERROR_VERBOSE) */
-	yyerror ("parse error");
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
-  goto yyerrlab1;
 
+  yyerror_range[0] = yylloc;
 
-/*--------------------------------------------------.
-| yyerrlab1 -- error raised explicitly by an action |
-`--------------------------------------------------*/
-yyerrlab1:
   if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
 	 error, discard it.  */
 
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
-      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
-		  yychar, yytname[yychar1]));
-      yychar = YYEMPTY;
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval, &yylloc);
+	  yychar = YYEMPTY;
+	}
     }
 
   /* Else will try to reuse lookahead token after shifting the error
      token.  */
+  goto yyerrlab1;
 
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
-
-  goto yyerrhandle;
-
-
-/*-------------------------------------------------------------------.
-| yyerrdefault -- current state does not do anything special for the |
-| error token.                                                       |
-`-------------------------------------------------------------------*/
-yyerrdefault:
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
 
-  /* If its default is to accept any token, ok.  Otherwise pop it.  */
-  yyn = yydefact[yystate];
-  if (yyn)
-    goto yydefault;
-#endif
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  yyerror_range[0] = yylsp[1-yylen];
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
 
 
-/*---------------------------------------------------------------.
-| yyerrpop -- pop the current state because it cannot handle the |
-| error token                                                    |
-`---------------------------------------------------------------*/
-yyerrpop:
-  if (yyssp == yyss)
-    YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#if YYLSP_NEEDED
-  yylsp--;
-#endif
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
 
-#if YYDEBUG
-  if (yydebug)
+  for (;;)
     {
-      short *yyssp1 = yyss - 1;
-      YYFPRINTF (stderr, "Error: state stack now");
-      while (yyssp1 != yyssp)
-	YYFPRINTF (stderr, " %d", *++yyssp1);
-      YYFPRINTF (stderr, "\n");
-    }
-#endif
-
-/*--------------.
-| yyerrhandle.  |
-`--------------*/
-yyerrhandle:
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
 
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
 
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
+      yyerror_range[0] = *yylsp;
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp, yylsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
     }
-  else if (yyn == 0)
-    goto yyerrpop;
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
+  *++yyvsp = yylval;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
+  yyerror_range[1] = yylloc;
+  /* Using YYLLOC is tempting, but would change the location of
+     the lookahead.  YYLOC is available though.  */
+  YYLLOC_DEFAULT (yyloc, (yyerror_range - 1), 2);
+  *++yylsp = yyloc;
 
-  *++yyvsp = yylval;
-#if YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
@@ -1535,24 +2182,49 @@
   yyresult = 1;
   goto yyreturn;
 
-/*---------------------------------------------.
-| yyoverflowab -- parser overflow comes here.  |
-`---------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
+#endif
 
 yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval, &yylloc);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp, yylsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
-#line 303 "cfgparser1.y"
+
+
+
+/* Line 1675 of yacc.c  */
+#line 306 "cfgparser1.y"
 
 void yyerror (const char *s) {
 	logit("%s", s);
 }
 
+
diff -ur src_old/cfgparser1.h src/cfgparser1.h
--- src_old/cfgparser1.h	2010-08-10 20:41:31.000000000 +0000
+++ src/cfgparser1.h	2010-08-10 20:41:37.000000000 +0000
@@ -28,51 +28,52 @@
 # define YYLTYPE_IS_TRIVIAL 1
 #endif
 
-# define	TIME	257
-# define	INTEGER	258
-# define	STRING	259
-# define	DEBUG	260
-# define	USER	261
-# define	GROUP	262
-# define	PID_FILE	263
-# define	MAILER	264
-# define	TIMESTAMP_FORMAT	265
-# define	RRD	266
-# define	STATUS	267
-# define	ALARM	268
-# define	TARGET	269
-# define	OVERRIDE	270
-# define	DEFAULT	271
-# define	MAILTO	272
-# define	MAILFROM	273
-# define	MAILENVFROM	274
-# define	MAILSUBJECT	275
-# define	COMMAND	276
-# define	PIPE	277
-# define	COMBINE	278
-# define	REPEAT	279
-# define	DOWN	280
-# define	LOSS	281
-# define	DELAY	282
-# define	TIME_	283
-# define	PERCENT_LOW	284
-# define	PERCENT_HIGH	285
-# define	DELAY_LOW	286
-# define	DELAY_HIGH	287
-# define	DESCRIPTION	288
-# define	ALARMS	289
-# define	INTERVAL	290
-# define	AVG_DELAY_SAMPLES	291
-# define	AVG_LOSS_SAMPLES	292
-# define	AVG_LOSS_DELAY_SAMPLES	293
-# define	FILE_	294
-# define	ERROR	295
-# define	ON	296
-# define	OFF	297
-# define	YES	298
-# define	NO	299
-# define	TRUE	300
-# define	FALSE	301
+# define	TIME	258
+# define	INTEGER	259
+# define	STRING	260
+# define	DEBUG	261
+# define	USER	262
+# define	GROUP	263
+# define	PID_FILE	264
+# define	MAILER	265
+# define	TIMESTAMP_FORMAT	266
+# define	RRD	267
+# define	STATUS	268
+# define	ALARM	269
+# define	TARGET	270
+# define	OVERRIDE	271
+# define	DEFAULT	272
+# define	MAILTO	273
+# define	MAILFROM	274
+# define	MAILENVFROM	275
+# define	MAILSUBJECT	276
+# define	COMMAND	277
+# define	PIPE	278
+# define	COMBINE	279
+# define	REPEAT	280
+# define	DOWN	281
+# define	LOSS	282
+# define	DELAY	283
+# define	TIME_	284
+# define	PERCENT_LOW	285
+# define	PERCENT_HIGH	286
+# define	DELAY_LOW	287
+# define	DELAY_HIGH	288
+# define	DESCRIPTION	289
+# define	SRCIP	290
+# define	ALARMS	291
+# define	INTERVAL	292
+# define	AVG_DELAY_SAMPLES	293
+# define	AVG_LOSS_SAMPLES	294
+# define	AVG_LOSS_DELAY_SAMPLES	295
+# define	FILE_	296
+# define	ERROR	297
+# define	ON	298
+# define	OFF	299
+# define	YES	300
+# define	NO	301
+# define	TRUE	302
+# define	FALSE	303
 
 
 extern YYSTYPE yylval;
diff -ur src_old/cfgparser1.y src/cfgparser1.y
--- src_old/cfgparser1.y	2010-08-10 20:41:31.000000000 +0000
+++ src/cfgparser1.y	2010-08-10 20:41:37.000000000 +0000
@@ -97,6 +97,7 @@
 %token DELAY_HIGH
 
 %token DESCRIPTION
+%token SRCIP
 %token ALARMS
 %token INTERVAL
 %token AVG_DELAY_SAMPLES
@@ -248,6 +249,8 @@
 targetcfg: /* */ 
 	| DESCRIPTION string 
 		{ cur_target->description=$2; }
+	| SRCIP string 
+		{ cur_target->srcip = $2; }
 	| ALARMS alarmlist
 		{ cur_target->alarms=$2; }
 	| ALARMS OVERRIDE alarmlist
diff -ur src_old/cfgparser2.l src/cfgparser2.l
--- src_old/cfgparser2.l	2010-08-10 20:41:31.000000000 +0000
+++ src/cfgparser2.l	2010-08-10 20:41:37.000000000 +0000
@@ -82,6 +82,7 @@
 delay_high	{ LOC; LOCINC; return DELAY_HIGH; }
 delay_low	{ LOC; LOCINC; return DELAY_LOW; }
 description	{ LOC; LOCINC; return DESCRIPTION; }
+srcip		{ LOC; LOCINC; return SRCIP; }
 down		{ LOC; LOCINC; return DOWN; }
 false		{ LOC; LOCINC; return FALSE; }
 file		{ LOC; LOCINC; return FILE_; }
diff -ur src_old/conf.h src/conf.h
--- src_old/conf.h	2010-08-10 20:41:31.000000000 +0000
+++ src/conf.h	2010-08-10 20:41:37.000000000 +0000
@@ -72,6 +72,7 @@
 struct target_cfg {
 	char *name;
 	char *description;
+	char *srcip;
 	int interval;
 	int avg_delay_samples;
 	int avg_loss_delay_samples;
diff -ur src_old/icmp.c src/icmp.c
--- src_old/icmp.c	2010-08-10 20:41:31.000000000 +0000
+++ src/icmp.c	2010-08-10 20:41:37.000000000 +0000
@@ -151,14 +151,14 @@
 	size=sizeof(*p)+sizeof(ti);
 
 	p->icmp_cksum = in_cksum((u_short *)p,size,0);
-	ret=sendto(icmp_sock,p,size,MSG_DONTWAIT,
+	ret=sendto(t->socket,p,size,MSG_DONTWAIT,
 			(struct sockaddr *)&t->addr.addr4,sizeof(t->addr.addr4));
 	if (ret<0){
 		if (config->debug) myperror("sendto");
 	}
 }
 
-void recv_icmp(void){
+void recv_icmp(struct target *t){
 int len,hlen,icmplen,datalen;
 char buf[1024];
 struct sockaddr_in from;
@@ -171,6 +171,7 @@
 struct iovec iov;
 struct msghdr msg;
 struct cmsghdr *c;
+reloophack:
 
 	iov.iov_base=buf;
 	iov.iov_len=1000;
@@ -180,12 +181,13 @@
 	msg.msg_iovlen=1;
 	msg.msg_control=ans_data;
 	msg.msg_controllen=sizeof(ans_data);
-	len=recvmsg(icmp_sock, &msg, MSG_DONTWAIT);
+	len=recvmsg(t->socket, &msg, MSG_DONTWAIT);
 #else
 socklen_t sl;
+reloophack:
 
 	sl=sizeof(from);
-	len=recvfrom(icmp_sock,buf,1024,MSG_DONTWAIT,(struct sockaddr *)&from,&sl);
+	len=recvfrom(t->socket,buf,1024,MSG_DONTWAIT,(struct sockaddr *)&from,&sl);
 #endif
 	if (len<0){
 		if (errno==EAGAIN) return;
@@ -207,7 +209,7 @@
 #endif
 	if (time_recvp==NULL){
 #ifdef SIOCGSTAMP
-		if (!ioctl(icmp_sock, SIOCGSTAMP, &time_recv)){
+		if (!ioctl(t->socket, SIOCGSTAMP, &time_recv)){
 			debug("Got timestampt from ioctl()");
 		}else
 #endif
@@ -227,7 +229,8 @@
 		return;
 	}
 	if (icmp->icmp_id != ident){
-		debug("Alien echo-reply received");
+		debug("Alien echo-reply received from %s. Expected %i, received %i",inet_ntoa(from.sin_addr), ident, icmp->icmp_id);
+		goto reloophack;	
 		return;
 	}
 	debug("Ping reply from %s",inet_ntoa(from.sin_addr));
@@ -243,19 +246,23 @@
 #endif
 }
 
-int make_icmp_socket(void){
+int make_icmp_socket(struct target *t){
 int on;
 
-	icmp_sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
-	if (icmp_sock<0)
+	t->socket = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
+	if (t->socket < 0)
 		myperror("socket");
 #ifdef SO_TIMESTAMP
-	else{
+	else {
 		on=1;
-		if (setsockopt(icmp_sock, SOL_SOCKET, SO_TIMESTAMP, &on, sizeof(on)))
+		if (setsockopt(t->socket, SOL_SOCKET, SO_TIMESTAMP, &on, sizeof(on)))
 			myperror("setsockopt(SO_TIMESTAMP)");
 	}
 #endif
-	return icmp_sock;
+
+	if (bind(t->socket, (struct sockaddr *)&t->ifaddr.addr4, sizeof(t->ifaddr.addr4)) < 0)
+			myperror("bind socket");
+
+	return t->socket;
 }
 
diff -ur src_old/main.c src/main.c
--- src_old/main.c	2010-08-10 20:41:31.000000000 +0000
+++ src/main.c	2010-08-10 20:41:37.000000000 +0000
@@ -72,6 +72,7 @@
 		{		/* target defaults */
 				"default",	/* name */
 				"",		/* description */
+				"",		/* interface */
 				1000,		/* interval */
 				20,		/* avg_delay_samples */
 				5,		/* avg_loss_delay_samples */
@@ -217,11 +218,13 @@
 		}
 	}
 
+#if 0
 	make_icmp_socket();
 	make_icmp6_socket();
 	if (icmp6_sock<0 && icmp_sock<0){
 		return 1;
 	}
+#endif
 
 	pw=getpwnam(config->user);
 	if (!pw) {
@@ -286,9 +289,13 @@
 #ifdef FORKED_RECEIVER
 	signal(SIGCHLD,sigchld_handler);
 #endif
+	logit("Starting Alarm Pinger, apinger(%i)", ident);
+
 	main_loop();
+#if 0
 	if (icmp_sock>=0) close(icmp_sock);
 	if (icmp6_sock>=0) close(icmp6_sock);
+#endif
 
 	logit("Exiting on signal %i.",interrupted_by);
 
