<?php
/*
 * frr.inc
 *
 * part of pfSense (https://www.pfsense.org)
 * Copyright (c) 2017 Rubicon Communications, LLC (Netgate)
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require_once("config.inc");
require_once("functions.inc");
require_once("interfaces.inc");
require_once("service-utils.inc");
require_once("util.inc");

define('PKG_FRR_CONFIG_BASE', '/var/etc/frr');
/* Since we need to embed this in strings & HERE Docs, copy to a var. Can't embed constants. */
global $frr_config_base;
$frr_config_base = PKG_FRR_CONFIG_BASE;

global $frr_well_known_communities;
$frr_well_known_communities = array("internet", "no-export", "no-advertise", "local-as");

global $frr_auto_config_warning;
$frr_auto_config_warning = <<<EOF
##################### DO NOT EDIT THIS FILE! ######################
###################################################################
# This file was created by an automatic configuration generator.  #
# The contents of this file will be overwritten without warning!  #
###################################################################

EOF;

require_once("frr/inc/frr_validation.inc");
require_once("frr/inc/frr_zebra.inc");
require_once("frr/inc/frr_bgp.inc");
require_once("frr/inc/frr_ospf.inc");
require_once("frr/inc/frr_ospf6.inc");

/* Build a list of only CARP VIPs, formatted for use in a selection list */
function frr_get_carp_list() {
	$list = array();
	$list[] = array("name" => "none", "value" => "none");
	$carplist = get_configured_vip_list("all", VIP_CARP);
	foreach ($carplist as $vid => $vaddr) {
		$vip = get_configured_vip($vid);
		$list[] = array("name" => "$vaddr (vhid: {$vip['vhid']})", "value" => $vid);
	}
	return ($list);
}

/* Build a list of assigned/enabled interfaces, formatted for use in a selection
 * list, including IP Aliases, CARP VIPs, and OpenVPN interfaces. */
function frr_get_interfaces($includedefault = true, $includevips = true, $includelocalhost = false, $nameprefix = "", $valueprefix = "") {
	global $config;

	/* Only include the 'default' option when requested, some places like
	 * OSPF interface selections can't use 'default'.
	 */
	if ($includedefault) {
		$interfaces['default'] = "default";
	} else {
		$interfaces = array();
	}
	if ($includelocalhost) {
		$interfaces['lo0'] = "Localhost (lo0)";
	}
	$interfaces = array_merge($interfaces, get_configured_interface_with_descr());
	$ifs = array();

	/* Change the interfaces array into one properly formatted for an XML GUI select_source list */
	foreach ($interfaces as $iface => $ifacename) {
		$tmp["name"] = $nameprefix . $ifacename;
		$tmp["value"] = $valueprefix . $iface;
		$ifs[] = $tmp;
	}

	/* Get a list of VIPs */
	if ($includevips) {
		$viplist = get_configured_vip_list();
		foreach ($viplist as $vip => $address) {
			$tmp["name"] = $nameprefix . $address;
			$tmp["value"] = $valueprefix . $vip.'|'.$address;
			if (get_vip_descr($address)) {
				$tmp["name"] .= " (" . get_vip_descr($address) . ")";
			}
			$ifs[] = $tmp;
		}
	}

	/* Create a list of OpenVPN server and client interfaces. */
	foreach (array('server', 'client') as $mode) {
		if (is_array($config['openvpn']["openvpn-{$mode}"])) {
			foreach ($config['openvpn']["openvpn-{$mode}"] as $id => $setting) {
				if (!isset($setting['disable'])) {
					$tmp["name"] = $nameprefix . gettext("OpenVPN") . " ".$mode.": ".htmlspecialchars($setting['description']);
					$tmp["value"] = $valueprefix . 'ovpn' . substr($mode, 0, 1) . $setting['vpnid'];
					$ifs[] = $tmp;
				}
			}
		}
	}
	return $ifs;
}

/* Simple utility function to translate a select_source list of items into a 
 * list of values for easier testing by in_array() and similar cases. */
function frr_get_list_values($arr) {
	$vals = array();
	foreach ($arr as $a) {
		$vals[] = $a['value'];
	}
	return $vals;
}

/*
 * Called when a CARP VIP changes state
 * $pluginparams['event'] contains either 'rc.carpmaster' or 'rc.carpbackup'
 * $pluginparams['interface'] contains the affected VIP, id@int e.g. 19@igb1
 */
function frr_plugin_carp($pluginparams) {
	global $config;
	/* If frr is not configured, then stop */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	} else {
		return null;
	}
	/* If there is no properly configured CARP status check IP, then stop */
	if (!isset($frr_conf['carpstatusvid']) || $frr_conf['carpstatusvid'] == "none") {
		return null;
	}
	/* Locate the VIP and match it against the configured check address */
	list($vhid, $iface) = explode("@", trim($pluginparams['interface']));
	$friendly = convert_real_interface_to_friendly_interface_name($iface);
	$vip = get_configured_vip($frr_conf['carpstatusvid']);
	if ($vip['vhid'] != $vhid || $vip['interface'] != $friendly) {
		/* This is not the VIP we're looking for, move along. */
		return null;
	}
	/* Start or stop the service as needed based on the CARP transition. */
	if ($pluginparams['event'] == "rc.carpmaster") {
		start_service("FRR zebra");
	} elseif ($pluginparams['event'] == "rc.carpbackup") {
		stop_service("FRR zebra");
	}
}

/* Function to get a few items of interface information from a 'friendly'
 * interface name */
function frr_get_interfaceinfo($interface, $ipv6 = false) {
	$realif = get_real_interface($interface);
	if (empty($realif)) {
		return array();
	}
	/* Find the IP address and subnet by the real interface name/type */
	$interface_ip = ($ipv6) ? find_interface_ipv6($realif) : find_interface_ip($realif);
	$interface_subnet = ($ipv6) ? find_interface_subnetv6($realif) : find_interface_subnet($realif);
	/* Cheap hack since point-to-points won't attach if /32 is used. */
	if (!$ipv6 && ($interface_subnet == 32)) {
		$interface_subnet = 30;
	}
	$subnet = ($ipv6) ? gen_subnetv6($interface_ip, $interface_subnet) : gen_subnet($interface_ip, $interface_subnet);
	return array($interface_ip, $interface_subnet, $subnet);
}

/* Build a list of potential route destinations (gateways, interfaces) */
function frr_get_route_destinations() {
	global $config;
	$list = array();

	$list[] = array("name" => "None", "value" => "none");

	/* Add non-disabled gateways to the list */
	$gateways = return_gateways_array();
	foreach ($gateways as $gw) {
		if (!empty($gw['descr'])) {
			$gw['descr'] = " ({$gw['descr']})";
		}
		$tmp["name"] = "Gateway: {$gw['name']}{$gw['descr']}";
		$tmp["value"] = "gw|{$gw['name']}";
		$list[] = $tmp;
	}

	/* Add BGP Neighbors */
	$list = array_merge_recursive($list, frr_get_bgp_neighbor_list(false, true, false, "BGP Neighbor: ", "bgp|"));

	/* Add interfaces (including OpenVPN interfaces) */
	$list = array_merge_recursive($list, frr_get_interfaces(false, false, true, "Interface: ", "if|"));

	return $list;
}

/* Function to compare arrays that contain seq values to sort  */
function frr_array_seq_compare($a, $b) {
	if ($a['seq'] == $b['seq']) {
		return 0;
	}
	return ($a['seq'] < $b['seq']) ? -1 : 1;
}

/* Function to compare arrays that contain name and seq values to sort  */
function frr_array_name_seq_compare($a, $b) {
	if ($a['name'] == $b['name']) {
		return frr_array_seq_compare($a, $b);
	}
	return strcmp($a['name'], $b['name']);
}

/* Sort an array by its 'seq' value, only if needed. */
function frr_array_seq_sort(&$arr) {
	/* Sort by seq only if all have seq defined */
	$need_sort = false;
	foreach ($arr as $line) {
		if (is_numeric($line['seq'])) {
			$need_sort = true;
		} else {
			$need_sort = false;
		}
	}
	/* If this is true, then all entries must have had a sequence number, so they must be sorted. */
	if ($need_sort) {
		usort($arr, "frr_array_seq_compare");
	}
}

/* Convert a CIDR prefix to wildcard bits */
function frr_cidr_to_wildcard_bits($cidr) {
	return long2ip(~gen_subnet_mask_long($cidr));
}

/* Create the rc.d service control script for FRR */
function frr_generate_config_rcfile() {
	global $config, $frr_config_base;
	/* If frr is not configured, then stop */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	} else {
		return null;
	}

	/* Setup a CARP VIP status check, if needed, so the service won't start
	 * unless this node is in a MASTER state */
	$carp_ip_status_check = "";
	if (isset($frr_conf['carpstatusvid']) && $frr_conf['carpstatusvid'] != "none") {
		$vip = get_configured_vip($frr_conf['carpstatusvid']);
		$carpcheckinterface = escapeshellarg(get_real_interface($vip['interface']));
		$vhid = escapeshellarg("vhid {$vip['vhid']}");
		$carp_ip_status_check = <<<EOF

CARP_STATUS=`/sbin/ifconfig {$carpcheckinterface} | /usr/bin/grep 'carp:' | /usr/bin/grep {$vhid} | /usr/bin/awk '{print \$2;}'`
if [ \${CARP_STATUS} != "MASTER" ]; then
	exit;
fi
EOF;
	}

	/* When stopping, stop all services and remove old PID files */
	$rc_file_stop = <<<EOF
if [ -e /var/run/frr/zebra.pid ]; then
	/bin/pkill -F /var/run/frr/zebra.pid
	/bin/rm -f /var/run/frr/zebra.pid
fi
if [ -e /var/run/frr/ospfd.pid ]; then
	/bin/pkill -F /var/run/frr/ospfd.pid
	/bin/rm -f /var/run/frr/ospfd.pid
fi
if [ -e /var/run/frr/ospf6d.pid ]; then
	/bin/pkill -F /var/run/frr/ospf6d.pid
	/bin/rm -f /var/run/frr/ospf6d.pid
fi
if [ -e /var/run/frr/bgpd.pid ]; then
	/bin/pkill -F /var/run/frr/bgpd.pid
	/bin/rm -f /var/run/frr/bgpd.pid
fi
EOF;
	/* When starting, cleanup first, then fix permissions and make sure no
	 * other instances are running before starting back up. */
	$rc_file_start = <<<EOF
/bin/mkdir -p /var/run/frr
/bin/mkdir -p /var/log/frr
/bin/rm -f /var/run/frr/zebra.pid
/bin/rm -f /var/run/frr/ospfd.pid
/bin/rm -f /var/run/frr/ospf6d.pid
/bin/rm -f /var/run/frr/bgpd.pid

if [ -s {$frr_config_base}/frr_md5pw_del.conf ]; then
	/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf
fi

/usr/sbin/chown -R frr:frr {$frr_config_base}
/usr/sbin/chown -R frr:frr /var/run/frr
/usr/sbin/chown -R frr:frr /var/log/frr
# Ensure no other copies of the daemons are running or it breaks.
sleep 1
if /bin/pgrep -q zebra; then
	/usr/bin/killall zebra
	sleep 1
	/usr/bin/killall -9 zebra 2>/dev/null
fi
if /bin/pgrep -q ospfd; then
	/usr/bin/killall ospfd
	sleep 1
	/usr/bin/killall -9 ospfd 2>/dev/null
fi
if /bin/pgrep -q ospf6d; then
	/usr/bin/killall ospf6d
	sleep 1
	/usr/bin/killall -9 ospf6d 2>/dev/null
fi
if /bin/pgrep -q bgpd; then
	/usr/bin/killall bgpd
	sleep 1
	/usr/bin/killall -9 bgpd 2>/dev/null
fi
{$carp_ip_status_check}
[ -s {$frr_config_base}/zebra.conf ] && /usr/local/sbin/zebra -d -f {$frr_config_base}/zebra.conf
[ -s {$frr_config_base}/ospfd.conf ] && /usr/local/sbin/ospfd -d -f {$frr_config_base}/ospfd.conf
[ -s {$frr_config_base}/ospf6d.conf ] && /usr/local/sbin/ospf6d -d -f {$frr_config_base}/ospf6d.conf
[ -s {$frr_config_base}/bgpd.conf ] && /usr/local/sbin/bgpd -d -f {$frr_config_base}/bgpd.conf
[ -s {$frr_config_base}/frr_md5pw_add.conf ] && /sbin/setkey -f {$frr_config_base}/frr_md5pw_add.conf

EOF;

	write_rcfile(array(
			"file" => "frr.sh",
			"start" => $rc_file_start,
			"stop" =>  $rc_file_stop
		)
	);

	/* Ensure files have correct ownership and permissions */
	mwexec("/bin/chmod a+rx /usr/local/etc/rc.d/frr.sh");
	mwexec("/bin/chmod u+rw,go-rw {$frr_config_base}/ospfd.conf");
	mwexec("/bin/chmod u+rw,go-rw {$frr_config_base}/ospf6d.conf");
	mwexec("/bin/chmod u+rw,go-rw {$frr_config_base}/zebra.conf");
	mwexec("/bin/chmod u+rw,go-rw {$frr_config_base}/bgpd.conf");

	/* Start/Restart FRR, if a CARP VIP is set, check its status and act
	 * appropriately. */
	if (isset($frr_conf['carpstatusvid']) && $frr_conf['carpstatusvid'] != "none") {
		$status = get_carp_interface_status($frr_conf['carpstatusvid']);
		switch (strtoupper($status)) {
			// Stop the service if the VIP is in BACKUP or INIT state.
			case "BACKUP":
			case "INIT":
				mwexec_bg("/usr/local/etc/rc.d/frr.sh stop");
				break;
			// Start the service if the VIP is MASTER state.
			case "MASTER":
			// Assume it's up if the status can't be determined.
			default:
				mwexec_bg("/usr/local/etc/rc.d/frr.sh restart");
				break;
		}
	} else {
		mwexec_bg("/usr/local/etc/rc.d/frr.sh restart");
	}
}

/* Setup necessary setkey entries for TCP MD5 authentication. */
function frr_setkey() {
	global $config, $frr_config_base;
	$peers = array();

	/* Clear existing md5 authentication sessions and remove any md5
	 * config files if they exist. */
	if (file_exists("{$frr_config_base}/frr_md5pw_del.conf")) {
		mwexec("/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf");
		unlink_if_exists("{$frr_config_base}/frr_md5pw_del.conf");
	}
	unlink_if_exists("{$frr_config_base}/frr_md5pw_add.conf");

	/* Build md5 password configuration files based on raw tab list */
	if (is_array($config['installedpackages']['frrglobalraw']['config'][0]['row'])) {
		foreach ($config['installedpackages']['frrglobalraw']['config'][0]['row'] as $frrtcpsigpw) {
			if (($frrtcpsigpw['tcpsigsrc'] != "") && ($frrtcpsigpw['tcpsigdst'] != "") && ($frrtcpsigpw['tcpsigpw'])!= "") {
				$tmp = array();
				$tmp['src'] = $frrtcpsigpw['tcpsigsrc'];
				$tmp['dst'] = $frrtcpsigpw['tcpsigdst'];
				$tmp['pw'] = $frrtcpsigpw['tcpsigpw'];
				$tmp['bidir'] = !empty($frrtcpsigpw['tcpsigbidir']);
				$peers[] = $tmp;
			}
		}
	}

	/* Build md5 password configuration for BGP Peers */
	$neighbors = frr_get_neighbors_with_name_key();
	foreach ($neighbors as $nname => $neighbor) {
		list($pwtype_base, $pwtype_bidir) = explode('-', $neighbor['password_type'], 2);
		if ((($pwtype_base == "setkey") ||
		    ($pwtype_base == "both")) &&
		    is_ipaddr($neighbor['peer'])) {
			if (array_key_exists($neighbor['peergroup'], $neighbors)) {
				$peergroup = $neighbors[$neighbor['peergroup']];
			} else {
				$peergroup = array();
			}
			$tmp = array();
			/* determine source by update-source or by finding the interface for that destination */
			/* First, try to get the update source specified directly on this neighbor. */
			$tmp['src'] = frr_get_neighbor_updatesource($neighbor['updatesource'], $neighbor['updatesource_type']);
			/* If that fails, check if this neighbor is a member of a peer group, and if that group has one */
			if (empty($tmp['src']) && !empty($neighbor['peergroup']) &&
			    !empty($peergroup)) {
				if (!empty($peergroup['updatesource'])) {
					/* Try to determine an update source from the group */
					$tmp['src'] = frr_get_neighbor_updatesource($peergroup['updatesource'], $peergroup['updatesource_type']);
					break;
				}
			}
			/* If it is still empty, try to find it automatically based on the destination */
			if (empty($tmp['src'])) {
				if (is_ipaddrv4($neighbor['peer'])) {
					$tmp['src'] = find_interface_ip(guess_interface_from_ip($neighbor['peer']));
				} elseif (is_ipaddrv6($neighbor['peer'])) {
					$tmp['src'] = find_interface_ipv6(guess_interface_from_ip($neighbor['peer']));
				}
			}
			/* If all attempts to determine a source have failed, bail */
			if (empty($tmp['src'])) {
				continue;
			}

			/* This peer address can be used as-is */
			$tmp['dst'] = $neighbor['peer'];

			if (!empty($neighbor['password'])) {
				/* Password defined on this peer directly */
				$tmp['pw'] = $neighbor['password'];
			} elseif (!empty($peergroup['password'])) {
				/* Password from the peer group instead */
				$tmp['pw'] = $peergroup['password'];
			} else {
				/* No valid password, so skip this entry! */
				continue;
			}

			/* Use bidirectional setkey? */
			if ($pwtype_bidir == 'bidir') {
				$tmp['bidir'] = true;
			}
			$peers[] = $tmp;
		}
	}

	foreach ($peers as $peer) {
		$md5pw_add .= "add {$peer['src']} {$peer['dst']} tcp 0x1000 -A tcp-md5 \"{$peer['pw']}\";\n";
		if ($peer['bidir']) {
			$md5pw_add .= "add {$peer['dst']} {$peer['src']} tcp 0x1001 -A tcp-md5 \"{$peer['pw']}\";\n";
		}
		$md5pw_del .= "delete {$peer['src']} {$peer['dst']} tcp 0x1000 ;\n";
		if ($peer['bidir']) {
			$md5pw_del .= "delete {$peer['dst']} {$peer['src']} tcp 0x1001 ;\n";
		}
	}
	if (!empty($md5pw_add)) {
		file_put_contents("{$frr_config_base}/frr_md5pw_add.conf", $md5pw_add);
	}
	if (!empty($md5pw_del)) {
		file_put_contents("{$frr_config_base}/frr_md5pw_del.conf", $md5pw_del);
	}
}

/* Main function to generate all of the configuration files and make general
 * preparations */
function frr_generate_config() {

	/* Make sure that the FRR config directory exists and has the
	 * correct ownership info. */
	safe_mkdir(PKG_FRR_CONFIG_BASE);
	chown(PKG_FRR_CONFIG_BASE, 'frr');
	chgrp(PKG_FRR_CONFIG_BASE, 'frr');
	clearstatcache();

	/* Zebra configuration */
	frr_generate_config_zebra();

	/* BGP configuration */
	frr_generate_config_bgp();

	/* OSPF Configuration */
	frr_generate_config_ospf();

	/* OSPF6 Configuration */
	frr_generate_config_ospf6();

	/* Create the rc.d service control script */
	frr_generate_config_rcfile();

	/* Setup TCP MD5 authentication */
	frr_setkey();
}
