<?php
/*
 * frr.inc
 *
 * part of pfSense (https://www.pfsense.org)
 * Copyright (c) 2017-2021 Rubicon Communications, LLC (Netgate)
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require_once("config.inc");
require_once("functions.inc");
require_once("interfaces.inc");
require_once("service-utils.inc");
require_once("util.inc");

define('PKG_FRR_CONFIG_BASE', '/var/etc/frr');
define('PKG_FRR_LIST_NONE_VALUE', array('name' => 'None', 'value' => 'none'));

/* Since we need to embed this in strings & HERE Docs, copy to a var. Can't embed constants. */
global $frr_config_base;
$frr_config_base = PKG_FRR_CONFIG_BASE;

global $frr_modules;
$frr_modules = array('zebra', 'staticd', 'bgpd', 'ospfd', 'ospf6d', 'bfdd');

global $frr_well_known_communities;
$frr_well_known_communities = array("internet", "no-export", "no-advertise", "local-as");

global $frr_auto_config_warning;
$frr_auto_config_warning = <<<EOF
##################### DO NOT EDIT THIS FILE! ######################
###################################################################
# This file was created by an automatic configuration generator.  #
# The contents of this file will be overwritten without warning!  #
###################################################################
!

EOF;

require_once("frr/inc/frr_validation.inc");
require_once("frr/inc/frr_zebra.inc");
require_once("frr/inc/frr_bfd.inc");
require_once("frr/inc/frr_bgp.inc");
require_once("frr/inc/frr_ospf.inc");
require_once("frr/inc/frr_ospf6.inc");

/* Build a list of only CARP VIPs, formatted for use in a selection list */
function frr_get_carp_list() {
	$list = array();
	$list[] = PKG_FRR_LIST_NONE_VALUE;
	$carplist = get_configured_vip_list("all", VIP_CARP);
	foreach ($carplist as $vid => $vaddr) {
		$vip = get_configured_vip($vid);
		$list[] = array("name" => "$vaddr (vhid: {$vip['vhid']})", "value" => $vid);
	}
	return ($list);
}

/* Build a list of assigned/enabled interfaces, formatted for use in a selection
 * list, including IP Aliases, CARP VIPs, and OpenVPN interfaces. */
function frr_get_interfaces($includedefault = true, $includevips = true, $includelocalhost = false, $nameprefix = "", $valueprefix = "") {
	global $config;

	/* Only include the 'default' option when requested, some places like
	 * OSPF interface selections can't use 'default'.
	 */
	if ($includedefault) {
		$interfaces['default'] = "Default";
	} else {
		$interfaces = array();
	}
	if ($includelocalhost) {
		$interfaces['lo0'] = "Localhost (lo0)";
	}
	$interfaces = array_merge($interfaces, get_configured_interface_with_descr());
	$ifs = array();

	/* Change the interfaces array into one properly formatted for an XML GUI select_source list */
	foreach ($interfaces as $iface => $ifacename) {
		$tmp["name"] = $nameprefix . $ifacename;
		$tmp["value"] = $valueprefix . $iface;
		$ifs[] = $tmp;
	}

	/* Get a list of VIPs */
	if ($includevips) {
		$viplist = get_configured_vip_list();
		foreach ($viplist as $vip => $address) {
			$tmp["name"] = $nameprefix . $address;
			$tmp["value"] = $valueprefix . $vip.'|'.$address;
			if (get_vip_descr($address)) {
				$tmp["name"] .= " (" . get_vip_descr($address) . ")";
			}
			$ifs[] = $tmp;
		}
	}

	/* Create a list of OpenVPN server and client interfaces. */
	foreach (array('server', 'client') as $mode) {
		if (is_array($config['openvpn']["openvpn-{$mode}"])) {
			foreach ($config['openvpn']["openvpn-{$mode}"] as $id => $setting) {
				if (!isset($setting['disable'])) {
					$tmp["name"] = $nameprefix . gettext("OpenVPN") . " ".$mode.": ".htmlspecialchars($setting['description']);
					$tmp["value"] = $valueprefix . 'ovpn' . substr($mode, 0, 1) . $setting['vpnid'];
					$ifs[] = $tmp;
				}
			}
		}
	}
	return $ifs;
}

/* Simple utility function to translate a select_source list of items into a
 * list of values for easier testing by in_array() and similar cases. */
function frr_get_list_values($arr) {
	$vals = array();
	foreach ($arr as $a) {
		$vals[] = $a['value'];
	}
	return $vals;
}

/*
 * Called when a CARP VIP changes state
 * $pluginparams['event'] contains either 'rc.carpmaster' or 'rc.carpbackup'
 * $pluginparams['interface'] contains the affected VIP, id@int e.g. 19@igb1
 */
function frr_plugin_carp($pluginparams) {
	global $config;
	/* If frr is not configured, then stop */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	} else {
		return null;
	}
	/* If there is no properly configured CARP status check IP, then stop */
	if (!isset($frr_conf['carpstatusvid']) || $frr_conf['carpstatusvid'] == "none") {
		return null;
	}
	/* Locate the VIP and match it against the configured check address */
	list($vhid, $iface) = explode("@", trim($pluginparams['interface']));
	$friendly = convert_real_interface_to_friendly_interface_name($iface);
	$vip = get_configured_vip($frr_conf['carpstatusvid']);
	if ($vip['vhid'] != $vhid || $vip['interface'] != $friendly) {
		/* This is not the VIP we're looking for, move along. */
		return null;
	}
	/* Start or stop the service as needed based on the CARP transition. */
	if ($pluginparams['event'] == "rc.carpmaster") {
		start_service("FRR zebra");
	} elseif ($pluginparams['event'] == "rc.carpbackup") {
		stop_service("FRR zebra");
	}
}

/*
 * Called when IPsec reloads via rc.newipsecdns or similar. Cycles the IPsec
 * interface in FRR status so routing will work again.
 */
function frr_ipsec_reload() {
	global $config;
	init_config_arr(array('installedpackages', 'frr', 'config', 0));
	if (!empty($config['installedpackages']['frr']['config'][0]['ignoreipsecrestart']) ||
		empty($config['installedpackages']['frr']['config'][0]['enable']) || !is_process_running('zebra')) {
		return;
	}

	require_once('interfaces.inc');
	$vti_ifs = array_keys(interface_ipsec_vti_list_all());
	foreach ($vti_ifs as $vif) {
		mwexec('/usr/local/bin/frrctl cycleinterface ' . escapeshellarg($vif));
	}
}

/* Function to get a few items of interface information from a 'friendly'
 * interface name */
function frr_get_interfaceinfo($interface, $ipv6 = false) {
	$realif = get_real_interface($interface);
	if (empty($realif)) {
		return array();
	}
	/* Find the IP address and subnet by the real interface name/type */
	$interface_ip = ($ipv6) ? find_interface_ipv6($realif) : find_interface_ip($realif);
	$interface_subnet = ($ipv6) ? find_interface_subnetv6($realif) : find_interface_subnet($realif);
	/* Cheap hack since point-to-points won't attach if /32 is used. */
	if (!$ipv6 && ($interface_subnet == 32)) {
		$interface_subnet = 30;
	}
	$subnet = ($ipv6) ? gen_subnetv6($interface_ip, $interface_subnet) : gen_subnet($interface_ip, $interface_subnet);
	return array($interface_ip, $interface_subnet, $subnet);
}

/* Build a list of potential route destinations (gateways, interfaces) */
function frr_get_route_destinations() {
	global $config;
	$list = array();

	$list[] = PKG_FRR_LIST_NONE_VALUE;

	/* Add non-disabled gateways to the list */
	$gateways = return_gateways_array();
	foreach ($gateways as $gw) {
		if (!empty($gw['descr'])) {
			$gw['descr'] = " ({$gw['descr']})";
		}
		$tmp["name"] = "Gateway: {$gw['name']}{$gw['descr']}";
		$tmp["value"] = "gw|{$gw['name']}";
		$list[] = $tmp;
	}

	/* Add BGP Neighbors */
	$list = array_merge_recursive($list, frr_get_bgp_neighbor_list(false, true, false, "BGP Neighbor: ", "bgp|"));

	/* Add interfaces (including OpenVPN interfaces) */
	$list = array_merge_recursive($list, frr_get_interfaces(false, false, true, "Interface: ", "if|"));

	return $list;
}

/* Function to compare arrays that contain seq values to sort  */
function frr_array_seq_compare($a, $b) {
	if ($a['seq'] == $b['seq']) {
		return 0;
	}
	return ($a['seq'] < $b['seq']) ? -1 : 1;
}

/* Function to compare arrays that contain name and seq values to sort  */
function frr_array_name_seq_compare($a, $b) {
	if ($a['name'] == $b['name']) {
		return frr_array_seq_compare($a, $b);
	}
	return strcmp($a['name'], $b['name']);
}

/* Sort an array by its 'seq' value, only if needed. */
function frr_array_seq_sort(&$arr) {
	/* Sort by seq only if all have seq defined */
	$need_sort = false;
	foreach ($arr as $line) {
		if (is_numeric($line['seq'])) {
			$need_sort = true;
		} else {
			$need_sort = false;
		}
	}
	/* If this is true, then all entries must have had a sequence number, so they must be sorted. */
	if ($need_sort) {
		usort($arr, "frr_array_seq_compare");
	}

	return $need_sort;
}

/* Sort an array by its 'name' and 'seq' value. */
function frr_array_name_seq_sort(&$arr) {
	return usort($arr, "frr_array_name_seq_compare");
}

/* Convert a CIDR prefix to wildcard bits */
function frr_cidr_to_wildcard_bits($cidr) {
	return long2ip(~gen_subnet_mask_long($cidr));
}

/* Create the rc.d service control script for FRR */
function frr_generate_config_rcfile() {
	global $config, $frr_config_base, $frr_modules;
	/* If frr is not configured, then stop */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	} else {
		return null;
	}

	/* Config area to daemon name mapping */
	$daemons = array(
		'frr' => array('zebra', 'staticd'),
		'frrbfd' => array('bfdd'),
		'frrbgp' => array('bgpd'),
		'frrospfd' => array('ospfd'),
		'frrospf6d' => array('ospf6d')
	);

	/* Get FRR daemons enabled */
	$frrdaemons = array();
	if (!empty($config['installedpackages']['frr']['config'][0]['enable'])) {
		foreach ($daemons as $config_key => $daemon) {
			if (!empty($config['installedpackages'][$config_key]['config'][0]['enable'])) {
				$frrdaemons = array_merge($frrdaemons, $daemon);
			}
		}
	}
	$frr_daemons_string = implode(" ", $frrdaemons);

	/* Get FRR daemon modules to append to daemon commands */
	$frrmodules = array();

	/* SNMP */
	foreach ($daemons as $config_key => $daemon) {
		$frrmodules[$daemon[0]] = '';

		if ($config['installedpackages'][$config_key]['config'][0]['enablesnmpagentx']) {
			$frrmodules[$daemon[0]] .= ' -M snmp';
		}
	}
	/* BGP RPKI */
	if ($config['installedpackages']['frrbgp']['config'][0]['enablerpki']) {
		$frrmodules['bgpd'] .= ' -M rpki';
	}

	/* Build the start command for enabled daemons */
	$frr_daemons_start_cmd = "";
	foreach ($frrdaemons as $daemon) {
		$frr_daemons_start_cmd .= "	echo \"Starting {$daemon}\"\n";
		$frr_daemons_start_cmd .= "	/bin/rm -f /var/run/frr/{$daemon}.pid\n";
		$frr_daemons_start_cmd .= "	if /bin/pgrep -q {$daemon}; then\n";
		$frr_daemons_start_cmd .= "		/usr/bin/killall {$daemon}\n";
		$frr_daemons_start_cmd .= "		/usr/bin/killall -9 {$daemon} 2>/dev/null\n";
		$frr_daemons_start_cmd .= "	fi\n";
		$frr_daemons_start_cmd .= "	/usr/local/sbin/{$daemon} -d";

		if (!empty($frrmodules[$daemon])) {
			$frr_daemons_start_cmd .= $frrmodules[$daemon];
		}
		$frr_daemons_start_cmd .= "\n";
	}

	/* Check/Record the generated start command so that it can be compared to decide
	 * whether FRR requires a restart or a configuration reload */
	if (file_exists("/tmp/frr_start_command_last.txt")) {
		$frr_daemons_start_cmd_last = file_get_contents("/tmp/frr_start_command_last.txt");
	} else {
		$frr_daemons_start_cmd_last = '';
	}

	if (strcmp($frr_daemons_start_cmd, $frr_daemons_start_cmd_last) == 0) {
		$frr_restart_needed = false;
	} else {
		$frr_restart_needed = true;
	}
	file_put_contents("/tmp/frr_start_command_last.txt", $frr_daemons_start_cmd);

	/* Setup a CARP VIP status check, if needed, so the service won't start
	 * unless this node is in a MASTER state */
	$carp_ip_status_check = "";
	if (isset($frr_conf['carpstatusvid']) && $frr_conf['carpstatusvid'] != "none") {
		$vip = get_configured_vip($frr_conf['carpstatusvid']);
		$carpcheckinterface = escapeshellarg(get_real_interface($vip['interface']));
		$vhid = escapeshellarg("vhid {$vip['vhid']}");
		$carp_ip_status_check = <<<EOF

	CARP_STATUS=`/sbin/ifconfig {$carpcheckinterface} | /usr/bin/grep 'carp:' | /usr/bin/grep {$vhid} | /usr/bin/awk '{print \$2;}'`
	if [ \${CARP_STATUS} != "MASTER" ]; then
		exit;
	fi
EOF;
}

	/* When stopping, stop all services and remove old PID files */
	$rc_file_stop = <<<EOF
frr_daemons="zebra staticd ospfd ospf6d bgpd bfdd watchfrr"

	for daemon in \$frr_daemons; do
		if [ -e /var/run/frr/\$daemon.pid ]; then
		echo "Stopping \$daemon"
		/bin/pkill -F /var/run/frr/\$daemon.pid
		/bin/rm -f /var/run/frr/\$daemon.pid
		fi
	done

EOF;
	/* When starting, cleanup first, then fix permissions and make sure no
	 * other instances are running before starting back up. */
	$rc_file_start = <<<EOF
/bin/mkdir -p /var/run/frr
	/bin/mkdir -p /var/log/frr

	if [ -s {$frr_config_base}/frr_md5pw_del.conf ]; then
		/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf
	fi

	/usr/sbin/chown -R frr:frr {$frr_config_base}
	/usr/sbin/chown -R frr:frr /var/run/frr
	/usr/sbin/chown -R frr:frr /var/log/frr

	{$carp_ip_status_check}

	# Perform configuration check
	echo "Performing intergrated config test"
	/usr/local/bin/vtysh -C

	# Start Daemons
{$frr_daemons_start_cmd}
	[ -s {$frr_config_base}/frr_md5pw_add.conf ] && /sbin/setkey -f {$frr_config_base}/frr_md5pw_add.conf

	echo "Performing vtysh boot"
	/usr/local/bin/vtysh -b --config_dir /var/etc/frr

	echo "Starting watchfrr"
	/usr/local/sbin/watchfrr -d -r /usr/local/etc/rc.d/frrbBrestartbB%s -s /usr/local/etc/rc.d/frrbBstartbB%s -k /usr/local/etc/rc.d/frrbBstopbB%s -b bB -t 30 {$frr_daemons_string}

EOF;

	write_rcfile(array(
			"file" => "frr.sh",
			"start" => $rc_file_start,
			"stop" =>  $rc_file_stop
		)
	);

	/* Ensure files have correct ownership and permissions */
	chmod("/usr/local/etc/rc.d/frr.sh", 0555);
	foreach ($frr_modules as $module) {
		$moduleRunningFile = "{$frr_config_base}/{$module}.conf";
		if (file_exists($moduleRunningFile) && (filesize($moduleRunningFile) > 0)) {
			chmod($moduleRunningFile, 0600);
		}
	}

	return $frr_restart_needed;
}

function frr_service_action($restart_needed) {
	global $config, $frr_config_base, $frr_modules;
	/* If frr is not configured, then stop */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	} else {
		return null;
	}

	if ($frr_conf['enable']) {
		/* Start/Restart FRR, if a CARP VIP is set, check its status and appropriately. */
		if (isset($frr_conf['carpstatusvid']) && $frr_conf['carpstatusvid'] != "none") {
			$status = get_carp_interface_status($frr_conf['carpstatusvid']);
			switch (strtoupper($status)) {
				// Stop the service if the VIP is in BACKUP or INIT state.
				case "BACKUP":
				case "INIT":
					mwexec_bg("/usr/local/etc/rc.d/frr.sh stop");
					break;
				// Start the service if the VIP is MASTER state.
				case "MASTER":
				// Assume it's up if the status can't be determined.
				default:
					if ($restart_needed) {
						frr_package_log("FRR: Restarting services.");
						mwexec_bg("/usr/local/etc/rc.d/frr.sh restart");
					} else {
						frr_package_log("FRR: Reloading configuration.");
						mwexec_bg("/usr/local/sbin/frr-reload");
					}
					break;
			}
		} else {
			if ($restart_needed) {
				frr_package_log("FRR: Restarting services.");
				mwexec_bg("/usr/local/etc/rc.d/frr.sh restart");
			} else {
				frr_package_log("FRR: Reloading configuration.");
				mwexec_bg("/usr/local/sbin/frr-reload");
			}
		}
	} else {
		frr_package_log("FRR: Stopping services.");
		mwexec_bg("/usr/local/etc/rc.d/frr.sh stop");
	}
}

/* Setup necessary setkey entries for TCP MD5 authentication. */
function frr_setkey() {
	global $config, $frr_config_base;
	$peers = array();

	/* Clear existing md5 authentication sessions and remove any md5
	 * config files if they exist. */
	if (file_exists("{$frr_config_base}/frr_md5pw_del.conf")) {
		mwexec("/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf");
		unlink_if_exists("{$frr_config_base}/frr_md5pw_del.conf");
	}
	unlink_if_exists("{$frr_config_base}/frr_md5pw_add.conf");

	/* Build md5 password configuration files based on raw tab list */
	if (is_array($config['installedpackages']['frrglobalraw']['config'][0]['row'])) {
		foreach ($config['installedpackages']['frrglobalraw']['config'][0]['row'] as $frrtcpsigpw) {
			if (($frrtcpsigpw['tcpsigsrc'] != "") && ($frrtcpsigpw['tcpsigdst'] != "") && ($frrtcpsigpw['tcpsigpw'])!= "") {
				$tmp = array();
				$tmp['src'] = $frrtcpsigpw['tcpsigsrc'];
				$tmp['dst'] = $frrtcpsigpw['tcpsigdst'];
				$tmp['pw'] = $frrtcpsigpw['tcpsigpw'];
				$tmp['bidir'] = !empty($frrtcpsigpw['tcpsigbidir']);
				$peers[] = $tmp;
			}
		}
	}

	/* Build md5 password configuration for BGP Peers */
	$neighbors = frr_get_neighbors_with_name_key();
	foreach ($neighbors as $nname => $neighbor) {
		list($pwtype_base, $pwtype_bidir) = explode('-', $neighbor['password_type'], 2);
		if ((($pwtype_base == "setkey") ||
			($pwtype_base == "both")) &&
			is_ipaddr($neighbor['peer'])) {
			if (array_key_exists($neighbor['peergroup'], $neighbors)) {
				$peergroup = $neighbors[$neighbor['peergroup']];
			} else {
				$peergroup = array();
			}
			$tmp = array();
			/* determine source by update-source or by finding the interface for that destination */
			/* First, try to get the update source specified directly on this neighbor. */
			$tmp['src'] = frr_get_neighbor_updatesource($neighbor['updatesource'], $neighbor['updatesource_type']);
			/* If that fails, check if this neighbor is a member of a peer group, and if that group has one */
			if (empty($tmp['src']) && !empty($neighbor['peergroup']) &&
				!empty($peergroup)) {
				if (!empty($peergroup['updatesource'])) {
					/* Try to determine an update source from the group */
					$tmp['src'] = frr_get_neighbor_updatesource($peergroup['updatesource'], $peergroup['updatesource_type']);
					break;
				}
			}
			/* If it is still empty, try to find it automatically based on the destination */
			if (empty($tmp['src'])) {
				if (is_ipaddrv4($neighbor['peer'])) {
					$tmp['src'] = find_interface_ip(guess_interface_from_ip($neighbor['peer']));
				} elseif (is_ipaddrv6($neighbor['peer'])) {
					$tmp['src'] = find_interface_ipv6(guess_interface_from_ip($neighbor['peer']));
				}
			}
			/* If all attempts to determine a source have failed, bail */
			if (empty($tmp['src'])) {
				continue;
			}

			/* This peer address can be used as-is */
			$tmp['dst'] = $neighbor['peer'];

			if (!empty($neighbor['password'])) {
				/* Password defined on this peer directly */
				$tmp['pw'] = $neighbor['password'];
			} elseif (!empty($peergroup['password'])) {
				/* Password from the peer group instead */
				$tmp['pw'] = $peergroup['password'];
			} else {
				/* No valid password, so skip this entry! */
				continue;
			}

			/* Use bidirectional setkey? */
			if ($pwtype_bidir == 'bidir') {
				$tmp['bidir'] = true;
			}
			$peers[] = $tmp;
		}
	}

	foreach ($peers as $peer) {
		$md5pw_add .= "add {$peer['src']} {$peer['dst']} tcp 0x1000 -A tcp-md5 \"{$peer['pw']}\";\n";
		if ($peer['bidir']) {
			$md5pw_add .= "add {$peer['dst']} {$peer['src']} tcp 0x1001 -A tcp-md5 \"{$peer['pw']}\";\n";
		}
		$md5pw_del .= "delete {$peer['src']} {$peer['dst']} tcp 0x1000 ;\n";
		if ($peer['bidir']) {
			$md5pw_del .= "delete {$peer['dst']} {$peer['src']} tcp 0x1001 ;\n";
		}
	}
	if (!empty($md5pw_add)) {
		file_put_contents("{$frr_config_base}/frr_md5pw_add.conf", $md5pw_add);
	}
	if (!empty($md5pw_del)) {
		file_put_contents("{$frr_config_base}/frr_md5pw_del.conf", $md5pw_del);
	}
}

/* Write a message to the syslog conditionally on package log level setting*/
function frr_package_log($string, $priority = LOG_INFO) {
	global $config;

	/* Populate FRR Global Settings */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	}

	/* Check if extended package logging is enabled */
	if (is_null($frr_conf['pkgloglevel']) || ($frr_conf['pkgloglevel'] < 1)) {
		// Extended logging is disabled
		return;
	}

	syslog($priority, "FRR Package: {$string}");
}

/* Main function to generate all of the configuration files and make general
 * preparations */
function frr_generate_config() {
	/* Create integrated configuration global */
	global $frr_integrated_config;
	$frr_integrated_config = array();
	$frr_integrated_config['interfaces'] = array();

	/* Make sure that the FRR config directory exists and has the
	 * correct ownership info. */
	safe_mkdir(PKG_FRR_CONFIG_BASE);
	chown(PKG_FRR_CONFIG_BASE, 'frr');
	chgrp(PKG_FRR_CONFIG_BASE, 'frr');
	clearstatcache();

	/* vtysh configuration */
	frr_generate_config_vtysh();

	/* Zebra configuration */
	frr_generate_config_zebra();

	/* BGP configuration */
	frr_generate_config_bgp();

	/* OSPF Configuration */
	frr_generate_config_ospf();

	/* OSPF6 Configuration */
	frr_generate_config_ospf6();

	/* BFD Configuration */
	frr_generate_config_bfd();

	/* Setup TCP MD5 authentication */
	frr_setkey();

	/* Integrated configuration */
	frr_generate_config_integrated();

	/* Create the rc.d service control script and trigger restart/reload */
	if (!empty($_POST['service_force_restart'])) {
		frr_package_log("FRR: Service restart forced.");
		/* If force_restart is set, delete the previously generated start command file to force a service restart */
		unlink_if_exists("/tmp/frr_start_command_last.txt");
	}
	$restart_needed = frr_generate_config_rcfile();
	frr_service_action($restart_needed);
}

function frr_generate_config_vtysh() {
	global $config, $frr_config_base, $frr_auto_config_warning;

	unlink_if_exists("{$frr_config_base}/vtysh.conf");

	/* Populate FRR Global Settings */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	}

	/* If there is no raw configuration and no GUI configuration, stop. */
	if (empty($frr_conf)) {
		frr_package_log("FRR vtysh: No config data found.");
		return;
	}
	if (empty($frr_conf['enable'])) {
		frr_package_log("FRR vtysh: FRR master switch is off.");
		return;
	}

	$vtyshconffile = $frr_auto_config_warning;
	$vtyshconffile .= "service integrated-vtysh-config\n\n";
	file_put_contents("{$frr_config_base}/vtysh.conf", $vtyshconffile);
	chown("{$frr_config_base}/vtysh.conf", 'frr');
	chgrp("{$frr_config_base}/vtysh.conf", 'frr');
}

function frr_flatten_config_interfaces() {
	global $frr_integrated_config;

	$interfaces_config = "";
	foreach (array_keys($frr_integrated_config['interfaces']) as $interface) {
		$interfaces_config .= "interface {$interface}\n";

		foreach(array('ospfd', 'ospf6d') as $service) {
			if (empty($frr_integrated_config['interfaces_descr'][$interface][$service])) {
				continue;
			}
			if (!isset($interface_description)) {
				$interface_description = "";
			} else {
				$interface_description .= " - ";
			}
			$interface_description .= "{$service}: {$frr_integrated_config['interfaces_descr'][$interface][$service]}";
		}
		unset($service);

		if (!empty($interface_description)) {
			$interfaces_config .= " description \"{$interface_description}\"\n";
		}

		$interfaces_config .= $frr_integrated_config['interfaces'][$interface];
	}
	unset($interface);

	$frr_integrated_config['interfaces'] = $interfaces_config;
}

function frr_generate_config_integrated() {
	global $config, $frr_config_base, $frr_auto_config_warning, $frr_integrated_config;

	unlink_if_exists("{$frr_config_base}/frr.conf");

	/* Populate FRR Global Settings */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	}

	/* If there is no raw configuration and no GUI configuration, stop. */
	if (empty($frr_conf)) {
		frr_package_log("FRR Integrated: No config data found.");
		return;
	}
	if (empty($frr_conf['enable'])) {
		frr_package_log("FRR Integrated: FRR master switch is off.");
		return;
	}

	frr_package_log("FRR Integrated: Rebuild configuration.");

	$integratedconffile = $frr_auto_config_warning;
	$integratedconffile .= "frr defaults traditional\n";
	$integratedconffile .= "hostname " . $config['system']['hostname'] . "." . $config['system']['domain'] . "\n";

	/* Management Password */
	if ($frr_conf['password']) {
		$integratedconffile .= "password {$frr_conf['password']}\n";
	}
	/* Logging Options */
	if ($frr_conf['logging']) {
		$integratedconffile .= "log syslog\n";
	}
	/* SNMP AgentX Support*/
	if ($frr_conf['enablesnmpagentx']) {
		$integratedconffile .= "agentx\n";
	}

	/* FRR Services */
	$integratedconffile .= "service integrated-vtysh-config\n";
	if ($frr_conf['passwordencrypt']) {
		$integratedconffile .= "service password-encryption\n";
	}
	$integratedconffile .= "!\n";

	if (!empty($frr_conf['routerid'])) {
		if (is_ipaddrv4($frr_conf['routerid'])) {
			$integratedconffile .= "ip ";
		} elseif (is_ipaddrv6($frr_conf['routerid'])) {
			$integratedconffile .= "ipv6 ";
		}
		$integratedconffile .= "router-id {$frr_conf['routerid']}\n";
		$integratedconffile .= "!\n";
	}

	frr_flatten_config_interfaces();
	$conf_keys = array('staticd', 'interfaces', 'bgpd', 'rpki', 'ospfd', 'ospf6d', 'zebra', 'bfdd');
	foreach ($conf_keys as $key) {
		if (empty($frr_integrated_config[$key])) {
			continue;
		}
		$integratedconffile .= $frr_integrated_config[$key];
		$integratedconffile .= "!\n";
	}

	$integratedconffile .= "line vty\n";
	$integratedconffile .= "!\n";
	$integratedconffile .= "end\n";

	/* Remove sample configuration files */
	array_map('unlink', glob("{$frr_config_base}/*.sample*"));

	file_put_contents("{$frr_config_base}/frr.conf", $integratedconffile, LOCK_EX);
	chown("{$frr_config_base}/frr.conf", 'frr');
	chgrp("{$frr_config_base}/frr.conf", 'frr');
}

/* Upgrade the FRR configuration to the latest format */
function frr_config_sort_route_map() {
	global $config;

	update_status("Sorting route-map configuration items");

	init_config_arr(array('installedpackages', 'frrglobalroutemaps', 'config'));
	$frr_routemap_conf = &$config['installedpackages']['frrglobalroutemaps']['config'];

	$need_write = frr_array_name_seq_sort($frr_routemap_conf);

	if ($need_write) {
		update_status("Saving sorted route-map configuration items");
		write_config('FRR: Sorted route-map configuration items');
		update_status("Done.\n");
	}
}

/* Upgrade the FRR configuration to the latest format */
function frr_package_config_upgrade() {
	global $config;
	update_status("Upgrading FRR Settings ... ");
	$need_write = false;
	/* Populate FRR Global Settings */
	if (is_array($config['installedpackages']['frr']['config'])) {
		$frr_conf = &$config['installedpackages']['frr']['config'][0];
	} else {
		/* If FRR is not configured, stop. */
		return null;
	}

	/* Populate FRR OSPF Settings */
	init_config_arr(array('installedpackages', 'frrospfd', 'config', '0'));
	$ospfd_conf = &$config['installedpackages']['frrospfd']['config'][0];
	init_config_arr(array('installedpackages', 'frrospf6d', 'config', '0'));
	$ospf6d_conf = &$config['installedpackages']['frrospf6d']['config'][0];
	init_config_arr(array('installedpackages', 'frrglobalacls', 'config'));
	$frr_acls_conf = &$config['installedpackages']['frrglobalacls']['config'];
	init_config_arr(array('installedpackages', 'frrglobalprefixes', 'config'));
	$frr_prefixes_conf = &$config['installedpackages']['frrglobalprefixes']['config'];
	init_config_arr(array('installedpackages', 'frrglobalroutemaps', 'config'));
	$frr_routemap_conf = &$config['installedpackages']['frrglobalroutemaps']['config'];
	init_config_arr(array('installedpackages', 'frrospfdinterfaces', 'config'));
	$frr_ospfinterfaces_conf = &$config['installedpackages']['frrospfdinterfaces']['config'];
	init_config_arr(array('installedpackages', 'frrospfdareas', 'config'));
	$frr_areas_conf = &$config['installedpackages']['frrospfdareas']['config'];
	init_config_arr(array('installedpackages', 'frrbgp', 'config', '0'));
	$bgp_conf = &$config['installedpackages']['frrbgp']['config'][0];

	/* Iterate old network list looking for items marked to not redistribute */
	$dnrlist = array();
	if (is_array($ospfd_conf['row'])) {
		foreach ($ospfd_conf['row'] as $idx => &$redistr) {
			if (empty($redistr['routevalue']) ||
				($redistr['redistribute']) != 'ON') {
				continue;
			}
			$dnrlist[] = $redistr['routevalue'];
			unset($ospfd_conf['row'][$idx]);
			$need_write = true;
		}
	}

	/* Only import these items if there are values to process.
	 * If there are none, it means we have already imported or there was
	 * nothing to import, thus the changes are not needed. */
	if (!empty($dnrlist)) {
		/* Create a new access-list called dnr-list
		 * Add entries for old "do not redistribute" networks */
		$dnracl = array(
			'name' => 'dnr-list',
			'descr' => 'Do Not Redistribute (imported)',
		);
		$seq = 10;
		$dnracl['row'] = array();
		foreach ($dnrlist as $dnr) {
			$dnracl['row'][] = array(
				'seq' => $seq,
				'action' => 'deny',
				'source' => $dnr
			);
			$seq += 10;
		}
		$dnracl['row'][] = array(
			'seq' => $seq,
			'action' => 'permit',
			'source' => 'any'
		);
		$frr_acls_conf[] = $dnracl;

		/* Create a new Route Map named DNR using the dnr-list */
		$frr_routemap_conf[] = array(
			'name' => 'DNR',
			'descr' => 'Do Not Redistribute List',
			'action' => 'permit',
			'seq' => '10',
			'acl_match' => 'dnr-list',
		);

		/* Create new Area entry for default area with its export list set to dnr-list */
		$frr_areas_conf[] = array(
			'area' => $ospfd_conf['area'],
			'descr' => 'Default Area (imported)',
			'type' => $ospfd_conf['updatefib'],
			'exportlist' => 'dnr-list',
		);

		/* Set redist route-maps to DNR and distribute lists to dnr-list */
		if ($ospfd_conf['redistributeconnectedsubnets']) {
			$ospfd_conf['redistributeconnectedsubnets_routemap'] = "DNR";
			$ospfd_conf['redistributeconnectedsubnets_distlist'] = "dnr-list";
		}
		if ($ospfd_conf['redistributekernel']) {
			$ospfd_conf['redistributekernel_routemap'] = "DNR";
			$ospfd_conf['redistributekernel_distlist'] = "dnr-list";
		}
		if ($ospfd_conf['redistributebgp']) {
			$ospfd_conf['redistributebgp_routemap'] = "DNR";
			$ospfd_conf['redistributebgp_distlist'] = "dnr-list";
		}
		if ($ospfd_conf['redistributestatic']) {
			$ospfd_conf['redistributestatic_routemap'] = "DNR";
			$ospfd_conf['redistributestatic_distlist'] = "dnr-list";
		}
		if ($ospfd_conf['redistributedefaultroute']) {
			$ospfd_conf['redistributedefaultroute_routemap'] = "DNR";
		}
	}

	/* interface auth to new select style */
	foreach ($frr_ospfinterfaces_conf as &$conf) {
		$realif = get_real_interface($conf['interface']);
		if (empty($realif) ||
			empty($conf['password']) ||
			isset($conf['authtype'])) {
			continue;
		}
		if ($conf['md5password']) {
			$conf['authtype'] = "digest";
			unset($conf['md5password']);
		} else {
			$conf['authtype'] = "simple";
		}
		$need_write = true;
	}

	/* updatefib -> areatype */
	if (isset($ospfd_conf['updatefib'])) {
		$ospfd_conf['areatype'] = $ospfd_conf['updatefib'];
		unset($ospfd_conf['updatefib']);
		$need_write = true;
	}

	/* area->defaultarea */
	if ((strlen($ospfd_conf['defaultarea']) == 0) && !empty($ospfd_conf['area'])) {
		$ospfd_conf['defaultarea'] = $ospfd_conf['area'];
		unset($ospfd_conf['area']);
		$need_write = true;
	}
	if ((strlen($ospf6d_conf['defaultarea']) == 0) && !empty($ospf6d_conf['area'])) {
		$ospf6d_conf['defaultarea'] = $ospf6d_conf['area'];
		unset($ospf6d_conf['area']);
		$need_write = true;
	}
	/* areatype->defaultareatype */
	if ((strlen($ospfd_conf['defaultareatype']) == 0) && !empty($ospfd_conf['areatype'])) {
		$ospfd_conf['defaultareatype'] = $ospfd_conf['areatype'];
		unset($ospfd_conf['areatype']);
		$need_write = true;
	}

	/* BGP distribution migrate */
	if ((strlen($bgp_conf['redistributeconnected']) == 0) && !empty($bgp_conf['redistributeconnectedsubnets'])) {
		$bgp_conf['redistributeconnected'] = $bgp_conf['redistributeconnectedsubnets'];
		unset($bgp_conf['redistributeconnectedsubnets']);
		$need_write = true;
	}
	if (($bgp_conf['redistributeospf'] == 'yes') && empty($bgp_conf['redistributeospf6'])) {
		$bgp_conf['redistributeospf6'] = 'yes';
		$need_write = true;
	}

	/* ACL and Prefix List add IP Type*/
	foreach ($frr_acls_conf as $aclconf) {
		if (empty($aclconf['iptype']) && !empty($aclconf['row'])) {
			if (is_subnetv4($aclconf['row'][0]['source'])) {
				$aclconf['iptype'] = 'IPv4';
			} else {
				$aclconf['iptype'] = 'IPv6';
			}
			$need_write = true;
		}
	}
	foreach ($frr_prefixes_conf as $prefixconf) {
		if (empty($prefixconf['iptype']) && !empty($prefixconf['row'])) {
			if (is_subnetv4($aclconf['row'][0]['source'])) {
				$aclconf['iptype'] = 'IPv4';
			} else {
				$aclconf['iptype'] = 'IPv6';
			}
			$need_write = true;
		}
	}
	update_status("Done.\n");

	/* Save Changes */
	if ($need_write) {
		update_status("Saving changes ... ");
		write_config('FRR: Upgraded Settings.');
		update_status("Done.\n");
	} else {
		update_status("Nothing to do.\n");
	}
}

function frr_set_tunables() {
	global $config;

	init_config_arr(array('sysctl', 'item'));
	$sysctl_conf = &$config['sysctl']['item'];
	$sysctl_maxsockbuff = array('tunable' => 'kern.ipc.maxsockbuf', 'value' => 16777216, 'descr' => "Maximum socket buffer size - set by FRR package");

	if (!in_array($sysctl_maxsockbuff, $sysctl_conf)) {
		update_status("Installing maxsockbuf tunable ... ");
		$sysctl_conf[] = $sysctl_maxsockbuff;
		write_config('FRR: Installed maxsockbuf tunable.');
		system_setup_sysctl();
		update_status("Done.\n");
	}
}

/* Install-time functions */
function frr_package_install() {
	/* Upgrade the configuration */
	frr_package_config_upgrade();

	/* Set tunable kern.ipc.maxsockbuf to FRR recommended */
	/* OSPF and OSPF6 most likely won't work without this */
	frr_set_tunables();
}
