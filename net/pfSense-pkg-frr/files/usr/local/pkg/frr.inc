<?php
/*
 * frr.inc
 *
 * part of pfSense (https://www.pfsense.org)
 * Copyright (c) 2017-2025 Rubicon Communications, LLC (Netgate)
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require_once("config.inc");
require_once("functions.inc");
require_once("interfaces.inc");
require_once("service-utils.inc");
require_once("util.inc");

define('PKG_FRR_CONFIG_BASE', '/var/etc/frr');
define('PKG_FRR_LIST_NONE_VALUE', array('name' => 'None', 'value' => 'none'));
define('LOG_PREFIX_PKG_FRR', 'FRR');

/* Since we need to embed this in strings & HERE Docs, copy to a var. Can't embed constants. */
global $frr_config_base;
$frr_config_base = PKG_FRR_CONFIG_BASE;

global $frr_daemons;
$frr_daemons = array('zebra', 'mgmtd', 'staticd', 'bgpd', 'ospfd', 'ospf6d', 'ripd', 'bfdd');

global $frr_well_known_communities;
$frr_well_known_communities = array("internet", "no-export", "no-advertise", "local-as");

global $frr_auto_config_warning;
$frr_auto_config_warning = <<<EOF
##################### DO NOT EDIT THIS FILE! ######################
###################################################################
# This file was created by an automatic configuration generator.  #
# The contents of this file will be overwritten without warning!  #
###################################################################
!

EOF;

require_once("frr/inc/frr_validation.inc");
require_once("frr/inc/frr_zebra.inc");
require_once("frr/inc/frr_bfd.inc");
require_once("frr/inc/frr_bgp.inc");
require_once("frr/inc/frr_ospf.inc");
require_once("frr/inc/frr_ospf6.inc");
require_once("frr/inc/frr_rip.inc");

/* Build a list of only CARP VIPs, formatted for use in a selection list */
function frr_get_carp_list() {
	$list = array();
	$list[] = PKG_FRR_LIST_NONE_VALUE;
	$carplist = get_configured_vip_list("all", VIP_CARP);
	foreach ($carplist as $vid => $vaddr) {
		$vip = get_configured_vip($vid);
		$list[] = array("name" => "$vaddr (vhid: {$vip['vhid']})", "value" => $vid);
	}
	return ($list);
}

/* Build a list of assigned/enabled interfaces, formatted for use in a selection
 * list, including IP Aliases, CARP VIPs, and OpenVPN interfaces. */
function frr_get_interfaces($includedefault = true, $includevips = true, $includelocalhost = false, $nameprefix = "", $valueprefix = "") {
	/* Only include the 'default' option when requested, some places like
	 * OSPF interface selections can't use 'default'.
	 */
	if ($includedefault) {
		$interfaces['default'] = "Default";
	} else {
		$interfaces = array();
	}
	if ($includelocalhost) {
		$interfaces['lo0'] = "Localhost (lo0)";
	}
	$interfaces = array_merge($interfaces, get_configured_interface_with_descr());
	$ifs = array();

	/* Change the interfaces array into one properly formatted for an XML GUI select_source list */
	foreach ($interfaces as $iface => $ifacename) {
		$tmp["name"] = $nameprefix . $ifacename;
		$tmp["value"] = $valueprefix . $iface;
		$ifs[] = $tmp;
	}

	/* Get a list of VIPs */
	if ($includevips) {
		$viplist = get_configured_vip_list();
		foreach ($viplist as $vip => $address) {
			$tmp["name"] = $nameprefix . $address;
			$tmp["value"] = $valueprefix . $vip.'|'.$address;
			if (get_vip_descr($address)) {
				$tmp["name"] .= " (" . get_vip_descr($address) . ")";
			}
			$ifs[] = $tmp;
		}
	}

	/* Create a list of OpenVPN server and client interfaces. */
	foreach (["server", "client"] as $mode) {
		foreach (config_get_path("openvpn/openvpn-{$mode}", []) as $setting) {
			if (!isset($setting['disable'])) {
				$tmp["name"] = $nameprefix . gettext("OpenVPN") . " ".$mode.": ".htmlspecialchars($setting['description']);
				$tmp["value"] = $valueprefix . 'ovpn' . substr($mode, 0, 1) . $setting['vpnid'];
				$ifs[] = $tmp;
			}
		}
	}
	return $ifs;
}

/* Simple utility function to translate a select_source list of items into a
 * list of values for easier testing by in_array() and similar cases. */
function frr_get_list_values($arr) {
	$vals = array();
	foreach ($arr as $a) {
		$vals[] = $a['value'];
	}
	return $vals;
}

/*
 * Called when a CARP VIP changes state
 * $pluginparams['event'] contains either 'rc.carpmaster' or 'rc.carpbackup'
 * $pluginparams['interface'] contains the affected VIP, id@int e.g. 19@igb1
 */
function frr_plugin_carp($pluginparams) {
	/* If frr is not configured, then stop */
	$frr_conf = config_get_path('installedpackages/frr/config/0', []);
	if (empty($frr_conf)) {
		return null;
	}

	/* If there is no properly configured CARP status check IP, then stop */
	if (!array_key_exists('carpstatusvid', $frr_conf) ||
	    $frr_conf['carpstatusvid'] == "none") {
		return null;
	}
	/* Locate the VIP and match it against the configured check address */
	list($vhid, $iface) = explode("@", trim($pluginparams['interface']));
	$friendly = convert_real_interface_to_friendly_interface_name($iface);
	$vip = get_configured_vip($frr_conf['carpstatusvid']);
	if ($vip['vhid'] != $vhid || $vip['interface'] != $friendly) {
		/* This is not the VIP we're looking for, move along. */
		return null;
	}
	/* Start or stop the service as needed based on the CARP transition. */
	if ($pluginparams['event'] == "rc.carpmaster") {
		start_service("FRR zebra");
	} elseif ($pluginparams['event'] == "rc.carpbackup") {
		stop_service("FRR zebra");
	}
}

/*
 * Called when gathering status output.
 * See https://redmine.pfsense.org/issues/14777 and
 *     https://redmine.pfsense.org/issues/14588
 */

function frr_plugin_statusoutput($pluginparams) {
	require_once('status_output.inc');
	$entry_prefix = 'Package-FRR-';
	$control_script = "/usr/local/bin/frrctl";
	$frr_enabled    = ((config_get_path('installedpackages/frr/config/0/enable') == 'on')       || !empty(config_get_path('installedpackages/frrglobalraw/config/0/zebra')));
	$bgpd_enabled   = ((config_get_path('installedpackages/frrbgp/config/0/enable') == 'on')    || !empty(config_get_path('installedpackages/frrglobalraw/config/0/bgpd')));
	$ospfd_enabled  = ((config_get_path('installedpackages/frrospfd/config/0/enable') == 'on')  || !empty(config_get_path('installedpackages/frrglobalraw/config/0/ospfd')));
	$ospf6d_enabled = ((config_get_path('installedpackages/frrospf6d/config/0/enable') == 'on') || !empty(config_get_path('installedpackages/frrglobalraw/config/0/ospf6d')));
	$ripd_enabled   = ((config_get_path('installedpackages/frrripd/config/0/enable') == 'on')   || !empty(config_get_path('installedpackages/frrglobalraw/config/0/ripd')));
	$bfdd_enabled   = ((config_get_path('installedpackages/frrbfd/config/0/enable') == 'on')    || !empty(config_get_path('installedpackages/frrglobalraw/config/0/bfdd')));

	if (is_readable('/var/etc/frr/frr.conf')) {
		status_cmd_define("{$entry_prefix}Config-FRR", "cat /var/etc/frr/frr.conf");
	}
	if (is_readable('/var/etc/frr/vtysh.conf')) {
		status_cmd_define("{$entry_prefix}Config-vtysh", "cat /var/etc/frr/vtysh.conf");
	}
	if ($frr_enabled) {
		status_cmd_define("{$entry_prefix}Config-running", "/usr/local/bin/vtysh -c 'show run'");
	} else {
		/* FRR is disabled, remaining commands would fail */
		return;
	}

	status_cmd_define("{$entry_prefix}Zebra Routes", "{$control_script} zebra route");
	status_cmd_define("{$entry_prefix}Zebra IPv6 Routes", "{$control_script} zebra route6");
	status_cmd_define("{$entry_prefix}Zebra CPU", "{$control_script} zebra cpu");
	status_cmd_define("{$entry_prefix}Zebra Interfaces", "{$control_script} zebra int");
	status_cmd_define("{$entry_prefix}Zebra Memory", "{$control_script} zebra mem");

	if ($bgpd_enabled) {
		status_cmd_define("{$entry_prefix}BGP Routes", "{$control_script} bgp route");
		status_cmd_define("{$entry_prefix}BGP IPv6 Routes", "{$control_script} bgp6 route");
		status_cmd_define("{$entry_prefix}BGP Summary", "{$control_script} bgp sum");
		status_cmd_define("{$entry_prefix}BGP Neighbors", "{$control_script} bgp neighbor");
		status_cmd_define("{$entry_prefix}BGP Peer Groups", "{$control_script} bgp peer");
		status_cmd_define("{$entry_prefix}BGP Next Hops", "{$control_script} bgp nexthop");
		status_cmd_define("{$entry_prefix}BGP Memory", "{$control_script} bgp mem");
	}
	if ($ospfd_enabled) {
		status_cmd_define("{$entry_prefix}OSPF General", "{$control_script} ospf general");
		status_cmd_define("{$entry_prefix}OSPF Neighbors", "{$control_script} ospf neighbor");
		status_cmd_define("{$entry_prefix}OSPF Routes", "{$control_script} ospf route");
		status_cmd_define("{$entry_prefix}OSPF Database", "{$control_script} ospf database");
		status_cmd_define("{$entry_prefix}OSPF Router Database", "{$control_script} ospf database router");
		status_cmd_define("{$entry_prefix}OSPF Interfaces", "{$control_script} ospf interfaces");
		status_cmd_define("{$entry_prefix}OSPF CPU Usage", "{$control_script} ospf cpu");
		status_cmd_define("{$entry_prefix}OSPF Memory", "{$control_script} ospf mem");
	}
	if ($ospf6d_enabled) {
		status_cmd_define("{$entry_prefix}OSPF6 General", "{$control_script} ospf6 general");
		status_cmd_define("{$entry_prefix}OSPF6 Neighbors", "{$control_script} ospf6 neighbor");
		status_cmd_define("{$entry_prefix}OSPF6 Routes", "{$control_script} ospf6 route");
		status_cmd_define("{$entry_prefix}OSPF6 Database", "{$control_script} ospf6 database");
		status_cmd_define("{$entry_prefix}OSPF6 Router Database", "{$control_script} ospf6 database router");
		status_cmd_define("{$entry_prefix}OSPF6 Interfaces", "{$control_script} ospf6 interfaces");
		status_cmd_define("{$entry_prefix}OSPF6 CPU Usage", "{$control_script} ospf6 cpu");
		status_cmd_define("{$entry_prefix}OSPF6 Memory", "{$control_script} ospf6 mem");
	}
	if ($ripd_enabled) {
		status_cmd_define("{$entry_prefix}RIP General", "{$control_script} rip general");
		status_cmd_define("{$entry_prefix}RIP Routes", "{$control_script} rip routes");
		status_cmd_define("{$entry_prefix}RIP General", "{$control_script} rip general");
		status_cmd_define("{$entry_prefix}RIP Routes", "{$control_script} rip routes");
	}
	if ($bfdd_enabled) {
		status_cmd_define("{$entry_prefix}BFD Peers Brief", "{$control_script} bfd peer_br");
		status_cmd_define("{$entry_prefix}BFD Peers", "{$control_script} bfd peer");
		status_cmd_define("{$entry_prefix}BFD Peers Counters", "{$control_script} bfd counters");
	}
}

/*
 * Called when IPsec reloads via rc.newipsecdns or similar. Cycles the IPsec
 * interface in FRR status so routing will work again.
 */
function frr_ipsec_reload() {
	if (!empty(config_get_path('installedpackages/frr/config/0/ignoreipsecrestart')) ||
		empty(config_get_path('installedpackages/frr/config/0/enable')) || !is_process_running('zebra')) {
		return null;
	}

	require_once('interfaces.inc');
	$vti_ifs = array_keys(interface_ipsec_vti_list_all());
	foreach ($vti_ifs as $vif) {
		mwexec('/usr/local/bin/frrctl cycleinterface ' . escapeshellarg($vif));
	}
}

/* Function to get a few items of interface information from a 'friendly'
 * interface name */
function frr_get_interfaceinfo($interface, $ipv6 = false) {
	$realif = get_real_interface($interface);
	if (empty($realif)) {
		return array();
	}
	/* Find the IP address and subnet by the real interface name/type */
	$interface_ip = ($ipv6) ? find_interface_ipv6($realif) : find_interface_ip($realif);
	$interface_subnet = ($ipv6) ? find_interface_subnetv6($realif) : find_interface_subnet($realif);
	/* Cheap hack since point-to-points won't attach if /32 is used. */
	if (!$ipv6 && ($interface_subnet == 32)) {
		$interface_subnet = 30;
	}
	$subnet = ($ipv6) ? gen_subnetv6($interface_ip, $interface_subnet) : gen_subnet($interface_ip, $interface_subnet);
	return array($interface_ip, $interface_subnet, $subnet);
}

/* Build a list of potential route destinations (gateways, interfaces) */
function frr_get_route_destinations() {
	$list = array();

	$list[] = PKG_FRR_LIST_NONE_VALUE;

	/* Add non-disabled gateways to the list */
	$gateways = return_gateways_array();
	foreach ($gateways as $gw) {
		if (!empty($gw['descr'])) {
			$gw['descr'] = " ({$gw['descr']})";
		}
		$tmp["name"] = "Gateway: {$gw['name']}{$gw['descr']}";
		$tmp["value"] = "gw|{$gw['name']}";
		$list[] = $tmp;
	}

	/* Add BGP Neighbors */
	$list = array_merge_recursive($list, frr_get_bgp_neighbor_list(false, true, false, "BGP Neighbor: ", "bgp|"));

	/* Add interfaces (including OpenVPN interfaces) */
	$list = array_merge_recursive($list, frr_get_interfaces(false, false, true, "Interface: ", "if|"));

	return $list;
}

/* Function to compare arrays that contain seq values to sort  */
function frr_array_seq_compare($a, $b) {
	if ($a['seq'] == $b['seq']) {
		return 0;
	}
	return ($a['seq'] < $b['seq']) ? -1 : 1;
}

/* Function to compare arrays that contain name and seq values to sort  */
function frr_array_name_seq_compare($a, $b) {
	if ($a['name'] == $b['name']) {
		return frr_array_seq_compare($a, $b);
	}
	return strcmp($a['name'], $b['name']);
}

/* Sort an array by its 'seq' value, only if needed. */
function frr_array_seq_sort(&$arr) {
	/* Sort by seq only if all have seq defined */
	$need_sort = false;
	foreach ($arr as $line) {
		if (is_numeric($line['seq'])) {
			$need_sort = true;
		} else {
			$need_sort = false;
		}
	}
	/* If this is true, then all entries must have had a sequence number, so they must be sorted. */
	if ($need_sort) {
		usort($arr, "frr_array_seq_compare");
	}

	return $need_sort;
}

/* Sort an array by its 'name' and 'seq' value. */
function frr_array_name_seq_sort(&$arr) {
	return usort($arr, "frr_array_name_seq_compare");
}

/* Convert a CIDR prefix to wildcard bits */
function frr_cidr_to_wildcard_bits($cidr) {
	return long2ip(~gen_subnet_mask_long($cidr));
}

/* Create the rc.d service control script for FRR */
function frr_generate_config_rcfile() {
	global $frr_config_base, $frr_daemons;
	/* If frr is not configured, then stop */
	$frr_conf = config_get_path('installedpackages/frr/config/0', []);
	if (empty($frr_conf)) {
		return null;
	}

	/* Config area to daemon name mapping */
	$config_key_daemons = array(
		'frr' => array('zebra', 'mgmtd', 'staticd'),
		'frrbfd' => array('bfdd'),
		'frrbgp' => array('bgpd'),
		'frrospfd' => array('ospfd'),
		'frrospf6d' => array('ospf6d'),
		'frrripd' => array('ripd')
	);

	/* Get FRR daemons enabled */
	$frr_daemons_enabled = array();
	if (!empty(config_get_path('installedpackages/frr/config/0/enable'))) {
		foreach ($config_key_daemons as $config_key => $daemon) {
			if (!empty(config_get_path("installedpackages/{$config_key}/config/0/enable"))) {
				$frr_daemons_enabled = array_merge($frr_daemons_enabled, $daemon);
			}
		}
	}
	$frr_daemons_string = implode(" ", $frr_daemons_enabled);

	/* Get FRR daemon modules to append to daemon commands */
	$frr_daemon_modules = array();

	/* SNMP */
	foreach ($config_key_daemons as $config_key => $daemon) {
		$frr_daemon_modules[$daemon[0]] = '';
		if (config_get_path("installedpackages/{$config_key}/config/0/enablesnmpagentx")) {
			$frr_daemon_modules[$daemon[0]] .= ' -M snmp';
		}
	}
	/* BGP RPKI */
	if (config_get_path("installedpackages/frrbgp/config/0/enablerpki") == "on") {
		$frr_daemon_modules['bgpd'] .= ' -M rpki';
	}

	/* Setup a CARP VIP status check, if needed, so the service won't start
	 * unless this node is in a MASTER state */
	$carp_ip_status_check = "";
	if (isset($frr_conf['carpstatusvid']) && $frr_conf['carpstatusvid'] != "none") {
		$vip = get_configured_vip($frr_conf['carpstatusvid']);
		$carpcheckinterface = escapeshellarg(get_real_interface($vip['interface']));
		$vhid = escapeshellarg("vhid {$vip['vhid']}");
		$carp_ip_status_check = <<<EOF

	CARP_STATUS=`/sbin/ifconfig {$carpcheckinterface} | /usr/bin/grep 'carp:' | /usr/bin/grep {$vhid} | /usr/bin/awk '{print \$2;}'`
	if [ \${CARP_STATUS} != "MASTER" ]; then
		exit;
	fi

EOF;
}

	/* When stopping, stop all services and remove old PID files */
	$rc_file_stop = <<<EOF
echo "Stopping FRR"
	/usr/local/etc/rc.d/frr stop

	if [ -s {$frr_config_base}/frr_md5pw_del.conf ]; then
		/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf
	fi

	if [ -e /var/run/frr/\watchfrr.pid ]; then
	echo "Stopping watchfrr"
	/bin/pkill -F /var/run/frr/watchfrr.pid
	/bin/rm -f /var/run/frr/watchfrr.pid
	fi
EOF;
	/* When starting, cleanup first, then fix permissions and make sure no
	 * other instances are running before starting back up. */
	$rc_file_start = <<<EOF
/bin/mkdir -p /var/run/frr
	/bin/mkdir -p /var/log/frr

	if [ -s {$frr_config_base}/frr_md5pw_del.conf ]; then
		/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf
	fi

	if [ -s {$frr_config_base}/frr_md5pw_add.conf ]; then
		/sbin/setkey -f {$frr_config_base}/frr_md5pw_add.conf
	fi

	/usr/sbin/chown -R frr:frr {$frr_config_base}
	/usr/sbin/chown -R frr:frr /var/run/frr
	/usr/sbin/chown -R frr:frr /var/log/frr
	{$carp_ip_status_check}
	# Perform configuration check
	echo "Performing intergrated config test"
	/usr/local/bin/vtysh -C

	# Start Daemons
	echo "Starting FRR"
	/usr/local/etc/rc.d/frr start

	# Start watchfrr
	echo "Starting watchfrr"
	/usr/local/sbin/watchfrr -d -r /usr/local/etc/rc.d/frrbBrestartbB%s -s /usr/local/etc/rc.d/frrbBstartbB%s -k /usr/local/etc/rc.d/frrbBstopbB%s -b bB -t 30 {$frr_daemons_string}
EOF;

	write_rcfile(array(
			"file" => "frr.sh",
			"start" => $rc_file_start,
			"stop" =>  $rc_file_stop
		)
	);

	/* Ensure files have correct ownership and permissions */
	chmod("/usr/local/etc/rc.d/frr.sh", 0555);
	foreach ($frr_daemons as $daemon) {
		$daemon_config_file = "{$frr_config_base}/{$daemon}.conf";
		if (file_exists($daemon_config_file) && (filesize($daemon_config_file) > 0)) {
			chmod($daemon_config_file, 0600);
		}
	}

	/* Set rc.conf.d/frr for watchfrr service control */
	$frr_rc_conf = "";
	if ($frr_conf['enable']) {
		$frr_rc_conf = "frr_enable=\"YES\"\n";
	} else {
		$frr_rc_conf = "frr_enable=\"NO\"\n";
	}
	$frr_rc_conf .= "frr_vtysh_boot=\"YES\"\n";

	foreach ($frr_daemons_enabled as $daemon) {
		if (!empty($frr_daemon_modules[$daemon])) {
			$modules = trim($frr_daemon_modules[$daemon]);
			$frr_rc_conf .= "{$daemon}_flags=\"{$modules}\"\n";
		}
	}

	if (!empty($frr_daemons_string)) {
		$frr_rc_conf .= "frr_daemons=\"{$frr_daemons_string}\"\n";
	}

	/* Check the generated rc configuration to decide whether FRR requires a restart or a configuration reload */
	if (file_exists("/usr/local/etc/rc.conf.d/frr")) {
		$frr_rc_conf_last = file_get_contents("/usr/local/etc/rc.conf.d/frr");
	} else {
		$frr_rc_conf_last = "";
	}

	if ((strcmp($frr_rc_conf, $frr_rc_conf_last) == 0) && frr_daemons_running($frr_daemons_enabled)) {
		$frr_restart_needed = false;
	} else {
		$frr_restart_needed = true;
		safe_mkdir("/usr/local/etc/rc.conf.d");
		file_put_contents("/usr/local/etc/rc.conf.d/frr", $frr_rc_conf);
	}

	return $frr_restart_needed;
}

function frr_service_action($restart_needed) {
	/* If frr is not configured, then stop */
	$frr_conf = config_get_path('installedpackages/frr/config/0', []);
	if (empty($frr_conf)) {
		return null;
	}

	if ($frr_conf['enable']) {
		/* Start/Restart FRR, if a CARP VIP is set, check its status and appropriately. */
		if (array_key_exists('carpstatusvid', $frr_conf) && $frr_conf['carpstatusvid'] != "none") {
			$status = get_carp_interface_status($frr_conf['carpstatusvid']);
			switch (strtoupper($status)) {
				// Stop the service if the VIP is in BACKUP or INIT state.
				case "BACKUP":
				case "INIT":
					frr_package_log("Stopping services due to CARP status.");
					mwexec_bg("/usr/local/etc/rc.d/frr.sh stop");
					unlink_if_exists("/tmp/frr_start_command_last.txt");
					break;
				// Start the service if the VIP is MASTER state.
				case "MASTER":
				// Assume it's up if the status can't be determined.
				default:
					if ($restart_needed) {
						frr_package_log("Restarting services.");
						mwexec_bg("/usr/local/etc/rc.d/frr.sh restart");
					} else {
						frr_package_log("Reloading configuration.");
						mwexec_bg("/usr/local/sbin/frr-reload");
					}
					break;
			}
		} else {
			if ($restart_needed) {
				frr_package_log("Restarting services.");
				mwexec_bg("/usr/local/etc/rc.d/frr.sh restart");
			} else {
				frr_package_log("Reloading configuration.");
				mwexec_bg("/usr/local/sbin/frr-reload");
			}
		}
	} else {
		frr_package_log("Stopping services.");
		mwexec_bg("/usr/local/etc/rc.d/frr.sh stop");
		unlink_if_exists("/usr/local/etc/rc.conf.d/frr");
	}
}

/* Check all supplied daemons are running */
function frr_daemons_running($daemons) {
	$frr_daemons_running = array();
	foreach ($daemons as $daemon) {
		if (is_process_running($daemon)) {
			$frr_daemons_running[$daemon] = true;
		} else {
			$frr_daemons_running[$daemon] = false;
		}
	}

	$logarr = array();
	foreach ($frr_daemons_running as $daemon => $state) {
		$s = $state ? "running" : "stopped";
		array_push($logarr, "{$daemon}: {$s}");
	}
	$logstr = implode(" | ", $logarr);
	frr_package_log("Daemon state: {$logstr}");

	if (count(array_unique($frr_daemons_running)) === 1) {
		return current($frr_daemons_running);
	} else {
		return false;
	}
}

/* Setup necessary setkey entries for TCP MD5 authentication. */
function frr_setkey($restart_needed) {
	global $frr_config_base;
	$peers = array();

	if (empty(config_get_path('installedpackages/frr/config/0/enable'))) {
		if (file_exists("{$frr_config_base}/frr_md5pw_del.conf")) {
			mwexec("/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf");
		}
		unlink_if_exists("{$frr_config_base}/frr_md5pw_del.conf");
		unlink_if_exists("{$frr_config_base}/frr_md5pw_add.conf");
		return;
	}

	/* Build md5 password configuration files based on raw tab list */
	foreach (config_get_path('installedpackages/frrglobalraw/config/0/row', []) as $frrtcpsigpw) {
		if (($frrtcpsigpw['tcpsigsrc'] != "") && ($frrtcpsigpw['tcpsigdst'] != "") && ($frrtcpsigpw['tcpsigpw'])!= "") {
			$tmp = array();
			$tmp['src'] = $frrtcpsigpw['tcpsigsrc'];
			$tmp['dst'] = $frrtcpsigpw['tcpsigdst'];
			$tmp['pw'] = $frrtcpsigpw['tcpsigpw'];
			$tmp['bidir'] = !empty($frrtcpsigpw['tcpsigbidir']);
			$peers[] = $tmp;
		}
	}

	/* Build md5 password configuration for BGP Peers */
	$neighbors = frr_get_neighbors_with_name_key();
	foreach ($neighbors as $nname => $neighbor) {
		list($pwtype_base, $pwtype_bidir) = explode('-', $neighbor['password_type'], 2);
		if ((($pwtype_base == "setkey") ||
			($pwtype_base == "both")) &&
			is_ipaddr($neighbor['peer'])) {
			if (array_key_exists($neighbor['peergroup'], $neighbors)) {
				$peergroup = $neighbors[$neighbor['peergroup']];
			} else {
				$peergroup = array();
			}
			$tmp = array();
			/* determine source by update-source or by finding the interface for that destination */
			/* First, try to get the update source specified directly on this neighbor. */
			$tmp['src'] = frr_get_neighbor_updatesource($neighbor['updatesource'], $neighbor['updatesource_type']);
			/* If that fails, check if this neighbor is a member of a peer group, and if that group has one */
			if (empty($tmp['src']) && !empty($neighbor['peergroup']) &&
			    !empty($peergroup) && !empty($peergroup['updatesource'])) {
				/* Try to determine an update source from the group */
				$tmp['src'] = frr_get_neighbor_updatesource($peergroup['updatesource'], $peergroup['updatesource_type']);
			}
			/* If it is still empty, try to find it automatically based on the destination */
			if (empty($tmp['src'])) {
				if (is_ipaddrv4($neighbor['peer'])) {
					$tmp['src'] = find_interface_ip(guess_interface_from_ip($neighbor['peer']));
				} elseif (is_ipaddrv6($neighbor['peer'])) {
					$tmp['src'] = find_interface_ipv6(guess_interface_from_ip($neighbor['peer']));
				}
			}
			/* If all attempts to determine a source have failed, bail */
			if (empty($tmp['src'])) {
				continue;
			}

			/* This peer address can be used as-is */
			$tmp['dst'] = $neighbor['peer'];

			if (!empty($neighbor['password'])) {
				/* Password defined on this peer directly */
				$tmp['pw'] = $neighbor['password'];
			} elseif (!empty($peergroup['password'])) {
				/* Password from the peer group instead */
				$tmp['pw'] = $peergroup['password'];
			} else {
				/* No valid password, so skip this entry! */
				continue;
			}

			/* Use bidirectional setkey? */
			if ($pwtype_bidir == 'bidir') {
				$tmp['bidir'] = true;
			}
			$peers[] = $tmp;
		}
	}

	foreach ($peers as $peer) {
		$md5pw_add .= "add {$peer['src']} {$peer['dst']} tcp 0x1000 -A tcp-md5 \"{$peer['pw']}\";\n";
		if ($peer['bidir']) {
			$md5pw_add .= "add {$peer['dst']} {$peer['src']} tcp 0x1001 -A tcp-md5 \"{$peer['pw']}\";\n";
		}
		$md5pw_del .= "delete {$peer['src']} {$peer['dst']} tcp 0x1000 ;\n";
		if ($peer['bidir']) {
			$md5pw_del .= "delete {$peer['dst']} {$peer['src']} tcp 0x1001 ;\n";
		}
	}

	/* restart setkey only if parameters have changed, see https://redmine.pfsense.org/issues/11325 */
	if (!empty($md5pw_add) && !empty($md5pw_del)) {
		if (is_service_running('bgpd') && file_exists("{$frr_config_base}/frr_md5pw_add.conf")) {
			$existing_md5pw_add = file_get_contents("{$frr_config_base}/frr_md5pw_add.conf");
			if ($md5pw_add != $existing_md5pw_add) {
				/* setkey parameters changed, restart needed */
				$restart_setkey = true;
			}
		} else {
			$restart_setkey = true;
		}
		if ($restart_setkey) {
			if (!$restart_needed && file_exists("{$frr_config_base}/frr_md5pw_del.conf")) {
				/* do not run 'setkey' twice if $restart_needed is set */
				mwexec("/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf");
			}
			file_put_contents("{$frr_config_base}/frr_md5pw_del.conf", $md5pw_del);
			file_put_contents("{$frr_config_base}/frr_md5pw_add.conf", $md5pw_add);
			if (!$restart_needed) {
				mwexec("/sbin/setkey -f {$frr_config_base}/frr_md5pw_add.conf");
			}
		}
	} elseif (file_exists("{$frr_config_base}/frr_md5pw_add.conf") &&
	    file_exists("{$frr_config_base}/frr_md5pw_del.conf")) {
		mwexec("/sbin/setkey -f {$frr_config_base}/frr_md5pw_del.conf");
		unlink_if_exists("{$frr_config_base}/frr_md5pw_del.conf");
		unlink_if_exists("{$frr_config_base}/frr_md5pw_add.conf");
	}
}

/* Write a message to the syslog conditionally on package log level setting*/
function frr_package_log($string, $priority = LOG_INFO) {
	/* Populate FRR Global Settings */
	$pkgloglevel = config_get_path('installedpackages/frr/config/0/pkgloglevel');

	/* Check if extended package logging is enabled */
	if (is_null($pkgloglevel) || ($pkgloglevel < 1)) {
		// Extended logging is disabled
		return;
	}

	logger($priority, $string, LOG_PREFIX_PKG_FRR);
}

/* Main function to generate all of the configuration files and make general
 * preparations */
function frr_generate_config() {
	/* Create integrated configuration global */
	global $frr_integrated_config;
	$frr_integrated_config = array();
	$frr_integrated_config['interfaces'] = array();

	/* Make sure that the FRR config directory exists and has the
	 * correct ownership info. */
	safe_mkdir(PKG_FRR_CONFIG_BASE);
	chown(PKG_FRR_CONFIG_BASE, 'frr');
	chgrp(PKG_FRR_CONFIG_BASE, 'frr');
	clearstatcache();

	/* vtysh configuration */
	frr_generate_config_vtysh();

	/* Zebra configuration */
	frr_generate_config_zebra();

	/* BGP configuration */
	frr_generate_config_bgp();

	/* OSPF Configuration */
	frr_generate_config_ospf();

	/* OSPF6 Configuration */
	frr_generate_config_ospf6();

	/* RIP Configuration */
	frr_generate_config_rip();

	/* BFD Configuration */
	frr_generate_config_bfd();

	/* Integrated configuration */
	frr_generate_config_integrated();

	/* Create the rc.d service control script and trigger restart/reload */
	$restart_needed = frr_generate_config_rcfile();
	if (!empty($_POST['service_force_restart'])) {
		frr_package_log("Service restart forced.");
		/* If force_restart is set, override restart_needed to force a service restart */
		$restart_needed = true;
	}

	/* Setup TCP MD5 authentication */
	frr_setkey($restart_needed);

	frr_service_action($restart_needed);
}

function frr_generate_config_vtysh() {
	global $frr_config_base, $frr_auto_config_warning;

	unlink_if_exists("{$frr_config_base}/vtysh.conf");

	/* Populate FRR Global Settings */
	$frr_conf = config_get_path('installedpackages/frr/config/0', []);

	/* If there is no raw configuration and no GUI configuration, stop. */
	if (empty($frr_conf)) {
		frr_package_log("vtysh: No config data found.");
		return;
	}
	if (empty($frr_conf['enable'])) {
		frr_package_log("vtysh: FRR master switch is off.");
		return;
	}

	$vtyshconffile = $frr_auto_config_warning;
	$vtyshconffile .= "service integrated-vtysh-config\n\n";
	file_put_contents("{$frr_config_base}/vtysh.conf", $vtyshconffile);
	chown("{$frr_config_base}/vtysh.conf", 'frr');
	chgrp("{$frr_config_base}/vtysh.conf", 'frr');
}

function frr_flatten_config_interfaces() {
	global $frr_integrated_config;

	$interfaces_config = "";
	foreach (array_keys($frr_integrated_config['interfaces']) as $interface) {
		$interfaces_config .= "interface {$interface}\n";
		$interface_description = "";

		foreach(array('ospfd', 'ospf6d', 'ripd') as $service) {
			if (empty($frr_integrated_config['interfaces_descr'][$interface][$service])) {
				continue;
			}
			if (!empty($interface_description)) {
				$interface_description .= " - ";
			}
			$interface_description .= "{$service}: {$frr_integrated_config['interfaces_descr'][$interface][$service]}";
		}
		unset($service);

		if (!empty($interface_description)) {
			$interfaces_config .= " description \"{$interface_description}\"\n";
		}

		$interfaces_config .= $frr_integrated_config['interfaces'][$interface];
	}
	unset($interface);

	$frr_integrated_config['interfaces'] = $interfaces_config;
}

function frr_generate_config_integrated() {
	global $frr_config_base, $frr_auto_config_warning, $frr_integrated_config;

	unlink_if_exists("{$frr_config_base}/frr.conf");

	/* Populate FRR Global Settings */
	$frr_conf = config_get_path('installedpackages/frr/config/0', []);

	if (empty($frr_conf['enable'])) {
		frr_package_log("FRR master switch is off.");
		return;
	}

	if (!empty(config_get_path('installedpackages/frrglobalraw/config/0/frr'))) {
		// if there is a raw config specified in the config.xml use that instead of the assisted config
		$integratedconffile = str_replace("\r", "", base64_decode(config_get_path('installedpackages/frrglobalraw/config/0/frr')));
	} else {
		/* If there is no raw configuration and no GUI configuration, stop. */
		if (empty($frr_conf)) {
			frr_package_log("No config data found.");
			return;
		}

		frr_package_log("Rebuild configuration.");

		$integratedconffile = $frr_auto_config_warning;
		$integratedconffile .= "frr defaults traditional\n";
		$integratedconffile .= 'hostname ' . config_get_path('system/hostname') . '.' .config_get_path('system/domain') . "\n";

		/* Management Password */
		if ($frr_conf['password']) {
			$integratedconffile .= "password {$frr_conf['password']}\n";
		}
		/* Logging Options */
		if ($frr_conf['logging']) {
			$integratedconffile .= "log syslog\n";
		}
		/* SNMP AgentX Support */
		if ($frr_conf['enablesnmpagentx']) {
			$integratedconffile .= "agentx\n";
		}
		/* Nethop Tracking */
		if (isset($frr_conf['nht'])) {
			if (($frr_conf['nht'] == 'ipv4') || ($frr_conf['nht'] == 'both')) {
				$integratedconffile .= "ip nht resolve-via-default\n";
			}
			if (($frr_conf['nht'] == 'ipv6') || ($frr_conf['nht'] == 'both')) {
				$integratedconffile .= "ipv6 nht resolve-via-default\n";
			}
		}

		/* FRR Services */
		$integratedconffile .= "service integrated-vtysh-config\n";
		if ($frr_conf['passwordencrypt']) {
			$integratedconffile .= "service password-encryption\n";
		}
		$integratedconffile .= "!\n";

		if (!empty($frr_conf['routerid'])) {
			if (is_ipaddrv4($frr_conf['routerid'])) {
				$integratedconffile .= "ip ";
			} elseif (is_ipaddrv6($frr_conf['routerid'])) {
				$integratedconffile .= "ipv6 ";
			}
			$integratedconffile .= "router-id {$frr_conf['routerid']}\n";
			$integratedconffile .= "!\n";
		}

		frr_flatten_config_interfaces();
		$conf_keys = array('staticd', 'interfaces', 'bgpd', 'rpki', 'ospfd', 'ospf6d', 'ripd', 'zebra', 'bfdd');
		foreach ($conf_keys as $key) {
			if (!array_key_exists($key, $frr_integrated_config) || empty($frr_integrated_config[$key])) {
				continue;
			}
			$integratedconffile .= $frr_integrated_config[$key];
			$integratedconffile .= "!\n";
		}

		$integratedconffile .= "line vty\n";
		$integratedconffile .= "!\n";

		/* Remove sample configuration files */
		array_map('unlink', glob("{$frr_config_base}/*.sample*"));
	}

	file_put_contents("{$frr_config_base}/frr.conf", $integratedconffile, LOCK_EX);
	chown("{$frr_config_base}/frr.conf", 'frr');
	chgrp("{$frr_config_base}/frr.conf", 'frr');
}

/* Upgrade the FRR configuration to the latest format */
function frr_config_sort_route_map() {
	update_status("Sorting route-map configuration items");

	$frr_routemap_conf = config_get_path('installedpackages/frrglobalroutemaps/config', []);
	if (empty($frr_routemap_conf)) {
		return null;
	}
	frr_array_name_seq_sort($frr_routemap_conf);
	config_set_path('installedpackages/frrglobalroutemaps/config', $frr_routemap_conf);
	update_status("Saving sorted route-map configuration items");
	write_config('FRR: Sorted route-map configuration items');
	update_status("Done.\n");
}

function frr_package_config_cleanup($area, $add0 = false) {
	/* No area, nothing to do. */
	if (empty($area)) {
		return false;
	}
	$path = "installedpackages/{$area}/config";
	if ($add0) {
		$path .= "/0";
	}
	$conf = config_get_path($path, []);
	/* If the path is empty or not an array, wipe out the area as it's
	 * not valid and may break in various ways. */
	if (empty($conf) || !is_array($conf)) {
		config_del_path("installedpackages/{$area}");
		return true;
	}
	return false;
}

/* Upgrade the FRR configuration to the latest format */
function frr_package_config_upgrade() {
	update_status("Upgrading FRR Settings ... ");
	$need_write = false;
	/* Populate FRR Global Settings */
	$frr_conf = config_get_path('installedpackages/frr/config/0', []);
	if (empty($frr_conf)) {
		return null;
	}

	/* Clean up potentially broken old settings */
	/* Areas that have the configuration under entry "0" */
	$frr_config0_areas = array(
		'frr', 'frrbfd', 'frrglobalraw', 'frrbgp', 'frrbgpadvanced',
		'frrospf6d', 'frrospfd', 'frrripd'
	);
	/* Areas that do not use "0" */
	$frr_config_areas = array(
		'frrbfdpeers', 'frrbfdprofiles', 'frrbgpaspaths',
		'frrbgpcommunities', 'frrbgpneighbors',
		'frrbgprpkicacheservers', 'frrglobalroutemaps',
		'frrospf6dinterfaces', 'frrospfd6areas', 'frrospfdareas',
		'frrospfdinterfaces', 'frrospfdneighbors', 'frrripdinterfaces',
		'frrripdneighbors'
	);
	/* Cleanup before starting */
	foreach ($frr_config0_areas as $frr_area) {
		if (frr_package_config_cleanup($frr_area, true)) {
			$need_write = true;
		}
	}
	foreach ($frr_config_areas as $frr_area) {
		if (frr_package_config_cleanup($frr_area, false)) {
			$need_write = true;
		}
	}

	/* Populate FRR OSPF Settings */
	$ospfd_conf              = config_get_path('installedpackages/frrospfd/config/0', []);
	$ospf6d_conf             = config_get_path('installedpackages/frrospf6d/config/0', []);
	$frr_acls_conf           = config_get_path('installedpackages/frrglobalacls/config', []);
	$frr_prefixes_conf       = config_get_path('installedpackages/frrglobalprefixes/config', []);
	$frr_routemap_conf       = config_get_path('installedpackages/frrglobalroutemaps/config', []);
	$frr_ospfinterfaces_conf = config_get_path('installedpackages/frrospfdinterfaces/config', []);
	$frr_areas_conf          = config_get_path('installedpackages/frrospfdareas/config', []);
	$bgp_conf                = config_get_path('installedpackages/frrbgp/config/0', []);

	/* Iterate old network list looking for items marked to not redistribute */
	$dnrlist = array();
	foreach (config_get_path('installedpackages/frrospfd/config/0/row', []) as $idx => &$redistr) {
		if (empty($redistr['routevalue']) ||
			($redistr['redistribute']) != 'ON') {
			continue;
		}
		$dnrlist[] = $redistr['routevalue'];
		unset($ospfd_conf['row'][$idx]);
		$need_write = true;
	}

	/* Only import these items if there are values to process.
	 * If there are none, it means we have already imported or there was
	 * nothing to import, thus the changes are not needed. */
	if (!empty($dnrlist)) {
		/* Create a new access-list called dnr-list
		 * Add entries for old "do not redistribute" networks */
		$dnracl = array(
			'name' => 'dnr-list',
			'descr' => 'Do Not Redistribute (imported)',
		);
		$seq = 10;
		$dnracl['row'] = array();
		foreach ($dnrlist as $dnr) {
			$dnracl['row'][] = array(
				'seq' => $seq,
				'action' => 'deny',
				'source' => $dnr
			);
			$seq += 10;
		}
		$dnracl['row'][] = array(
			'seq' => $seq,
			'action' => 'permit',
			'source' => 'any'
		);
		$frr_acls_conf[] = $dnracl;

		/* Create a new Route Map named DNR using the dnr-list */
		$frr_routemap_conf[] = array(
			'name' => 'DNR',
			'descr' => 'Do Not Redistribute List',
			'action' => 'permit',
			'seq' => '10',
			'acl_match' => 'dnr-list',
		);

		/* Create new Area entry for default area with its export list set to dnr-list */
		$frr_areas_conf[] = array(
			'area' => $ospfd_conf['area'],
			'descr' => 'Default Area (imported)',
			'type' => $ospfd_conf['updatefib'],
			'exportlist' => 'dnr-list',
		);

		/* Set redist route-maps to DNR and distribute lists to dnr-list */
		if (array_key_exists('redistributeconnectedsubnets', $ospfd_conf) &&
		    $ospfd_conf['redistributeconnectedsubnets']) {
			$ospfd_conf['redistributeconnectedsubnets_routemap'] = "DNR";
			$ospfd_conf['redistributeconnectedsubnets_distlist'] = "dnr-list";
		}
		if (array_key_exists('redistributekernel', $ospfd_conf) &&
		    $ospfd_conf['redistributekernel']) {
			$ospfd_conf['redistributekernel_routemap'] = "DNR";
			$ospfd_conf['redistributekernel_distlist'] = "dnr-list";
		}
		if (array_key_exists('redistributebgp', $ospfd_conf) &&
		    $ospfd_conf['redistributebgp']) {
			$ospfd_conf['redistributebgp_routemap'] = "DNR";
			$ospfd_conf['redistributebgp_distlist'] = "dnr-list";
		}
		if (array_key_exists('redistributestatic', $ospfd_conf) &&
		    $ospfd_conf['redistributestatic']) {
			$ospfd_conf['redistributestatic_routemap'] = "DNR";
			$ospfd_conf['redistributestatic_distlist'] = "dnr-list";
		}
		if (array_key_exists('redistributedefaultroute', $ospfd_conf) &&
		    $ospfd_conf['redistributedefaultroute']) {
			$ospfd_conf['redistributedefaultroute_routemap'] = "DNR";
		}
	}

	/* interface auth to new select style */
	foreach ($frr_ospfinterfaces_conf as &$conf) {
		$realif = get_real_interface($conf['interface']);
		if (empty($realif) ||
			empty($conf['password']) ||
			isset($conf['authtype'])) {
			continue;
		}
		if (array_key_exists('md5password', $conf) &&
		    $conf['md5password']) {
			$conf['authtype'] = "digest";
			unset($conf['md5password']);
		} else {
			$conf['authtype'] = "simple";
		}
		$need_write = true;
	}

	/* updatefib -> areatype */
	if (array_key_exists('updatefib', $ospfd_conf)) {
		$ospfd_conf['areatype'] = $ospfd_conf['updatefib'];
		unset($ospfd_conf['updatefib']);
		$need_write = true;
	}

	/* area->defaultarea */
	if (array_key_exists('defaultarea', $ospfd_conf) &&
	    array_key_exists('area', $ospfd_conf) &&
	    (strlen($ospfd_conf['defaultarea']) == 0) &&
	    !empty($ospfd_conf['area'])) {
		$ospfd_conf['defaultarea'] = $ospfd_conf['area'];
		unset($ospfd_conf['area']);
		$need_write = true;
	}
	if (array_key_exists('defaultarea', $ospf6d_conf) &&
	    array_key_exists('area', $ospf6d_conf) &&
	    (strlen($ospf6d_conf['defaultarea']) == 0) &&
	    !empty($ospf6d_conf['area'])) {
		$ospf6d_conf['defaultarea'] = $ospf6d_conf['area'];
		unset($ospf6d_conf['area']);
		$need_write = true;
	}
	/* areatype->defaultareatype */
	if (array_key_exists('defaultareatype', $ospfd_conf) &&
	    array_key_exists('areatype', $ospfd_conf) &&
	    (strlen($ospfd_conf['defaultareatype']) == 0) &&
	    !empty($ospfd_conf['areatype'])) {
		$ospfd_conf['defaultareatype'] = $ospfd_conf['areatype'];
		unset($ospfd_conf['areatype']);
		$need_write = true;
	}

	/* BGP distribution migrate */
	if (array_key_exists('redistributeconnected', $bgp_conf) &&
	    array_key_exists('redistributeconnectedsubnets', $bgp_conf) &&
	    (strlen($bgp_conf['redistributeconnected']) == 0) &&
	    !empty($bgp_conf['redistributeconnectedsubnets'])) {
		$bgp_conf['redistributeconnected'] = $bgp_conf['redistributeconnectedsubnets'];
		unset($bgp_conf['redistributeconnectedsubnets']);
		$need_write = true;
	}

	if (array_key_exists('redistributeospf', $bgp_conf) &&
	    array_key_exists('redistributeospf6', $bgp_conf) &&
	    ($bgp_conf['redistributeospf'] == 'yes') &&
	    empty($bgp_conf['redistributeospf6'])) {
		$bgp_conf['redistributeospf6'] = 'yes';
		$need_write = true;
	}

	/* ACL and Prefix List add IP Type*/
	foreach ($frr_acls_conf as & $aclconf) {
		if (array_key_exists('iptype', $aclconf) &&
		    array_key_exists('row', $aclconf) &&
		    empty($aclconf['iptype']) &&
		    !empty($aclconf['row'])) {
			if (is_subnetv4($aclconf['row'][0]['source'])) {
				$aclconf['iptype'] = 'IPv4';
			} else {
				$aclconf['iptype'] = 'IPv6';
			}
			$need_write = true;
		}
	}
	foreach ($frr_prefixes_conf as & $prefixconf) {
		if (array_key_exists('iptype', $prefixconf) &&
		    array_key_exists('row', $prefixconf) &&
		    empty($prefixconf['iptype']) &&
		    !empty($prefixconf['row'])) {
			if (is_subnetv4($prefixconf['row'][0]['source'])) {
				$prefixconf['iptype'] = 'IPv4';
			} else {
				$prefixconf['iptype'] = 'IPv6';
			}
			$need_write = true;
		}
	}
	update_status("Done.\n");

	/* Save Changes */
	if ($need_write) {
		config_set_path('installedpackages/frrospfd/config/0', $ospfd_conf);
		config_set_path('installedpackages/frrospf6d/config/0', $ospf6d_conf);
		config_set_path('installedpackages/frrglobalacls/config', $frr_acls_conf);
		config_set_path('installedpackages/frrglobalprefixes/config', $frr_prefixes_conf);
		config_set_path('installedpackages/frrglobalroutemaps/config', $frr_routemap_conf);
		config_set_path('installedpackages/frrospfdinterfaces/config', $frr_ospfinterfaces_conf);
		config_set_path('installedpackages/frrospfdareas/config', $frr_areas_conf);
		config_set_path('installedpackages/frrbgp/config/0', $bgp_conf);

		/* Cleanup again before write */
		foreach ($frr_config0_areas as $frr_area) {
			if (frr_package_config_cleanup($frr_area, true)) {
				$need_write = true;
			}
		}
		foreach ($frr_config_areas as $frr_area) {
			if (frr_package_config_cleanup($frr_area, false)) {
				$need_write = true;
			}
		}

		update_status("Saving changes ... ");
		write_config('FRR: Upgraded Settings.');
		update_status("Done.\n");
	} else {
		update_status("Nothing to do.\n");
	}
}

function frr_set_tunables() {
	$sysctl_conf = config_get_path('sysctl/item', []);
	$sysctl_maxsockbuff = array('tunable' => 'kern.ipc.maxsockbuf', 'value' => 16777216, 'descr' => "Maximum socket buffer size - set by FRR package");

	if (!in_array($sysctl_maxsockbuff, $sysctl_conf)) {
		update_status("Installing maxsockbuf tunable ... ");
		$sysctl_conf[] = $sysctl_maxsockbuff;
		config_set_path('sysctl/item', $sysctl_conf);
		write_config('FRR: Installed maxsockbuf tunable.');
		system_setup_sysctl();
		update_status("Done.\n");
	}
}

/* Install-time functions */
function frr_package_install() {
	/* Upgrade the configuration */
	frr_package_config_upgrade();

	/* Set tunable kern.ipc.maxsockbuf to FRR recommended */
	/* OSPF and OSPF6 most likely won't work without this */
	frr_set_tunables();
}
