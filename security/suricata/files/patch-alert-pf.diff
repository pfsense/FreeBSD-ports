diff -ruN ./suricata-7.0.2.orig/src/Makefile.am ./suricata-7.0.2/src/Makefile.am
--- ./suricata-7.0.2.orig/src/Makefile.am	2023-10-18 10:25:29.000000000 -0400
+++ ./src/Makefile.am	2023-08-03 09:21:02.000000000 -0400
@@ -13,6 +13,7 @@
 	action-globals.h \
 	alert-debuglog.h \
 	alert-fastlog.h \
+	alert-pf.h \
 	alert-syslog.h \
 	app-layer-detect-proto.h \
 	app-layer-dnp3.h \
@@ -625,6 +626,7 @@
 libsuricata_c_a_SOURCES = \
 	alert-debuglog.c \
 	alert-fastlog.c \
+	alert-pf.c alert-pf.h \
 	alert-syslog.c \
 	app-layer.c \
 	app-layer-detect-proto.c \
diff -ruN ./suricata-7.0.2.orig/src/Makefile.in ./suricata-7.0.2/src/Makefile.in
--- ./suricata-7.0.2.orig/src/Makefile.in	2023-10-18 10:30:29.000000000 -0400
+++ ./src/Makefile.in	2023-11-09 14:54:23.000000000 -0500
@@ -153,6 +153,7 @@
 libsuricata_c_a_LIBADD =
 am_libsuricata_c_a_OBJECTS = alert-debuglog.$(OBJEXT) \
 	alert-fastlog.$(OBJEXT) alert-syslog.$(OBJEXT) \
+	alert-pf.$(OBJEXT) \
 	app-layer.$(OBJEXT) app-layer-detect-proto.$(OBJEXT) \
 	app-layer-dnp3.$(OBJEXT) app-layer-dnp3-objects.$(OBJEXT) \
 	app-layer-enip.$(OBJEXT) app-layer-enip-common.$(OBJEXT) \
@@ -615,6 +616,7 @@
 am__maybe_remake_depfiles = depfiles
 am__depfiles_remade = ./$(DEPDIR)/alert-debuglog.Po \
 	./$(DEPDIR)/alert-fastlog.Po ./$(DEPDIR)/alert-syslog.Po \
+	./$(DEPDIR)/alert-pf.Po \
 	./$(DEPDIR)/app-layer-detect-proto.Po \
 	./$(DEPDIR)/app-layer-dnp3-objects.Po \
 	./$(DEPDIR)/app-layer-dnp3.Po \
@@ -1327,6 +1329,7 @@
 	action-globals.h \
 	alert-debuglog.h \
 	alert-fastlog.h \
+	alert-pf.h \
 	alert-syslog.h \
 	app-layer-detect-proto.h \
 	app-layer-dnp3.h \
@@ -1939,6 +1942,7 @@
 libsuricata_c_a_SOURCES = \
 	alert-debuglog.c \
 	alert-fastlog.c \
+	alert-pf.c \
 	alert-syslog.c \
 	app-layer.c \
 	app-layer-detect-proto.c \
@@ -2867,6 +2871,7 @@
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alert-debuglog.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alert-fastlog.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alert-pf.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alert-syslog.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/app-layer-detect-proto.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/app-layer-dnp3-objects.Po@am__quote@ # am--include-marker
@@ -3666,6 +3671,7 @@
 distclean: distclean-am
 		-rm -f ./$(DEPDIR)/alert-debuglog.Po
 	-rm -f ./$(DEPDIR)/alert-fastlog.Po
+	-rm -f ./$(DEPDIR)/alert-pf.Po
 	-rm -f ./$(DEPDIR)/alert-syslog.Po
 	-rm -f ./$(DEPDIR)/app-layer-detect-proto.Po
 	-rm -f ./$(DEPDIR)/app-layer-dnp3-objects.Po
@@ -4320,6 +4326,7 @@
 maintainer-clean: maintainer-clean-am
 		-rm -f ./$(DEPDIR)/alert-debuglog.Po
 	-rm -f ./$(DEPDIR)/alert-fastlog.Po
+	-rm -f ./$(DEPDIR)/alert-pf.Po
 	-rm -f ./$(DEPDIR)/alert-syslog.Po
 	-rm -f ./$(DEPDIR)/app-layer-detect-proto.Po
 	-rm -f ./$(DEPDIR)/app-layer-dnp3-objects.Po
diff -ruN ./suricata-7.0.2.orig/src/alert-pf.c ./suricata-7.0.2/src/alert-pf.c
--- ./suricata-7.0.2.orig/src/alert-pf.c	1969-12-31 19:00:00.000000000 -0500
+++ ./src/alert-pf.c	2023-11-17 11:36:52.000000000 -0500
@@ -0,0 +1,1882 @@
+/* Copyright (C) 2007-2023 Open Information Security Foundation
+ *
+ * You can copy, redistribute or modify this Program under the terms of
+ * the GNU General Public License version 2 as published by the Free
+ * Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ * Portions of this module are based on previous works of the following:
+ *
+ * Copyright (c) 2023  Bill Meeks
+ * Copyright (c) 2012  Ermal Luci
+ * Copyright (c) 2006  Antonio Benojar <zz.stalker@gmail.com>
+ * Copyright (c) 2005  Antonio Benojar <zz.stalker@gmail.com>
+ *
+ * Copyright (c) 2003, 2004 Armin Wolfermann:
+ * 
+ * The AlertPfBlock() function is based 
+ * on Armin Wolfermann's pftabled-1.03 functions.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * \file
+ *
+ * \author Bill Meeks <billmeeks8@gmail.com>
+ *
+ * Inserts blocks for IP alerts into the pf firewall used in NetBSD and FreeBSD, 
+ * and logs the event, including the IP address, in "block.log".
+ *
+ *    # alert-pf blocking plugin
+ *    - alert-pf:
+ *        enabled: yes/no            # "yes" to enable blocking plugin
+ *        kill-state: yes/no         # "yes" to kill open state table entries associated with blocked IP addresses (default is "yes")
+ *        pass-list: <filename>      # complete path and filename for txt file of single IP addresses or CIDR networks that should never be blocked
+ *        block-ip: src/dst/both     # which IP in packet to block (default is BOTH)
+ *        pf-table: <pf table name>  # name of packet filter firewall table where block IP addresses should be added.  This table must exist!
+ *        block-drops-only: yes/no   # only insert blocks in packet filter firewall table for rules having DROP action keyword (default is "no")
+ *        passlist-debugging: yes/no # "yes" to enable detailed pass list operations logging
+ *
+ */
+
+#include "suricata.h"
+#include "suricata-common.h"
+#include "conf.h"
+#include "output.h"
+#include "action-globals.h"
+#include "packet.h"
+#include "threads.h"
+#include "tm-threads.h"
+#include "threadvars.h"
+
+#include "alert-pf.h"
+
+#include "util-atomic.h"
+#include "util-byte.h"
+#include "util-debug.h"
+#include "util-ip.h"
+#include "util-logopenfile.h"
+#include "util-print.h"
+#include "util-proto-name.h"
+#include "util-radix-tree.h"
+#include "util-time.h"
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/sysctl.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <ctype.h>
+#include <net/if.h>
+#include <net/pfvar.h>
+#include <net/route.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <err.h>
+#include <unistd.h>
+#include <regex.h>
+#include <ifaddrs.h>
+#include <pthread.h>
+#ifdef __FreeBSD__
+#include <libpfctl.h>
+#endif
+
+#define PFDEVICE	"/dev/pf"
+#define WLMAX		4096
+#define MODULE_NAME	"AlertPf"
+#define DEFAULT_LOG_FILENAME "block.log"
+#define DEFAULT_DEBUG_LOG_FILENAME "passlist_debug.log"
+#define MAX_RTMSG_SIZE 2048
+
+enum spblock { BLOCK_SRC, BLOCK_DST, BLOCK_BOTH };
+
+/* Define our FQDN Pass List linked-list structure */
+struct fqdn_wlist {
+  char apf_alias_tblname[PF_TABLE_NAME_SIZE];
+  SLIST_ENTRY(fqdn_wlist) elem;
+};
+
+/* Initialize FQDN linked-list HEAD pointer */
+SLIST_HEAD(wlist_head, fqdn_wlist);
+
+/**
+ * This holds global structures and variables.
+ * Each thread gets a pointer to this data.
+ */
+typedef struct _AlertPfCtx_ {
+    char pftable[PF_TABLE_NAME_SIZE + 1]; 
+    int kill_state;
+    enum spblock block_ip;
+    SCRadixTree *tree;
+    struct wlist_head head;
+    LogFileCtx* file_ctx;
+    LogFileCtx* dbgfile_ctx;
+    SCRWLock rwlock_tree;
+    SCRWLock rwlock_wlist;
+    int block_drops;
+    int passlist_dbg;
+} AlertPfCtx;
+
+/**
+ * This holds per-thread structures and variables.
+ */
+typedef struct AlertPfThread_ {
+    AlertPfCtx* ctx;       /* Pointer to the global context data */
+    int fd;                /* pf device handle */
+} AlertPfThread;
+
+SC_ATOMIC_DECLARE(uint64_t, alert_pf_blocks);  /* Atomic counter, to hold block count */
+SC_ATOMIC_DECLARE(uint64_t, alert_pf_alerts);  /* Atomic counter, to hold alerts count */
+
+// Used for Interface IP change monitoring thread
+pthread_t alert_pf_ifmon_thread;
+
+static void AlertPfDeInitCtx(OutputCtx *);
+static void AlertPfFreeWlist(struct wlist_head *);
+static TmEcode AlertPfIPv4(ThreadVars *, void *, const Packet *);
+static TmEcode AlertPfIPv6(ThreadVars *, void *, const Packet *);
+static bool AlertPfMatchFQDN(AlertPfThread *, uint8_t *, char);
+static int AlertPfInitIfaceList(AlertPfCtx *);
+static int AlertPfParseIfamAddress(struct sockaddr *, Address *);
+static void AlertPf_IflistMaint(Address *, AlertPfCtx *, u_char);
+static int AlertPf_parse_line(char *, FILE *);
+static int AlertPfLoadPassList(const char *, AlertPfCtx *);
+static int AlertPfDeviceInit(void);
+static int AlertPfTableExists(char *);
+static int AlertPfBlock(ThreadVars *, AlertPfThread *, const Address *);
+
+void AlertPfRegister(void)
+{
+    OutputRegisterPacketModule(LOGGER_ALERT_PF, MODULE_NAME, "alert-pf",
+        AlertPfInitCtx, AlertPf, AlertPfCondition,
+        AlertPfThreadInit, AlertPfThreadDeinit,
+        AlertPfExitPrintStats);
+}
+
+/**
+ * Return TRUE only for valid packets we want
+ * to process.
+ */
+int AlertPfCondition(ThreadVars *tv, void *thread_data, const Packet *p)
+{
+    if (p->alerts.cnt == 0)
+        return FALSE;
+    if (!IPH_IS_VALID(p))
+        return FALSE;
+    return TRUE;
+}
+
+/**
+ * This is a required function for freeing the
+ * 'user_data' element required for a Radix Tree
+ * entry. This function is called by the Radix Tree
+ * code when deleting a tree entry.
+ */
+static void AlertPfFreeUserData(void *data)
+{
+    if (data != NULL)
+        SCFree(data);
+
+    return;
+}
+
+/**
+ * This opens the pf device and returns a file descriptor.
+ */
+static int AlertPfDeviceInit(void)
+{
+    return(open(PFDEVICE, O_RDWR));
+}
+
+/** \brief Verifies the supplied pf table exists
+ *  \param *tablename pointer to pf table name string
+ *  \retval -1 on error, 1 if table exists or 0 if not
+ */
+static int AlertPfTableExists(char *tablename)
+{
+    int i;
+    int dev;
+    struct pfioc_table io;
+    struct pfr_table *table_aux = NULL;
+	
+    memset(&io, 0x00, sizeof(struct pfioc_table));
+	
+    /* obtain a pf device handle */
+    dev = AlertPfDeviceInit();
+    if (dev == -1) {
+        SCLogError("Failed to open the pf device.");
+        return -1;
+    }
+	
+    /* set up to first query the number of pf tables
+     * by passing a zero buffer size. Kernel will
+     * respond by putting the number of pf tables
+     * available in 'io.pfrio_size'.
+     */
+    io.pfrio_buffer = NULL;
+    io.pfrio_esize  = sizeof(struct pfr_table);
+    io.pfrio_size   = 0;
+
+    /* query pf for the count of available tables */
+    if(ioctl(dev, DIOCRGETTABLES, &io)) {  
+        SCLogError("AlertPfTableExists(): ioctl() DIOCRGETTABLES: %s\n", strerror(errno));
+        return -1;
+    }
+	
+    /* now we can allocate a buffer large enough to
+     * hold the names of all the available tables.
+     */
+    table_aux = (struct pfr_table*)SCCalloc(io.pfrio_size, sizeof(struct pfr_table));
+    if (table_aux == NULL) { 
+        SCLogError("AlertPfTableExists(): SCCalloc(): %s\n", strerror(errno));
+        return -1;
+    }
+	
+    /* set up to grab all the pf table names */
+    io.pfrio_buffer = table_aux;
+    io.pfrio_esize = sizeof(struct pfr_table);
+	
+    /* query pf for all registered table names again */
+    if(ioctl(dev, DIOCRGETTABLES, &io)) {
+        free(table_aux);
+        SCLogError("AlertPfTableExists(): ioctl() DIOCRGETTABLES: %s\n", strerror(errno));
+        return -1;
+    }
+
+    /* walk our buffer of returned pf table names
+     * to see if our configured table exists and
+     * return 1 (true) if we find it.
+     */
+    for(i=0; i < io.pfrio_size; i++) {
+        if (!strcmp(table_aux[i].pfrt_name, tablename)) {
+            free(table_aux);
+            return 1;
+        }	
+    }
+
+    /* did not find the referenced table */	
+    free(table_aux);
+    return 0;
+}
+
+/** \brief Inserts the passed IP address into the pf block table
+ *  \param *data pointer to AlertPfThread structure for current thread
+ *  \param *net_addr pointer to IP address to block
+ *  \retval -1 on error, 1 if IP blocked, 0 if already blocked
+ */
+static int AlertPfBlock(ThreadVars *tv, AlertPfThread *data, const Address *net_addr) 
+{ 
+    struct pfr_table table;
+    struct pfr_addr addr;
+    int states_err = 0;
+    int nadd = 0;
+    char timebuf[64];
+    char blockip[INET6_ADDRSTRLEN];
+    struct timeval tval;
+    SCTime_t ts;
+
+    if (data->fd < 0)
+        data->fd = AlertPfDeviceInit();
+    if (data->fd == -1) {
+        SCLogError("AlertPfDeviceInit(): no pf device available\n");
+        return -1;
+    }
+
+    memset(&table, 0x00, sizeof(struct pfr_table)); 
+    memset(&addr,  0x00, sizeof(struct pfr_addr)); 
+    strlcpy(table.pfrt_name, data->ctx->pftable, PF_TABLE_NAME_SIZE); 
+        
+    if (net_addr->family == AF_INET)
+        addr.pfra_ip4addr.s_addr = net_addr->addr_data32[0];
+    else if (net_addr->family == AF_INET6)
+        memcpy(&addr.pfra_ip6addr, net_addr->addr_data8, sizeof(struct in6_addr));
+    else {
+        SCLogError("AlertPfBlock(): unknown address family type: %d for supplied IP address.", net_addr->family);
+        return (-1);
+    }
+
+    addr.pfra_af  = net_addr->family; 
+    addr.pfra_net = net_addr->family == AF_INET ? 32 : 128;
+
+    /* Prepare some needed variables if pass list debugging enabled */
+    if (data->ctx->passlist_dbg) {
+        /* create a time string from packet's timestamp for debug log */
+        gettimeofday(&tval, NULL);
+        ts = SCTIME_FROM_TIMEVAL(&tval);
+        CreateTimeString(ts, timebuf, sizeof(timebuf));
+        PrintInet(net_addr->family, (const void *)net_addr->addr_data8, blockip, sizeof(blockip));
+    }
+
+    /* Add offender's IP address to passed pf table */
+    if (pfctl_table_add_addrs(data->fd, &table, &addr, 1, &nadd, 0)) {
+        SCLogError("AlertPfBlock(): ioctl() DIOCRADDADDRS: %s\n", strerror(errno));
+        if (data->ctx->passlist_dbg) {
+            SCMutexLock(&data->ctx->dbgfile_ctx->fp_mutex);
+            fprintf(data->ctx->dbgfile_ctx->fp, "%s  Thread: %s  Failed to add IP: %s to pf table %s. Traffic will NOT be blocked!\n", timebuf, tv->name, blockip, table.pfrt_name);
+            fflush(data->ctx->dbgfile_ctx->fp);
+            SCMutexUnlock(&data->ctx->dbgfile_ctx->fp_mutex);
+        }
+        return (-1);
+    }
+ 
+    /* count an IP block if we successfully added IP address
+     * to the pf table.
+     */
+    if (nadd > 0) {
+        SC_ATOMIC_ADD(alert_pf_blocks, 1);
+        if (data->ctx->passlist_dbg) {
+            SCMutexLock(&data->ctx->dbgfile_ctx->fp_mutex);
+            fprintf(data->ctx->dbgfile_ctx->fp, "%s  Thread: %s  Successfully added IP: %s to pf table %s for blocking.\n", timebuf, tv->name, blockip, table.pfrt_name);
+            fflush(data->ctx->dbgfile_ctx->fp);
+            SCMutexUnlock(&data->ctx->dbgfile_ctx->fp_mutex);
+        }
+    }
+
+    /* kill the states associated with the added IP address
+     * if 'kill-state' option enabled from YAML conf file.
+     */
+    if (data->ctx->kill_state) {
+        struct pfctl_kill kill = {
+            .af = net_addr->family,
+        };
+        unsigned int nkill = 0;
+
+        memset(&kill.src.addr.v.a.mask, 0xff, sizeof(kill.src.addr.v.a.mask));
+        if (kill.af == AF_INET)
+            kill.src.addr.v.a.addr.v4.s_addr = net_addr->addr_data32[0];
+        else if (kill.af == AF_INET6)
+            memcpy(&kill.src.addr.v.a.addr.v6, net_addr->addr_data8, sizeof(kill.src.addr.v.a.addr.v6));
+        else
+            return (-1);
+
+        /* Kill any open firewall states where blocked IP is the SRC */
+        if (pfctl_kill_states(data->fd, &kill, &nkill)) {
+            SCLogError("AlertPfBlock(): pfctl_kill_states(): %s\n", strerror(errno));
+            states_err++;
+        }
+
+        memset(&kill, 0, sizeof(kill));
+        memset(&kill.dst.addr.v.a.mask, 0xff, sizeof(kill.dst.addr.v.a.mask));
+        kill.af = net_addr->family;
+        if (kill.af == AF_INET)
+            kill.dst.addr.v.a.addr.v4.s_addr = net_addr->addr_data32[0];
+        else if (kill.af == AF_INET6)
+            memcpy(&kill.dst.addr.v.a.addr.v6, net_addr->addr_data8, sizeof(kill.dst.addr.v.a.addr.v6));
+
+        /* Kill any open firewall states where blocked IP is the DST */
+        if (pfctl_kill_states(data->fd, &kill, &nkill)) {
+            SCLogError("AlertPfBlock(): pfctl_kill_states(): %s\n", strerror(errno));
+            states_err++;
+        }
+
+        if (states_err && data->ctx->passlist_dbg) {
+            gettimeofday(&tval, NULL);
+            ts = SCTIME_FROM_TIMEVAL(&tval);
+            CreateTimeString(ts, timebuf, sizeof(timebuf));
+            SCMutexLock(&data->ctx->dbgfile_ctx->fp_mutex);
+            fprintf(data->ctx->dbgfile_ctx->fp, "%s  Thread: %s  Failed to kill all open states for IP: %s, stateful traffic may continue to pass!\n", timebuf, tv->name, blockip);
+            fflush(data->ctx->dbgfile_ctx->fp);
+            SCMutexUnlock(&data->ctx->dbgfile_ctx->fp_mutex);
+        } else if (data->ctx->passlist_dbg) {
+            gettimeofday(&tval, NULL);
+            ts = SCTIME_FROM_TIMEVAL(&tval);
+            CreateTimeString(ts, timebuf, sizeof(timebuf));
+            SCMutexLock(&data->ctx->dbgfile_ctx->fp_mutex);
+            fprintf(data->ctx->dbgfile_ctx->fp, "%s  Thread: %s  Successfully killed any open states for IP: %s, so any stateful traffic is blocked.\n", timebuf, tv->name, blockip);
+            fflush(data->ctx->dbgfile_ctx->fp);
+            SCMutexUnlock(&data->ctx->dbgfile_ctx->fp_mutex);
+        }
+    }
+
+    /* Return the number of effective IP blocks inserted */
+    return (nadd); 
+}
+
+/** \brief Load and parse a single line of text from Pass List file
+ *  \param *buf pointer to buffer of length WLMAX to hold line from Pass List file
+ *  \param *wfile FILE pointer to open Pass List text file
+ *  \retval buf[] filled with next line of text from Pass List file
+ *  \retval 0 on EOF, 1 if success or -1 if line exceed WLMAX length
+ */
+static int AlertPf_parse_line(char *buf, FILE *wfile)
+{
+    static char     next_ch = '\n';
+    int             i = 0;
+
+    if (feof(wfile))
+        return (0);
+
+    do {
+        next_ch = fgetc(wfile);
+        if (i < WLMAX)
+            buf[i++] = next_ch;
+    } while (!feof(wfile) && next_ch != '\n');
+
+    if (i >= WLMAX) {
+        SCLogWarning("Line in Pass List exceeded the allowed max of %d characters!", WLMAX);
+        buf[WLMAX - 1] = '\0';
+        return (-1);
+    }
+
+    buf[--i] = '\0';
+    return (1);
+}
+
+/** \brief Load and parse a Pass List text file and insert
+ *   the IP addresses and networks (in CIDR form) into a
+ *   Radix Tree for easy searching.
+ *  \param *plfile pointer to Pass List filename string
+ *  \param *ctx pointer to AlertPfCtx global data structure
+ *  \retval false (0) if error, true (-1) if success
+ */
+static int AlertPfLoadPassList(const char *plfile, AlertPfCtx *ctx)
+{
+    FILE *wfile;
+    SCRadixNode *node = NULL;
+    struct flock lock;
+	struct fqdn_wlist *fqdnwl = NULL;
+    struct in_addr *ipv4_addr = NULL;
+    struct in6_addr *ipv6_addr = NULL;
+    struct timeval tval;
+    char timebuf[64];
+    char buf[WLMAX];
+    char ip_str[WLMAX];
+    char ip_buffer[INET6_ADDRSTRLEN + 4];
+    int ret;
+    int count = 0;
+    int parsed = 0;
+    int covered = 0;
+
+    /* If we do not have a valid Radix Tree, then exit. */
+    if (ctx->tree == NULL) {
+        SCLogWarning("There is no valid Radix Tree to contain the Pass List IP data.");
+        return 0;
+    }
+
+    wfile = fopen(plfile, "r");
+    if (wfile == NULL) {
+        SCLogError("Unable to open Pass List file: %s", strerror(errno));
+        return (0);
+    }
+
+    memset(&lock, 0x00, sizeof(struct flock));
+    lock.l_type = F_RDLCK;
+    fcntl(fileno(wfile), F_SETLKW, &lock);
+
+    /* Lock the Radix Tree and FQDN List while we are updating them */
+    SCRWLockWRLock(&ctx->rwlock_tree);
+    SCRWLockWRLock(&ctx->rwlock_wlist);
+
+    memset(buf, 0, WLMAX);
+    SCLogInfo("Loading and parsing Pass List from: %s.", plfile);
+
+    /* Configure debug output if Pass List debugging enabled */
+    if (ctx->passlist_dbg) {
+        SCMutexLock(&ctx->dbgfile_ctx->fp_mutex);
+        gettimeofday(&tval, NULL);
+        SCTime_t ts = SCTIME_FROM_TIMEVAL(&tval);
+        CreateTimeString(ts, timebuf, sizeof(timebuf));
+        fprintf(ctx->dbgfile_ctx->fp, "%s  Pass List debugging enabled. Processing file: %s.\n",
+              timebuf, plfile);
+    }
+
+    /* Read the Pass List file line-by-line until EOF */
+    while((ret = AlertPf_parse_line(buf, wfile)) != 0) {
+        if (ret == 1 && strlen(buf) > 0) {
+
+            /* make a copy of the line we just parsed */
+            strcpy(ip_str, buf);
+            parsed++;
+            void *user_data = NULL;
+            Address *user_addr = NULL;
+            char *netmask_str = NULL;
+            int netmask_value = 0;
+
+            /* If pass list debug enabled, create a timestamp */
+            if (ctx->passlist_dbg) {
+                gettimeofday(&tval, NULL);
+                SCTime_t ts = SCTIME_FROM_TIMEVAL(&tval);
+                CreateTimeString(ts, timebuf, sizeof(timebuf));
+            }
+
+            /* first, check if we have a netblock definition,
+             * and if so, validate the supplied netmask and
+             * save it in 'netmask_value' for use later.
+             */
+            if ( (netmask_str = strchr(ip_str, '/')) != NULL) {
+                netmask_str[0] = '\0';
+                netmask_str++;
+                if (strchr(ip_str, ':') == NULL) {
+                    /* Validate IPv4 netmask string */
+                    if (StringParseI32RangeCheck(&netmask_value, 10, 0, (const char *)netmask_str, 0, 32) < 0) {
+                        SCLogError("Invalid IPv4 Netblock specified in %s - mask given was %s, skipping this line.", buf, netmask_str);
+                        continue;
+                    }
+                } else {
+                    /* Validate IPv6 netmask string */
+                    if (StringParseI32RangeCheck(&netmask_value, 10, 0, (const char *)netmask_str, 0, 128) < 0) {
+                        SCLogError("Invalid IPv6 Netblock specified in %s - mask given was %s, skipping this line.", buf, netmask_str);
+                        continue;
+                    }
+                }
+            }
+
+            /* next, see if we have an IPv4 or IPv6 address string */
+            if (strchr(ip_str, ':') != NULL) {
+                if ((ipv6_addr = ValidateIPV6Address(ip_str)) != NULL) {
+                    /* see if this address or netblock either already
+                     * exists in the Radix Tree or is contained within
+                     * an existing netblock in the Radix Tree.
+                     */
+                    if (netmask_str == NULL || atoi(netmask_str) == 128) {
+                        (void)SCRadixFindKeyIPV6ExactMatch((uint8_t *)ipv6_addr, ctx->tree, &user_data);
+                        if (user_data != NULL && ctx->passlist_dbg) {
+                            fprintf(ctx->dbgfile_ctx->fp, "%s  IPv6 address %s from Pass List exactly matches an existing entry, so not adding it again.\n",
+                                   timebuf, buf);
+                        }
+                    } else {
+                        node = SCRadixFindKeyIPV6Netblock((uint8_t *)ipv6_addr, ctx->tree, atoi(netmask_str), &user_data);
+                        if (node != NULL && user_data != NULL && ctx->passlist_dbg) {
+                            PrintInet(AF_INET6, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                            fprintf(ctx->dbgfile_ctx->fp, "%s  IPv6 netblock %s from Pass List lies within existing netblock entry %s/%d.\n",
+                                   timebuf, buf, ip_buffer, node->prefix->user_data->netmask);
+                            fflush(ctx->dbgfile_ctx->fp);
+                        }
+                    }
+
+                    /* check if current Pass List entry was covered
+                     * by an existing Radix Tree entry.
+                     */
+                    if (user_data != NULL) {
+                        covered++;
+                        SCFree(ipv6_addr);
+                        continue;
+                    }
+
+                    /* if we get here, then we are adding a new entry to the
+                     * Radix Tree, so create a "user_data" entry for this
+                     * Pass List item.
+                     */
+                    if ( (user_addr = SCCalloc(1, sizeof(Address))) == NULL) {
+                        SCLogError("Error allocating required user_data memory for Pass List IP entry %s. Skipping adding this entry to Pass List.", buf);
+                        continue;
+                        SCFree(ipv6_addr);
+                    }
+                    user_addr->family = AF_INET6;
+                    memcpy(user_addr->addr_data8, (uint8_t *)ipv6_addr, sizeof(struct in6_addr));
+
+                    /* we do not have an entry for this address in the Radix Tree, so add it */
+                    if (netmask_str == NULL || atoi(netmask_str) == 128) {
+                        SCRadixAddKeyIPV6((uint8_t *)ipv6_addr, ctx->tree, (void *)user_addr);
+                        if (ctx->passlist_dbg) {
+                            fprintf(ctx->dbgfile_ctx->fp, "%s  Added IPv6 address %s from Pass List to Radix Tree.\n",
+                                   timebuf, buf);
+                            fflush(ctx->dbgfile_ctx->fp);
+                        }
+                    } else {
+                        MaskIPNetblock((uint8_t *)ipv6_addr, netmask_value, 128);
+                        node = SCRadixAddKeyIPV6Netblock((uint8_t *)ipv6_addr, ctx->tree, (void *)user_addr, netmask_value);
+                        if (ctx->passlist_dbg) {
+                            PrintInet(AF_INET6, (const void *)ipv6_addr, ip_buffer, sizeof(ip_buffer));
+                            fprintf(ctx->dbgfile_ctx->fp, "%s  Added IPv6 netblock %s/%d to Radix Tree created from Pass List entry %s.\n",
+                                   timebuf, ip_buffer, netmask_value, buf);
+                        }
+                    }
+                    count++;
+                    SCFree(ipv6_addr);
+                    continue;
+                }
+            }
+            else if ((ipv4_addr = ValidateIPV4Address(ip_str)) != NULL) {
+                /* see if this address or netblock either already
+                 * exists in the Radix Tree, or is contained within
+                 * an existing netblock in the Radix Tree.
+                 */
+                if (netmask_str == NULL || atoi(netmask_str) == 32) {
+                    (void)SCRadixFindKeyIPV4ExactMatch((uint8_t *)ipv4_addr, ctx->tree, &user_data);
+                    if (user_data != NULL && ctx->passlist_dbg) {
+                        fprintf(ctx->dbgfile_ctx->fp, "%s  IPv4 address %s from Pass List exactly matches an existing entry, so not adding it again.\n",
+                              timebuf, buf);
+                    }
+                } else {
+                    node = SCRadixFindKeyIPV4Netblock((uint8_t *)ipv4_addr, ctx->tree, atoi(netmask_str), &user_data);
+                    if (node != NULL && user_data != NULL && ctx->passlist_dbg) {
+                        SCFree(ipv4_addr);
+                        PrintInet(AF_INET, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(ctx->dbgfile_ctx->fp, "%s  IPv4 netblock %s from Pass List lies within existing netblock entry %s/%d.\n",
+                               timebuf, buf, ip_buffer, node->prefix->user_data->netmask);
+                        fflush(ctx->dbgfile_ctx->fp);
+                    }
+                }
+
+                /* check if current Pass List entry was covered
+                 * by an existing Radix Tree entry.
+                 */
+                if (user_data != NULL) {
+                    covered++;
+                    SCFree(ipv4_addr);
+                    continue;
+                }
+
+                /* if we get here, then we are adding a new entry to the
+                 * Radix Tree, so create a "user_data" entry for this
+                 * Pass List item.
+                 */
+                if ( (user_addr = SCCalloc(1, sizeof(Address))) == NULL) {
+                    SCLogError("Error allocating required user_data memory for Pass List IP entry %s. Skipping adding this entry to Pass List.", buf);
+                    SCFree(ipv4_addr);
+                    continue;
+                }
+                user_addr->family = AF_INET;
+                memcpy(user_addr->addr_data32, (uint32_t *)ipv4_addr, sizeof(struct in_addr));
+
+                /* we do not have an entry for this address in the Radix Tree, so add it */
+                if (netmask_str == NULL || atoi(netmask_str) == 32) {
+                    SCRadixAddKeyIPV4((uint8_t *)ipv4_addr, ctx->tree, (void *)user_addr);
+                    if (ctx->passlist_dbg) {
+                        fprintf(ctx->dbgfile_ctx->fp, "%s  Added IPv4 address %s from Pass List.\n",
+                               timebuf, buf);
+                        fflush(ctx->dbgfile_ctx->fp);
+                    }
+                } else {
+                    MaskIPNetblock((uint8_t *)ipv4_addr, netmask_value, 32);
+                    node = SCRadixAddKeyIPV4Netblock((uint8_t *)ipv4_addr, ctx->tree, (void *)user_addr, netmask_value);
+                    if (ctx->passlist_dbg) {
+                            PrintInet(AF_INET, (const void *)ipv4_addr, ip_buffer, sizeof(ip_buffer));
+                            fprintf(ctx->dbgfile_ctx->fp, "%s  Added IPv4 netblock %s/%d to Radix Tree created from Pass List entry %s.\n",
+                                   timebuf, ip_buffer, netmask_value, buf);
+                    }
+                }
+                count++;
+                SCFree(ipv4_addr);
+                continue;
+            }
+            else {
+                /* not a valid IPv4 or IPv6 string, so test as FQDN or URL Table Alias */
+                if (AlertPfTableExists(buf) == 1) {
+                    /* Allocate and add a new FQDN alias pass list item */
+                    fqdnwl = SCCalloc(1, sizeof(struct fqdn_wlist));
+                    if (fqdnwl == NULL) {
+                        SCLogWarning("Could not allocate linked-list element memory for pf alias table entry '%s' in Pass List, skipping this line.", buf);
+                        continue;
+                    }
+                    strlcpy(fqdnwl->apf_alias_tblname, buf, PF_TABLE_NAME_SIZE); 
+                    SLIST_INSERT_HEAD(&ctx->head, fqdnwl, elem);
+                    if (ctx->passlist_dbg) {
+                        fprintf(ctx->dbgfile_ctx->fp, "%s  Added pf table alias '%s' from Pass List.\n",
+                               timebuf, buf);
+                        fflush(ctx->dbgfile_ctx->fp);
+                    }
+                    count++;
+                }
+                else {
+                    SCLogWarning("Parameter '%s' supplied in the Pass List is neither a valid IP address nor an existing pf alias table name, skipping this entry.", buf);
+                }
+            }
+        } else if (ret == -1)
+            /* an error occurred reading the current line in Pass List */
+            SCLogWarning("Error occurred parsing line (%s) in Pass List, skipping this line.", buf);
+    }
+
+    SCRWLockUnlock(&ctx->rwlock_tree);
+    SCRWLockUnlock(&ctx->rwlock_wlist);
+
+    lock.l_type = F_UNLCK;
+    fcntl(fileno(wfile), F_SETLKW, &lock);
+    fclose(wfile);
+
+    /* flush and unlock the Pass List debug log if enabled */
+    if (ctx->passlist_dbg) {
+        gettimeofday(&tval, NULL);
+        SCTime_t ts = SCTIME_FROM_TIMEVAL(&tval);
+        CreateTimeString(ts, timebuf, sizeof(timebuf));
+        fprintf(ctx->dbgfile_ctx->fp, "%s  Completed processing Pass List %s. Total entries parsed: %d, Unique IP addresses/netblocks/aliases added to Radix Tree: %d, IP addresses/netblocks ignored because they were covered by existing Radix Tree entries: %d.\n\n",
+              timebuf, plfile, parsed, count, covered);
+        fflush(ctx->dbgfile_ctx->fp);
+        SCMutexUnlock(&ctx->dbgfile_ctx->fp_mutex);
+    }
+
+    SCLogInfo("Pass List %s processed: Total entries parsed: %d, IP addresses/netblocks/aliases added to No Block list: %d, IP addresses/netblocks ignored because they were covered by existing entries: %d.",
+              plfile, parsed, count, covered);
+    return (-1);
+}
+
+/** \brief Grab all firewall interface addresses and insert
+ *   the IP addresses into a Radix Tree for easy searching.
+ *  \param *ctx pointer to AlertPfCtx global data structure
+ *  \retval false (0) if error, true (-1) if success
+ */
+static int AlertPfInitIfaceList(AlertPfCtx *ctx)
+{
+    struct ifaddrs *ifap, *ifa;
+    Address *user_addr = NULL;
+    char tmp[46];
+
+    /* If we don't have a valid Radix Tree, then exit. */
+    if (ctx->tree == NULL) {
+        SCLogInfo("No valid Radix Tree available. Pass List functionality is disabled!");
+        return -1;
+    }
+
+    if (getifaddrs(&ifap) == 0) {
+        SCLogInfo("Creating automatic firewall interface IP address Pass List.");
+
+        /* Lock the Radix Tree while we are updating it */
+        SCRWLockWRLock(&ctx->rwlock_tree);
+
+        for (ifa = ifap; ifa != NULL; ifa = ifa->ifa_next) {
+            if (ifa->ifa_addr) {
+
+                switch (ifa->ifa_addr->sa_family) {
+                    case AF_INET:
+                        /* create a "user_data" entry for this Pass List item */
+                        if ( (user_addr = SCCalloc(1, sizeof(struct in_addr))) == NULL) {
+                            FatalError("Failed allocating memory in AlertPfInitIfaceList() for Radix Tree user data entry. Exiting...");
+                        }
+
+                        user_addr->family = AF_INET;
+                        memcpy(user_addr->addr_data32, &((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr, sizeof(struct in_addr));
+                        PrintInet(AF_INET, (const void *)&((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr, tmp, sizeof(tmp));
+                        SCLogInfo("Adding firewall interface %s IPv4 address %s to automatic interface IP Pass List.", ifa->ifa_name, tmp);
+                        SCRadixAddKeyIPV4((uint8_t *)(&((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr), ctx->tree, user_addr);
+                    break;
+
+                    case AF_INET6:
+                        /* create a "user_data" entry for this Pass List item */
+                        if ( (user_addr = SCCalloc(1, sizeof(struct in6_addr))) == NULL) {
+                            FatalError("Failed allocating memory in AlertPfInitIfaceList() for Radix Tree user data entry. Exiting...");
+                        }
+
+                        user_addr->family = AF_INET6;
+                        memcpy(user_addr->addr_data8, &((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr.s6_addr, sizeof(struct in6_addr));
+                        PrintInet(AF_INET6, (const void *)&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr.s6_addr, tmp, sizeof(tmp));
+                        SCLogInfo("Adding firewall interface %s IPv6 address %s to automatic interface IP Pass List.", ifa->ifa_name, tmp);
+                        SCRadixAddKeyIPV6((uint8_t *)(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr.s6_addr), ctx->tree, user_addr);
+                        break;
+
+                    default:
+                        continue;
+                }
+            }
+        }
+
+        /* Finished updating the Radix Tree, so release our Write lock */
+        SCRWLockUnlock(&ctx->rwlock_tree);
+        freeifaddrs(ifap);
+        return -1;
+    }
+    else
+        return 0;
+}
+
+/** \brief Parse an if_addr RTM structure to grab the IP address
+ *   and write it into the passed Address structure.
+ *  \param *sa pointer to if_addr data sockaddr structure from Kernel routing message
+ *  \param *ip pointer to Address structure to receive IP address
+ *  \retval false (0) if error, true (-1) if success
+ */
+static int AlertPfParseIfamAddress(struct sockaddr *sa, Address *ip)
+{
+    if (sa == NULL) {
+        return 0;
+    }
+
+    switch (sa->sa_family) {
+        case AF_INET:
+            if (((struct sockaddr_in *)(void *)sa)->sin_addr.s_addr == INADDR_ANY) {
+                return 0;
+            }
+            ip->family = AF_INET;
+            memcpy(&ip->addr_data32, &((struct sockaddr_in *)(void *)sa)->sin_addr.s_addr, sizeof(ip->addr_data32));
+            return 1;
+
+        case AF_INET6:
+            if (IN6_IS_ADDR_UNSPECIFIED(&((struct sockaddr_in6 *)(void *)sa)->sin6_addr)) {
+                return 0;
+            }
+            ip->family = AF_INET6;
+            memcpy(&ip->addr_data8, &((struct sockaddr_in6 *)(void *)sa)->sin6_addr.s6_addr, sizeof(ip->addr_data8));
+            return 1;
+
+        default:
+            break;
+    }
+
+    return 0;
+}
+
+/** \brief Add/remove interface IP address from Radix tree
+ *  \param *ip pointer to Address structure containing IP address
+ *  \param *ctx pointer to AlertPfCtx global data structure
+ *  \param action value from Kernel Routing Message
+ */
+static void AlertPf_IflistMaint(Address *ip, AlertPfCtx *ctx, u_char action)
+{
+	char tmp[46];
+    void *user_data = NULL;
+    Address *user_addr = NULL;
+
+    // Validate passed pointers
+    if (ip == NULL || ctx == NULL)
+        return;
+
+    // Validate Radix Tree exists
+    if (ctx->tree == NULL)
+        return;
+
+    switch (action) {
+        case RTM_NEWADDR:
+            // Check if new address already in list
+            if (ip->family == AF_INET) {
+                SCRWLockRDLock(&ctx->rwlock_tree);
+                (void)SCRadixFindKeyIPV4ExactMatch((uint8_t *)&ip->addr_data32, ctx->tree, &user_data);
+                SCRWLockUnlock(&ctx->rwlock_tree);
+                if (user_data == NULL) {
+                    /* Not already in list, so add it. First create
+                     * a 'user_data' entry for this Pass List item
+                     */
+                    if ( (user_addr = SCCalloc(1, sizeof(struct in_addr))) == NULL) {
+                        FatalError("Failed allocating memory in AlertPf_IflistMaint() for Radix Tree user data entry. Exiting...");
+                    }
+                    COPY_ADDRESS(ip, user_addr);
+                    SCRWLockWRLock(&ctx->rwlock_tree);
+                    SCRadixAddKeyIPV4((uint8_t *)&ip->addr_data32, ctx->tree, user_addr);
+                    SCRWLockUnlock(&ctx->rwlock_tree);
+                    PrintInet(AF_INET, (const void *)&ip->addr_data32, tmp, sizeof(tmp));
+                    SCLogInfo("Added address %s to automatic firewall interface IP Pass List.", tmp);
+                }
+            }
+            else if (ip->family == AF_INET6) {
+                SCRWLockRDLock(&ctx->rwlock_tree);
+                (void)SCRadixFindKeyIPV6ExactMatch((uint8_t *)&ip->addr_data8, ctx->tree, &user_data);
+                SCRWLockUnlock(&ctx->rwlock_tree);
+                if (user_data == NULL) {
+                    /* Not already in list, so add it. First create
+                     * a 'user_data' entry for this Pass List item
+                     */
+                    if ( (user_addr = SCCalloc(1, sizeof(struct in6_addr))) == NULL) {
+                        FatalError("Failed allocating memory in AlertPf_IflistMaint() for Radix Tree user data entry. Exiting...");
+                    }
+                    COPY_ADDRESS(ip, user_addr);
+                    SCRWLockWRLock(&ctx->rwlock_tree);
+                    SCRadixAddKeyIPV6((uint8_t *)&ip->addr_data8, ctx->tree, user_addr);
+                    SCRWLockUnlock(&ctx->rwlock_tree);
+                    PrintInet(AF_INET6, (const void *)&ip->addr_data8, tmp, sizeof(tmp));
+                    SCLogInfo("Added address %s to automatic firewall interface IP Pass List.", tmp);
+                }
+            }
+            break;
+
+        case RTM_DELADDR:
+            // Delete the passed IP address only if it is in our IP List
+            if (ip->family == AF_INET) {
+                SCRWLockRDLock(&ctx->rwlock_tree);
+                (void)SCRadixFindKeyIPV4ExactMatch((uint8_t *)&ip->addr_data32, ctx->tree, &user_data);
+                SCRWLockUnlock(&ctx->rwlock_tree);
+                if (user_data != NULL) {
+                    // In list, so delete it
+                    SCRWLockWRLock(&ctx->rwlock_tree);
+                    SCRadixRemoveKeyIPV4((uint8_t *)&ip->addr_data32, ctx->tree);
+                    SCRWLockUnlock(&ctx->rwlock_tree);
+                    PrintInet(AF_INET, (const void *)&ip->addr_data32, tmp, sizeof(tmp));
+                    SCLogInfo("Deleted address %s from automatic firewall interface IP Pass List.", tmp);
+                }
+            }
+            else if (ip->family == AF_INET6) {
+                (void)SCRadixFindKeyIPV6ExactMatch((uint8_t *)&ip->addr_data8, ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    // In list, so delete it
+                    SCRWLockWRLock(&ctx->rwlock_tree);
+                    SCRadixRemoveKeyIPV6((uint8_t *)&ip->addr_data8, ctx->tree);
+                    SCRWLockUnlock(&ctx->rwlock_tree);
+                    PrintInet(AF_INET6, (const void *)&ip->addr_data8, tmp, sizeof(tmp));
+                    SCLogInfo("Deleted address %s from automatic firewall interface IP Pass List.", tmp);
+                }
+            }
+            break;
+
+        default:
+            SCLogWarning("AlertPf_IflistMaint(): received unrecognized action parameter.");
+            return;
+    }
+
+    return;
+}
+
+/**
+ * This initializes the data for a new thread.
+ */
+TmEcode AlertPfThreadInit(ThreadVars *t, const void *initdata, void **data)
+{
+    AlertPfThread *apft;
+
+    if(initdata == NULL)
+    {
+        SCLogDebug("Error getting context for Alert-PF.  \"initdata\" argument NULL");
+        return TM_ECODE_FAILED;
+    }
+
+    apft = SCCalloc(1, sizeof(AlertPfThread));
+
+    if (unlikely(apft == NULL))
+        return TM_ECODE_FAILED;
+    memset(apft, 0, sizeof(AlertPfThread));
+
+    /* Use the Ouput Context */
+    apft->ctx = ((OutputCtx *)initdata)->data;
+
+    /* Open the pf device */
+    apft->fd = AlertPfDeviceInit();
+    if (apft->fd == -1) {
+        SCLogError("Failed to open the pf device, alert-pf module thread init failed.");
+        return TM_ECODE_FAILED;
+    }
+
+    *data = (void *)apft;
+    return TM_ECODE_OK;
+}
+
+/**
+ * This clears and releases the data for a thread.
+ */
+TmEcode AlertPfThreadDeinit(ThreadVars *t, void *data)
+{
+    AlertPfThread *apft = (AlertPfThread *)data;
+
+    if (apft == NULL) {
+        SCLogDebug("AlertPfThreadDeinit() done (error)");
+        return TM_ECODE_FAILED;
+    }
+
+    /* Close the pf device */
+    close(apft->fd);
+
+    /* Free our local thread memory */
+    SCFree(apft);
+
+    return TM_ECODE_OK;
+}
+
+/** \brief Print the pf alert module blocking stats.
+ *  \param *tv pointer to ThreadVars structure
+ *  \param *data pointer to AlertPfThread structure
+ */
+void AlertPfExitPrintStats(ThreadVars *tv, void *data)
+{
+    AlertPfThread *apft = (AlertPfThread *)data;
+    if (apft == NULL) {
+        return;
+    }
+
+    uint64_t blocks = SC_ATOMIC_GET(alert_pf_blocks);
+    uint64_t alerts = SC_ATOMIC_GET(alert_pf_alerts);
+    if (blocks == 1)
+        SCLogInfo("Inserted %" PRIu64 " IP address block", blocks);
+    else
+        SCLogInfo("Inserted %" PRIu64 " IP address blocks", blocks);
+
+    if (alerts == 1)
+        SCLogInfo("Processed %" PRIu64 " alert", alerts);
+    else
+        SCLogInfo("Processed %" PRIu64 " alerts", alerts);
+}
+
+/** \brief Thread for monitoring firewall interface IP address changes.
+ *  \param *args pointer to global AlertPfCtx structure
+ */
+void *AlertPfMonitorIfaceChanges(void *args)
+{
+    int sock = -1;
+    int fib = RT_ALL_FIBS;
+    size_t fib_len = sizeof(fib);
+    size_t len;
+    char msg[MAX_RTMSG_SIZE];
+    char ifname[IFNAMSIZ];
+    char *p;
+    Address addr;
+    struct rt_msghdr *rtm;
+    struct ifa_msghdr *ifam;
+    struct sockaddr *sa;
+
+    AlertPfCtx *ctx = args;
+
+    sock = socket(PF_ROUTE, SOCK_RAW, AF_UNSPEC);
+    if (sock == -1) {
+        SCLogWarning("Failed to create routing messages socket(PF_ROUTE): %s.  Dynamic IP changes on firewall interfaces will not be monitored!", strerror(errno));
+        return (NULL);
+    }
+
+    pthread_setname_np(pthread_self(), "IM#01");
+    SCLogInfo("Firewall Interface IP Address Change monitoring thread IM#01 has successfully started.");
+
+    if (sysctlbyname("net.my_fibnum", &fib, &fib_len, NULL, 0) < 0)
+    {  
+        SCLogWarning("Failed to obtain active route table FIB so using all FIBs by default.");
+        fib = RT_ALL_FIBS;
+    }
+    setsockopt(sock, SOL_SOCKET, SO_SETFIB, (void *)&fib, sizeof(fib));
+
+    // Loop forever receiving and handling kernel RTM messages
+    for (;;) {
+ 
+        /* exit if Suricata is shutting down */
+        if (unlikely(suricata_ctl_flags != 0)) {
+            break;
+        }
+
+        len = read(sock, &msg, sizeof(msg));
+
+        // Disregard any route message not of the size we require
+        if (len < sizeof(struct ifa_msghdr))
+            continue;
+        else
+            len -= sizeof(struct ifa_msghdr);
+
+        rtm = (struct rt_msghdr *)msg;
+        if (rtm->rtm_version != RTM_VERSION)
+            continue;
+
+        ifam = (struct ifa_msghdr *)msg;
+
+        switch (rtm->rtm_type) {
+            case RTM_NEWADDR:
+            case RTM_DELADDR:
+                // Make sure all address info we need is present in the message by checking the RTAX flags.
+                if (ifam->ifam_addrs & (RTAX_NETMASK | RTAX_IFP | RTAX_IFA | RTAX_BRD)) {
+
+                    // Get the interface address that is changing (will be third sockaddr in msg)
+                    p = (char *)(ifam + 1);
+                    p += SA_SIZE((struct sockaddr *)p);
+                    len -= SA_SIZE((struct sockaddr *)p);
+                    p += SA_SIZE((struct sockaddr *)p);
+                    len -= SA_SIZE((struct sockaddr *)p);
+                    sa = (struct sockaddr *)p;
+
+                    // If we've run out of data, skip this message as something is amiss
+                    if (len == 0 || len < SA_SIZE(sa))
+                        continue;
+
+                    // Zero out our Address structure prior to each call to parse it
+                    addr.family = 0;
+                    addr.addr_data32[0] = 0;
+                    addr.addr_data32[1] = 0;
+                    addr.addr_data32[2] = 0;
+                    addr.addr_data32[3] = 0;
+
+                    // Make sure we have a valid non-zero IP address in that sockaddr structure
+                    if (!AlertPfParseIfamAddress(sa, &addr)) {
+                        SCLogDebug("Firewall interface IP change notification thread received an invalid IP address via kernel routing message socket.");
+                        continue;
+                    }
+
+                    // OK, now either delete it from or add it to the interface IP list
+                    SCLogInfo("Received notification of IP address change on firewall interface %s.", if_indextoname(ifam->ifam_index, ifname));
+                    AlertPf_IflistMaint(&addr, ctx, rtm->rtm_type);
+                }
+                continue;
+
+            default:
+                continue;
+        }
+    }
+
+    SCLogInfo("Firewall Interface IP Address Change monitoring thread IM#01 shutting down.");
+    return (NULL);
+}
+
+/** \brief Initialize the pf alert blocking module.
+ *  \param *conf pointer to module's ConfNode structure
+ * \return A newly allocated AlertPfCtx structure, or NULL
+ */
+OutputInitResult AlertPfInitCtx(ConfNode *conf)
+{
+    AlertPfCtx *ctx;
+    OutputInitResult result = { NULL, false };
+    LogFileCtx *logfile_ctx;
+    LogFileCtx *dbgfile_ctx;
+    const char *pass_list_name;
+    const char *kill_state;
+    const char *block_ip;
+    const char *block_drops;
+    const char *pf_table;
+    const char *passlist_dbg;
+    OutputCtx *output_ctx;
+
+    pass_list_name = ConfNodeLookupChildValue(conf, "pass-list");
+    if (pass_list_name == NULL) {
+        SCLogWarning("No Pass List was specified. Local hosts may get blocked.");
+    }
+
+    kill_state = ConfNodeLookupChildValue(conf, "kill-state");
+    block_ip = ConfNodeLookupChildValue(conf, "block-ip");
+    pf_table = ConfNodeLookupChildValue(conf, "pf-table");
+    block_drops = ConfNodeLookupChildValue(conf, "block-drops-only");
+    passlist_dbg = ConfNodeLookupChildValue(conf, "passlist-debugging");
+
+    if (unlikely(pf_table == NULL)) {
+        FatalError("alert-pf -> No PF table name specified, module init failed.");
+    }
+
+    ctx = SCCalloc(1, sizeof(AlertPfCtx));
+    if (unlikely(ctx == NULL)) {
+        FatalError("alert-pf -> Unable to allocate memory for AlertPfCtx, module init failed.");
+    }
+
+    /* Create a Radix Tree to hold PASS LIST IP addresses */
+    ctx->tree = SCRadixCreateRadixTree(AlertPfFreeUserData, NULL);
+    if (unlikely(ctx->tree == NULL))
+        SCLogWarning("Failed to create Radix Tree for IP address lookups.  Pass List functionality is auto-disabled!");
+
+    /* Initialize a RWLock for the Radix Tree to control concurrent updates and reads */
+	if (ctx->tree)
+        SCRWLockInit(&ctx->rwlock_tree, NULL);
+
+    /* Initialize our FQDN Alias pass list */
+	SLIST_INIT(&ctx->head);
+
+    /* Initialize a RWLock for the FQDN Pass List to control concurrent updates and reads */
+    SCRWLockInit(&ctx->rwlock_wlist, NULL);
+
+    /* Grab all firewall interface IP addresses and save in Radix Tree */
+    if (!AlertPfInitIfaceList(ctx))
+        SCLogWarning("Failed to create the list of firewall interface addresses for auto-whitelisting.");
+
+    /* Create a LogFileCtx for the block.log output */
+    logfile_ctx = LogFileNewCtx();
+    if (logfile_ctx == NULL) {
+        SCLogDebug("AlertPfInitCtx(): Could not create new LogFileCtx for %s", DEFAULT_LOG_FILENAME);
+        SCFree(ctx);
+        return result;
+    }
+    if (SCConfLogOpenGeneric(conf, logfile_ctx, DEFAULT_LOG_FILENAME, 1) < 0) {
+        LogFileFreeCtx(logfile_ctx);
+        SCLogDebug("AlertPfInitCtx(): Could not open log file %s specified by LogFileCtx, DEFAULT_LOG_FILENAME");
+        SCFree(ctx);
+        return result;
+    }
+    ctx->file_ctx = logfile_ctx;
+
+    if (passlist_dbg && ConfValIsTrue(passlist_dbg)) {
+
+        /* Create a LogFileCtx for the Pass List Debug output if enabled */
+        dbgfile_ctx = LogFileNewCtx();
+        if (dbgfile_ctx == NULL) {
+            SCLogDebug("AlertPfInitCtx: Could not create new LogFileCtx for %s", DEFAULT_DEBUG_LOG_FILENAME);
+            LogFileFreeCtx(logfile_ctx);
+            SCFree(ctx);
+            return result;
+        }
+        if (SCConfLogOpenGeneric(conf, dbgfile_ctx, DEFAULT_DEBUG_LOG_FILENAME, 1) < 0) {
+            SCLogDebug("AlertPfInitCtx: Could not open Pass List debug log file %s specified by LogFileCtx", DEFAULT_DEBUG_LOG_FILENAME);
+            LogFileFreeCtx(dbgfile_ctx);
+            LogFileFreeCtx(logfile_ctx);
+            SCFree(ctx);
+            return result;
+        }
+        SCLogInfo("Enabling Pass List debugging output to file %s.", dbgfile_ctx->filename);
+        ctx->passlist_dbg = 1;
+        ctx->dbgfile_ctx = dbgfile_ctx;
+    } else {
+        ctx->passlist_dbg = 0;
+    }
+
+    /* Parse the remaining arguments for this plugin from */
+    /* the suricata.yaml conf file.                       */
+    ctx->kill_state = 1;
+    if (kill_state == NULL) {
+        SCLogWarning("kill-state parameter value not recognized, defaulting to 'yes'.");
+    }
+    if (kill_state && ConfValIsFalse(kill_state))
+        ctx->kill_state = 0;
+
+    ctx->block_drops = 0;
+    if (block_drops == NULL) {
+        SCLogWarning("block-drops-only parameter value not recognized, defaulting to 'no'.");
+    }
+    if (block_drops && ConfValIsTrue(block_drops))
+        ctx->block_drops = 1;
+
+    if (block_ip == NULL) {
+        SCLogWarning("block-ip parameter value not recognized, defaulting to 'both'.");
+    }
+    if (block_ip && !strncasecmp("src", block_ip, strlen("src")))
+        ctx->block_ip = BLOCK_SRC;
+    else if (block_ip && !strncasecmp("dst", block_ip, strlen("dst")))
+        ctx->block_ip = BLOCK_DST;
+    else
+        ctx->block_ip = BLOCK_BOTH;
+
+    if (pass_list_name) {
+        if (!AlertPfLoadPassList(pass_list_name, ctx)) {
+            SCLogWarning("Supplied Pass List file was not successfully processed! Local host IPs may be blocked.");
+        }
+    }
+
+    strlcpy(ctx->pftable, pf_table, PF_TABLE_NAME_SIZE);
+
+    if (AlertPfTableExists(ctx->pftable) != 1) {
+        LogFileFreeCtx(logfile_ctx);
+        LogFileFreeCtx(dbgfile_ctx);
+        SCFree(ctx);
+        FatalError("alert-pf -> Could not validate pf table name exists: %s, module init failed.", pf_table);
+    }
+
+    output_ctx = SCCalloc(1, sizeof(OutputCtx));
+    if (unlikely(output_ctx == NULL)) {
+        LogFileFreeCtx(logfile_ctx);
+        LogFileFreeCtx(dbgfile_ctx);
+        SCFree(ctx);
+        FatalError("alert-pf -> Unable to allocate memory for Logging OutputCtx, module init failed.");
+    }
+    output_ctx->data = ctx;
+    output_ctx->DeInit = AlertPfDeInitCtx;
+    SC_ATOMIC_INIT(alert_pf_blocks);
+    SC_ATOMIC_INIT(alert_pf_alerts);
+
+    const char *block;
+    switch (ctx->block_ip) {
+        case BLOCK_SRC:
+            block = "src";
+            break;
+
+        case BLOCK_DST:
+            block = "dst";
+            break;
+
+        default:
+            block = "both";
+    }
+
+    /* Set defaults for any missing conf arguments */
+    const char *state = ctx->kill_state ? "yes" : "no";
+    const char *drops = ctx->block_drops ? "yes" : "no";
+    const char *plist_dbg = ctx->passlist_dbg ? "yes" : "no";
+
+    /* start iface monitoring thread only if we have a valid Radix Tree */
+    if (ctx->tree) {
+        if (pthread_create(&alert_pf_ifmon_thread, NULL, AlertPfMonitorIfaceChanges, ctx))
+            SCLogError("Failed to create Interface IP Address change monitoring thread for 'alert-pf' output plugin.");
+        else
+            SCLogInfo("Created Firewall Interface IP Change monitor thread for auto-whitelisting of firewall interface IP addresses.");
+    }
+
+    SCLogInfo("pfSense Suricata Custom Blocking Module initialized: pf-table=%s  block-ip=%s  kill-state=%s  block-drops-only=%s  passlist-debugging=%s", ctx->pftable, block, state, drops, plist_dbg);
+
+    result.ctx = output_ctx;
+    result.ok = true;
+    return result;
+}
+
+/** \brief This releases memory used by global FQDN Pass List linked list.
+ *  \param *wl wlist_head
+ */
+static void AlertPfFreeWlist(struct wlist_head *wl)
+{
+    struct fqdn_wlist *n1;
+
+    /* Release memory used by our FQDN Pass List */
+    while (!SLIST_EMPTY(wl)) {
+        n1	= SLIST_FIRST(wl);
+        SLIST_REMOVE_HEAD(wl, elem);
+        SCFree(n1);
+    }
+}
+
+/** \brief This releases the memory used by the global
+ * AlertPfCtx data structure.
+ */
+static void AlertPfDeInitCtx(OutputCtx *output_ctx)
+{
+    AlertPfCtx *ctx = (AlertPfCtx *)output_ctx->data;
+    LogFileFreeCtx(ctx->file_ctx);
+    LogFileFreeCtx(ctx->dbgfile_ctx);
+    SCRadixReleaseRadixTree(ctx->tree);
+    SCRWLockDestroy(&ctx->rwlock_tree);
+    AlertPfFreeWlist(&ctx->head);
+    SCRWLockDestroy(&ctx->rwlock_wlist);
+    SCFree(ctx);
+    SCFree(output_ctx);
+}
+
+/** \brief This searches any FQDN or URL Table Aliases loaded from
+ * the Pass List for a match to the passed IP address.
+ *  \param *apft pointer to AlertPf thread data
+ *  \param *ip uint8_t pointer to IP address to match
+ *  \paran family is IP address type (AF_INET or AF_INET6)
+ *  \return true if IP match found in table alias list
+ */
+static bool AlertPfMatchFQDN(AlertPfThread *apft, uint8_t *ip, char family) {
+
+    struct fqdn_wlist *p1;	
+    struct pfioc_table io; 
+    struct pfr_table table; 
+    struct pfr_addr addr; 
+
+    /* Iterate the table aliases in our list searching for IP match */
+    SLIST_FOREACH(p1, &apft->ctx->head, elem) {
+        /* Initialize parameters for system ioctl() call */
+        memset(&io,    0x00, sizeof(struct pfioc_table)); 
+        memset(&table, 0x00, sizeof(struct pfr_table)); 
+        memset(&addr,  0x00, sizeof(struct pfr_addr)); 
+        strlcpy(table.pfrt_name, (const char *)&p1->apf_alias_tblname, PF_TABLE_NAME_SIZE); 
+        family == AF_INET ? memcpy(&addr.pfra_ip4addr.s_addr, ip, sizeof(in_addr_t)) : memcpy(&addr.pfra_ip6addr, ip, sizeof(struct in6_addr));
+        addr.pfra_af  = family; 
+        addr.pfra_net = family == AF_INET ? 32 : 128;
+        io.pfrio_table  = table; 
+        io.pfrio_buffer = &addr; 
+        io.pfrio_esize  = sizeof(addr); 
+        io.pfrio_size   = 1;
+
+        /* Query packet filter for any IP match in this table entry */
+        if (ioctl(apft->fd, DIOCRTSTADDRS, &io)) {
+            /* An error occurred. Ignore or log it depending on cause */
+            if (AlertPfTableExists(p1->apf_alias_tblname) == 0) {
+                /* the FQDN alias must have been deleted, so ignore previous error */
+                continue;
+            }
+            else {
+                /* some other error occurred, so log it */
+                SCLogWarning("AlertPfMatchFQDN(): ioctl() DIOCRTSTADDRS: %s. Failed testing for matching IP in alias %s from Pass List.", strerror(errno), p1->apf_alias_tblname);
+                continue;
+            }
+        }
+        if (addr.pfra_fback == PFR_FB_MATCH)
+            return true;
+    }
+    return false;
+}
+
+/** \brief This processes an IPv4 alert and inserts the appropriate
+ * block if the IP address is not on the Pass List.
+ */
+static TmEcode AlertPfIPv4(ThreadVars *tv, void *data, const Packet *p)
+{
+    AlertPfThread *apft = (AlertPfThread *)data;
+    int i;
+    char proto[16] = "";
+    char timebuf[64], ip_buffer[INET_ADDRSTRLEN + 4];
+    char srcip[INET_ADDRSTRLEN], dstip[INET_ADDRSTRLEN];
+
+    if (p->alerts.cnt == 0)
+        return TM_ECODE_OK;
+
+    /* create a time string from the packet's timestamp for the block log */
+    CreateTimeString(p->ts, timebuf, sizeof(timebuf));
+    PrintInet(AF_INET, (const void *)GET_IPV4_SRC_ADDR_PTR(p), srcip, sizeof(srcip));
+    PrintInet(AF_INET, (const void *)GET_IPV4_DST_ADDR_PTR(p), dstip, sizeof(dstip));
+
+    if (SCProtoNameValid(IPV4_GET_IPPROTO(p)) == TRUE) {
+        strlcpy(proto, known_proto[IPV4_GET_IPPROTO(p)], sizeof(proto));
+    } else {
+        snprintf(proto, sizeof(proto), "PROTO:%03" PRIu32, IPV4_GET_IPPROTO(p));
+    }
+
+    /* A packet can generate multiple alerts, so walk the list */
+    for (i = 0; i < p->alerts.cnt; i++) {
+        const PacketAlert *pa = &p->alerts.alerts[i];
+        if (unlikely(pa->s == NULL)) {
+            continue;
+        }
+
+        /* Don't block on alerts where SIG_FLAG_NOALERT is set for the Signature */
+        if (pa->s->flags & SIG_FLAG_NOALERT) {
+            continue;
+        }
+        SC_ATOMIC_ADD(alert_pf_alerts, 1);
+
+        /* If blocking only DROP rules and alert is not from a DROP rule, ignore it */
+        if (apft->ctx->block_drops && !(PacketCheckAction(p, ACTION_DROP))) {
+            continue;
+        }
+
+        void *user_data = NULL;
+        SCRadixNode *node = NULL;
+
+        /* Read Lock the Radix Tree and FQDN Pass List while we are searching them */
+        SCRWLockRDLock(&apft->ctx->rwlock_tree);
+        SCRWLockRDLock(&apft->ctx->rwlock_wlist);
+
+        switch (apft->ctx->block_ip) {
+            case BLOCK_BOTH:
+                /* Block only if IP is not in Pass List */
+                node = SCRadixFindKeyIPV4BestMatch((uint8_t *)GET_IPV4_SRC_ADDR_PTR(p), apft->ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        PrintInet(AF_INET, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s covered by Pass List entry %s/%d - not blocking.\n",
+                              timebuf, tv->name, srcip, ip_buffer, node->prefix->user_data->netmask);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    goto Check_IPv4_DST;
+                }
+
+                /* check our FQDN alias pass list for this SRC IP */
+                if (!AlertPfMatchFQDN(apft, (uint8_t *)GET_IPV4_SRC_ADDR_PTR(p), AF_INET)) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s did not match any Pass List entry, so adding to block list.\n",
+                              timebuf, tv->name, srcip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    if (AlertPfBlock(tv, apft, &p->src) > 0) {
+                        SCMutexLock(&apft->ctx->file_ctx->fp_mutex);
+                        fprintf(apft->ctx->file_ctx->fp, "%s  [Block Src] [**] [%" PRIu32 ":%" PRIu32 ":%"
+                              PRIu32 "] %s [**] [Classification: %s] [Priority: %"PRIu32"]"
+                              " {%s} %s:%" PRIu32 "\n", timebuf, pa->s->gid,
+                              pa->s->id, pa->s->rev, pa->s->msg, pa->s->class_msg, pa->s->prio,
+                              proto, srcip, p->sp);
+                        fflush(apft->ctx->file_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->file_ctx->fp_mutex);
+                    }
+                } else {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s matched a URL Table Alias IP or FQDN IP Pass List entry - not blocking.\n",
+                              timebuf, tv->name, srcip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                }
+
+    Check_IPv4_DST:
+                user_data = NULL;
+                node = SCRadixFindKeyIPV4BestMatch((uint8_t *)GET_IPV4_DST_ADDR_PTR(p), apft->ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        PrintInet(AF_INET, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s covered by Pass List entry %s/%d - not blocking.\n",
+                              timebuf, tv->name, dstip, ip_buffer, node->prefix->user_data->netmask);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    break;
+                }
+
+                /* check our FQDN alias pass list for this DST IP */
+                if (!AlertPfMatchFQDN(apft, (uint8_t *)GET_IPV4_DST_ADDR_PTR(p), AF_INET)) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s did not match any Pass List entry, so adding to block list.\n",
+                              timebuf, tv->name, dstip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    if (AlertPfBlock(tv, apft, &p->dst) > 0) {
+                        SCMutexLock(&apft->ctx->file_ctx->fp_mutex);
+                        fprintf(apft->ctx->file_ctx->fp, "%s  [Block Dst] [**] [%" PRIu32 ":%" PRIu32 ":%"
+                              PRIu32 "] %s [**] [Classification: %s] [Priority: %"PRIu32"]"
+                              " {%s} %s:%" PRIu32 "\n", timebuf, pa->s->gid,
+                              pa->s->id, pa->s->rev, pa->s->msg, pa->s->class_msg, pa->s->prio,
+                              proto, dstip, p->dp);
+                        fflush(apft->ctx->file_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->file_ctx->fp_mutex);
+                    }
+                } else {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s matched a URL Table Alias IP or FQDN IP Pass List entry - not blocking.\n",
+                              timebuf, tv->name, dstip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                }
+                break;
+
+            case BLOCK_SRC:
+                /* Block SRC only if IP is not in Pass List */
+                node = SCRadixFindKeyIPV4BestMatch((uint8_t *)GET_IPV4_SRC_ADDR_PTR(p), apft->ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        PrintInet(AF_INET, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s covered by Pass List entry %s/%d - not blocking.\n",
+                              timebuf, tv->name, srcip, ip_buffer, node->prefix->user_data->netmask);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    break;
+                }
+
+                /* check our FQDN alias pass list for this SRC IP */
+                if (!AlertPfMatchFQDN(apft, (uint8_t *)GET_IPV4_SRC_ADDR_PTR(p), AF_INET)) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s did not match any Pass List entry, so adding to block list.\n",
+                              timebuf, tv->name, srcip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    if (AlertPfBlock(tv, apft,&p->src) > 0) {
+                        SCMutexLock(&apft->ctx->file_ctx->fp_mutex);
+                        fprintf(apft->ctx->file_ctx->fp, "%s  [Block Src] [**] [%" PRIu32 ":%" PRIu32 ":%"
+                              PRIu32 "] %s [**] [Classification: %s] [Priority: %"PRIu32"]"
+                              " {%s} %s:%" PRIu32 "\n", timebuf, pa->s->gid,
+                              pa->s->id, pa->s->rev, pa->s->msg, pa->s->class_msg, pa->s->prio,
+                              proto, srcip, p->sp);
+                        fflush(apft->ctx->file_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->file_ctx->fp_mutex);
+                    }
+                } else {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s matched a URL Table Alias IP or FQDN IP Pass List entry - not blocking.\n",
+                              timebuf, tv->name, srcip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                }
+                break;
+
+            case BLOCK_DST:
+                /* Block DST only if IP is not in Pass List */
+                node = SCRadixFindKeyIPV4BestMatch((uint8_t *)GET_IPV4_DST_ADDR_PTR(p), apft->ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        PrintInet(AF_INET, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s covered by Pass List entry %s/%d - not blocking.\n",
+                              timebuf, tv->name, dstip, ip_buffer, node->prefix->user_data->netmask);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    break;
+                }
+
+                /* check our FQDN alias pass list for this DST IP */
+                if (!AlertPfMatchFQDN(apft, (uint8_t *)GET_IPV4_DST_ADDR_PTR(p), AF_INET)) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s did not match any Pass List entry, so adding to block list.\n",
+                              timebuf, tv->name, dstip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    if (AlertPfBlock(tv, apft, &p->dst) > 0) {
+                        SCMutexLock(&apft->ctx->file_ctx->fp_mutex);
+                        fprintf(apft->ctx->file_ctx->fp, "%s  [Block Dst] [**] [%" PRIu32 ":%" PRIu32 ":%"
+                              PRIu32 "] %s [**] [Classification: %s] [Priority: %"PRIu32"]"
+                              " {%s} %s:%" PRIu32 "\n", timebuf, pa->s->gid,
+                              pa->s->id, pa->s->rev, pa->s->msg, pa->s->class_msg, pa->s->prio,
+                              proto, dstip, p->dp);
+                        fflush(apft->ctx->file_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->file_ctx->fp_mutex);
+                    }
+                } else {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s matched a URL Table Alias IP or FQDN IP Pass List entry - not blocking.\n",
+                              timebuf, tv->name, dstip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                }
+                break;
+
+            default:
+                SCLogWarning("Provided value for 'block-ip' parameter in suricata.yaml conf is invalid. Blocking is disabled!");
+                break;
+        }
+
+        /* Release our Read Locks on the Radix Tree and FQDN Pass List */
+        SCRWLockUnlock(&apft->ctx->rwlock_tree);
+        SCRWLockUnlock(&apft->ctx->rwlock_wlist);
+
+        /* Once we block any alert for this packet, we're done */
+        return TM_ECODE_OK;
+    }
+
+    return TM_ECODE_OK;
+}
+
+/** \brief This processes an IPv6 alert and inserts the appropriate
+ * block if the IP address is not on the Pass List.
+ */
+static TmEcode AlertPfIPv6(ThreadVars *tv, void *data, const Packet *p)
+{
+    AlertPfThread *apft = (AlertPfThread *)data;
+    int i;
+    char proto[16] = "";
+    char timebuf[64], ip_buffer[INET6_ADDRSTRLEN + 4];
+    char srcip[INET6_ADDRSTRLEN], dstip[INET6_ADDRSTRLEN];
+
+    if (p->alerts.cnt == 0)
+        return TM_ECODE_OK;
+
+    /* create a time string from the packet's timestamp for the block log */
+    CreateTimeString(p->ts, timebuf, sizeof(timebuf));
+    PrintInet(AF_INET6, (const void *)GET_IPV6_SRC_ADDR(p), srcip, sizeof(srcip));
+    PrintInet(AF_INET6, (const void *)GET_IPV6_DST_ADDR(p), dstip, sizeof(dstip));
+
+    if (SCProtoNameValid(IPV6_GET_L4PROTO(p)) == TRUE) {
+        strlcpy(proto, known_proto[IPV6_GET_L4PROTO(p)], sizeof(proto));
+    } else {
+        snprintf(proto, sizeof(proto), "PROTO:%03" PRIu32, IPV6_GET_L4PROTO(p));
+    }
+
+    /* A packet can generate multiple alerts, so walk the list */
+    for (i = 0; i < p->alerts.cnt; i++) {
+        const PacketAlert *pa = &p->alerts.alerts[i];
+        if (unlikely(pa->s == NULL)) {
+            continue;
+        }
+
+        /* Don't block on alerts where SIG_FLAG_NOALERT is set for the Signature */
+        if (pa->s->flags & SIG_FLAG_NOALERT) {
+            continue;
+        }
+        SC_ATOMIC_ADD(alert_pf_alerts, 1);
+
+        /* If blocking only DROP rules and alert is not from a DROP rule, ignore it */
+        if (apft->ctx->block_drops && !(PacketCheckAction(p, ACTION_DROP))) {
+            continue;
+        }
+
+        void *user_data = NULL;
+        SCRadixNode *node = NULL;
+
+        /* Read Lock the Radix Tree while we are searching it */
+        SCRWLockRDLock(&apft->ctx->rwlock_tree);
+
+        switch (apft->ctx->block_ip) {
+    	    case BLOCK_BOTH:
+                /* Block only if IP is not in Pass List */
+                node = SCRadixFindKeyIPV6BestMatch((uint8_t *)GET_IPV6_SRC_ADDR(p), apft->ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    user_data = NULL;
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        PrintInet(AF_INET6, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s covered by Pass List entry %s/%d - not blocking.\n",
+                              timebuf, tv->name, srcip, ip_buffer, node->prefix->user_data->netmask);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    goto Check_IPv6_DST;
+                }
+
+                /* check our FQDN alias pass list for this SRC IP */
+                if (!AlertPfMatchFQDN(apft, (uint8_t *)GET_IPV6_SRC_ADDR(p), AF_INET6)) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s did not match any Pass List entry, so adding to block list.\n",
+                              timebuf, tv->name, srcip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    if (AlertPfBlock(tv, apft, &p->src) > 0) {
+                        SCMutexLock(&apft->ctx->file_ctx->fp_mutex);
+                        fprintf(apft->ctx->file_ctx->fp, "%s  [Block Src] [**] [%" PRIu32 ":%" PRIu32 ":%"
+                              PRIu32 "] %s [**] [Classification: %s] [Priority: %"PRIu32"]"
+                              " {%s} %s:%" PRIu32 "\n", timebuf, pa->s->gid,
+                              pa->s->id, pa->s->rev, pa->s->msg, pa->s->class_msg, pa->s->prio,
+                              proto, srcip, p->sp);
+                        fflush(apft->ctx->file_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->file_ctx->fp_mutex);
+                    }
+                } else {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s matched a URL Table Alias IP or FQDN IP Pass List entry - not blocking.\n",
+                              timebuf, tv->name, srcip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                }
+
+    Check_IPv6_DST:
+                node = SCRadixFindKeyIPV6BestMatch((uint8_t *)GET_IPV6_DST_ADDR(p), apft->ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        PrintInet(AF_INET6, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s covered by Pass List entry %s/%d - not blocking.\n",
+                              timebuf, tv->name, dstip, ip_buffer, node->prefix->user_data->netmask);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    break;
+                }
+
+                /* check our FQDN alias pass list for this DST IP */
+                if (!AlertPfMatchFQDN(apft, (uint8_t *)GET_IPV6_DST_ADDR(p), AF_INET6)) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s did not match any Pass List entry, so adding to block list.\n",
+                              timebuf, tv->name, dstip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    if (AlertPfBlock(tv, apft, &p->dst) > 0) {
+                        SCMutexLock(&apft->ctx->file_ctx->fp_mutex);
+                        fprintf(apft->ctx->file_ctx->fp, "%s  [Block Dst] [**] [%" PRIu32 ":%" PRIu32 ":%"
+                              PRIu32 "] %s [**] [Classification: %s] [Priority: %"PRIu32"]"
+                              " {%s} %s:%" PRIu32 "\n", timebuf, pa->s->gid,
+                              pa->s->id, pa->s->rev, pa->s->msg, pa->s->class_msg, pa->s->prio,
+                              proto, dstip, p->dp);
+                        fflush(apft->ctx->file_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->file_ctx->fp_mutex);
+                    }
+                } else {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s matched a URL Table Alias IP or FQDN IP Pass List entry - not blocking.\n",
+                              timebuf, tv->name, dstip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                }
+	        break;
+
+	    case BLOCK_SRC:
+                /* Block SRC only if IP is not in Pass List */
+                node = SCRadixFindKeyIPV6BestMatch((uint8_t *)GET_IPV6_SRC_ADDR(p), apft->ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        PrintInet(AF_INET6, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s covered by Pass List entry %s/%d - not blocking.\n",
+                              timebuf, tv->name, srcip, ip_buffer, node->prefix->bitlen);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    break;
+                }
+
+                /* check our FQDN alias pass list for this SRC IP */
+                if (!AlertPfMatchFQDN(apft, (uint8_t *)GET_IPV6_SRC_ADDR(p), AF_INET6)) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s did not match any Pass List entry, so adding to block list.\n",
+                              timebuf, tv->name, srcip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    if (AlertPfBlock(tv, apft, &p->src) > 0) {
+                        SCMutexLock(&apft->ctx->file_ctx->fp_mutex);
+                        fprintf(apft->ctx->file_ctx->fp, "%s  [Block Src] [**] [%" PRIu32 ":%" PRIu32 ":%"
+                              PRIu32 "] %s [**] [Classification: %s] [Priority: %"PRIu32"]"
+                              " {%s} %s:%" PRIu32 "\n", timebuf, pa->s->gid,
+                              pa->s->id, pa->s->rev, pa->s->msg, pa->s->class_msg, pa->s->prio,
+                              proto, srcip, p->sp);
+                        fflush(apft->ctx->file_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->file_ctx->fp_mutex);
+                    }
+                } else {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  SRC IP: %s matched a URL Table Alias IP or FQDN IP Pass List entry - not blocking.\n",
+                              timebuf, tv->name, srcip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                }
+	        break;
+
+	    case BLOCK_DST:
+                /* Block DST only if IP is not in Pass List */
+                node = SCRadixFindKeyIPV6BestMatch((uint8_t *)GET_IPV6_DST_ADDR(p), apft->ctx->tree, &user_data);
+                if (user_data != NULL) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        PrintInet(AF_INET6, (const void *)node->prefix->stream, ip_buffer, sizeof(ip_buffer));
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s covered by Pass List entry %s/%d - not blocking.\n",
+                              timebuf, tv->name, dstip, ip_buffer, node->prefix->user_data->netmask);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    break;
+                }
+
+                /* check our FQDN alias pass list for this DST IP */
+                if (!AlertPfMatchFQDN(apft, (uint8_t *)GET_IPV6_DST_ADDR(p), AF_INET6)) {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s did not match any Pass List entry, so adding to block list.\n",
+                              timebuf, tv->name, dstip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                    if (AlertPfBlock(tv, apft, &p->dst) > 0) {
+                        SCMutexLock(&apft->ctx->file_ctx->fp_mutex);
+                        fprintf(apft->ctx->file_ctx->fp, "%s  [Block Dst] [**] [%" PRIu32 ":%" PRIu32 ":%"
+                              PRIu32 "] %s [**] [Classification: %s] [Priority: %"PRIu32"]"
+                              " {%s} %s:%" PRIu32 "\n", timebuf, pa->s->gid,
+                              pa->s->id, pa->s->rev, pa->s->msg, pa->s->class_msg, pa->s->prio,
+                              proto, dstip, p->dp);
+                        fflush(apft->ctx->file_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->file_ctx->fp_mutex);
+                    }
+                } else {
+                    if (apft->ctx->passlist_dbg) {
+                        SCMutexLock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                        fprintf(apft->ctx->dbgfile_ctx->fp, "%s  Thread: %s  DST IP: %s matched a URL Table Alias IP or FQDN IP Pass List entry - not blocking.\n",
+                              timebuf, tv->name, dstip);
+                        fflush(apft->ctx->dbgfile_ctx->fp);
+                        SCMutexUnlock(&apft->ctx->dbgfile_ctx->fp_mutex);
+                    }
+                }
+                break;
+
+            default:
+                break;
+        }
+
+        /* Release our Read Lock on the Radix Tree */
+        SCRWLockUnlock(&apft->ctx->rwlock_tree);
+
+        /* Once we block any alert for this packet, we're done */
+        return TM_ECODE_OK;
+    }
+
+    return TM_ECODE_OK;
+}
+
+/** \brief This processes an IP alert and routes it to the
+ * appropriate handler.
+ */
+int AlertPf (ThreadVars *tv, void *data, const Packet *p)
+{
+    if (PKT_IS_IPV4(p)) {
+        return AlertPfIPv4(tv, data, p);
+    } else if (PKT_IS_IPV6(p)) {
+        return AlertPfIPv6(tv, data, p);
+    }
+
+    return TM_ECODE_OK;
+}
diff -ruN ./suricata-7.0.2.orig/src/alert-pf.h ./suricata-7.0.2/src/alert-pf.h
--- ./suricata-7.0.2.orig/src/alert-pf.h	1969-12-31 19:00:00.000000000 -0500
+++ ./src/alert-pf.h	2023-08-03 10:51:48.000000000 -0400
@@ -0,0 +1,47 @@
+/* Copyright (C) 2007-2023 Open Information Security Foundation
+ *
+ * You can copy, redistribute or modify this Program under the terms of
+ * the GNU General Public License version 2 as published by the Free
+ * Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * version 2 along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ * Portions of this module are based on previous works of the following:
+ *
+ * Copyright (c) 2023  Bill Meeks
+ * Copyright (c) 2012  Ermal Luci
+ * Copyright (c) 2006  Antonio Benojar <zz.stalker@gmail.com>
+ * Copyright (c) 2005  Antonio Benojar <zz.stalker@gmail.com>
+ * Copyright (c) 2003, 2004 Armin Wolfermann:
+ *
+ * All rights reserved.
+ */
+
+/**
+ * \file
+ *
+ * \author Bill Meeks <billmeeks8@gmail.com>
+ */
+
+#ifndef __ALERT_PF_H__
+#define __ALERT_PF_H__
+
+void AlertPfRegister (void);
+OutputInitResult AlertPfInitCtx(ConfNode *);
+int AlertPfCondition(ThreadVars *tv, void *thread_data, const Packet *p);
+int AlertPf(ThreadVars *, void *, const Packet *);
+TmEcode AlertPfThreadInit(ThreadVars *, const void *, void **);
+TmEcode AlertPfThreadDeinit(ThreadVars *, void *);
+void AlertPfExitPrintStats(ThreadVars *, void *);
+void *AlertPfMonitorIfaceChanges(void *);
+
+#endif /* __ALERT_PF_H__ */
+
diff -ruN ./suricata-7.0.2.orig/src/output.c ./suricata-7.0.2/src/output.c
--- ./suricata-7.0.2.orig/src/output.c	2023-10-18 10:25:29.000000000 -0400
+++ ./src/output.c	2023-08-03 09:32:26.000000000 -0400
@@ -42,6 +42,7 @@
 
 #include "alert-fastlog.h"
 #include "alert-debuglog.h"
+#include "alert-pf.h"
 #include "alert-syslog.h"
 #include "output-json.h"
 #include "output-json-alert.h"
@@ -1045,6 +1046,8 @@
     AlertFastLogRegister();
     /* debug log */
     AlertDebugLogRegister();
+    /* alerf pf */
+    AlertPfRegister();
     /* syslog log */
     AlertSyslogRegister();
     JsonDropLogRegister();
diff -ruN ./suricata-7.0.2.orig/src/suricata-common.h ./suricata-7.0.2/src/suricata-common.h
--- ./suricata-7.0.2.orig/src/suricata-common.h	2023-10-18 10:25:29.000000000 -0400
+++ ./src/suricata-common.h	2023-11-09 12:50:53.000000000 -0500
@@ -489,6 +489,7 @@
     LOGGER_JSON_METADATA,
     LOGGER_JSON_FRAME,
     LOGGER_JSON_STREAM,
+    LOGGER_ALERT_PF,
     LOGGER_SIZE,
 } LoggerId;
 
